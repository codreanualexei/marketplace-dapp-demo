{"ast":null,"code":"import { ed25519 } from '@noble/curves/ed25519';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/** Re-export of noble/curves Ed25519 utilities. */\nexport const noble = ed25519;\n/**\n * Creates a new Ed25519 key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const { privateKey, publicKey } = Ed25519.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const privateKey = randomPrivateKey({\n    as\n  });\n  const publicKey = getPublicKey({\n    privateKey,\n    as\n  });\n  return {\n    privateKey: privateKey,\n    publicKey: publicKey\n  };\n}\n/**\n * Computes the Ed25519 public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const publicKey = Ed25519.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(options) {\n  const {\n    as = 'Hex',\n    privateKey\n  } = options;\n  const privateKeyBytes = Bytes.from(privateKey);\n  const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes);\n  if (as === 'Hex') return Hex.fromBytes(publicKeyBytes);\n  return publicKeyBytes;\n}\n/**\n * Generates a random Ed25519 private key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const privateKey = Ed25519.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey(options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = ed25519.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}\n/**\n * Signs the payload with the provided private key and returns an Ed25519 signature.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const signature = Ed25519.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The Ed25519 signature.\n */\nexport function sign(options) {\n  const {\n    as = 'Hex',\n    payload,\n    privateKey\n  } = options;\n  const payloadBytes = Bytes.from(payload);\n  const privateKeyBytes = Bytes.from(privateKey);\n  const signatureBytes = ed25519.sign(payloadBytes, privateKeyBytes);\n  if (as === 'Hex') return Hex.fromBytes(signatureBytes);\n  return signatureBytes;\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const { privateKey, publicKey } = Ed25519.createKeyPair()\n * const signature = Ed25519.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Ed25519.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options) {\n  const {\n    payload,\n    publicKey,\n    signature\n  } = options;\n  const payloadBytes = Bytes.from(payload);\n  const publicKeyBytes = Bytes.from(publicKey);\n  const signatureBytes = Bytes.from(signature);\n  return ed25519.verify(signatureBytes, payloadBytes, publicKeyBytes);\n}","map":{"version":3,"names":["ed25519","Bytes","Hex","noble","createKeyPair","options","as","privateKey","randomPrivateKey","publicKey","getPublicKey","privateKeyBytes","from","publicKeyBytes","fromBytes","bytes","utils","sign","payload","payloadBytes","signatureBytes","verify","signature"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/Ed25519.ts"],"sourcesContent":["import { ed25519 } from '@noble/curves/ed25519'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/** Re-export of noble/curves Ed25519 utilities. */\nexport const noble = ed25519\n\n/**\n * Creates a new Ed25519 key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const { privateKey, publicKey } = Ed25519.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey, as })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey: publicKey as never,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private and public keys.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | randomPrivateKey.ErrorType\n    | getPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the Ed25519 public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const publicKey = Ed25519.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getPublicKey.Options<as>,\n): getPublicKey.ReturnType<as> {\n  const { as = 'Hex', privateKey } = options\n  const privateKeyBytes = Bytes.from(privateKey)\n  const publicKeyBytes = ed25519.getPublicKey(privateKeyBytes)\n  if (as === 'Hex') return Hex.fromBytes(publicKeyBytes) as never\n  return publicKeyBytes as never\n}\n\nexport declare namespace getPublicKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned public key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random Ed25519 private key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const privateKey = Ed25519.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = ed25519.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Signs the payload with the provided private key and returns an Ed25519 signature.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const signature = Ed25519.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey: '0x...' // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The signing options.\n * @returns The Ed25519 signature.\n */\nexport function sign<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: sign.Options<as>,\n): sign.ReturnType<as> {\n  const { as = 'Hex', payload, privateKey } = options\n  const payloadBytes = Bytes.from(payload)\n  const privateKeyBytes = Bytes.from(privateKey)\n  const signatureBytes = ed25519.sign(payloadBytes, privateKeyBytes)\n  if (as === 'Hex') return Hex.fromBytes(signatureBytes) as never\n  return signatureBytes as never\n}\n\nexport declare namespace sign {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned signature.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Payload to sign.\n     */\n    payload: Hex.Hex | Bytes.Bytes\n    /**\n     * Ed25519 private key.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n * ```ts twoslash\n * import { Ed25519 } from 'ox'\n *\n * const { privateKey, publicKey } = Ed25519.createKeyPair()\n * const signature = Ed25519.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = Ed25519.verify({ // [!code focus]\n *   publicKey, // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport function verify(options: verify.Options): boolean {\n  const { payload, publicKey, signature } = options\n  const payloadBytes = Bytes.from(payload)\n  const publicKeyBytes = Bytes.from(publicKey)\n  const signatureBytes = Bytes.from(signature)\n  return ed25519.verify(signatureBytes, payloadBytes, publicKeyBytes)\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** Public key that signed the payload. */\n    publicKey: Hex.Hex | Bytes.Bytes\n    /** Signature of the payload. */\n    signature: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Bytes.from.ErrorType | Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,uBAAuB;AAC/C,OAAO,KAAKC,KAAK,MAAM,YAAY;AAEnC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAE/B;AACA,OAAO,MAAMC,KAAK,GAAGH,OAAO;AAE5B;;;;;;;;;;;;;AAaA,OAAM,SAAUI,aAAaA,CAC3BC,OAAA,GAAqC,EAAE;EAEvC,MAAM;IAAEC,EAAE,GAAG;EAAK,CAAE,GAAGD,OAAO;EAC9B,MAAME,UAAU,GAAGC,gBAAgB,CAAC;IAAEF;EAAE,CAAE,CAAC;EAC3C,MAAMG,SAAS,GAAGC,YAAY,CAAC;IAAEH,UAAU;IAAED;EAAE,CAAE,CAAC;EAElD,OAAO;IACLC,UAAU,EAAEA,UAAmB;IAC/BE,SAAS,EAAEA;GACZ;AACH;AA2BA;;;;;;;;;;;;;AAaA,OAAM,SAAUC,YAAYA,CAC1BL,OAAiC;EAEjC,MAAM;IAAEC,EAAE,GAAG,KAAK;IAAEC;EAAU,CAAE,GAAGF,OAAO;EAC1C,MAAMM,eAAe,GAAGV,KAAK,CAACW,IAAI,CAACL,UAAU,CAAC;EAC9C,MAAMM,cAAc,GAAGb,OAAO,CAACU,YAAY,CAACC,eAAe,CAAC;EAC5D,IAAIL,EAAE,KAAK,KAAK,EAAE,OAAOJ,GAAG,CAACY,SAAS,CAACD,cAAc,CAAU;EAC/D,OAAOA,cAAuB;AAChC;AAyBA;;;;;;;;;;;;;AAaA,OAAM,SAAUL,gBAAgBA,CAC9BH,OAAA,GAAwC,EAAE;EAE1C,MAAM;IAAEC,EAAE,GAAG;EAAK,CAAE,GAAGD,OAAO;EAC9B,MAAMU,KAAK,GAAGf,OAAO,CAACgB,KAAK,CAACR,gBAAgB,EAAE;EAC9C,IAAIF,EAAE,KAAK,KAAK,EAAE,OAAOJ,GAAG,CAACY,SAAS,CAACC,KAAK,CAAU;EACtD,OAAOA,KAAc;AACvB;AAkBA;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUE,IAAIA,CAClBZ,OAAyB;EAEzB,MAAM;IAAEC,EAAE,GAAG,KAAK;IAAEY,OAAO;IAAEX;EAAU,CAAE,GAAGF,OAAO;EACnD,MAAMc,YAAY,GAAGlB,KAAK,CAACW,IAAI,CAACM,OAAO,CAAC;EACxC,MAAMP,eAAe,GAAGV,KAAK,CAACW,IAAI,CAACL,UAAU,CAAC;EAC9C,MAAMa,cAAc,GAAGpB,OAAO,CAACiB,IAAI,CAACE,YAAY,EAAER,eAAe,CAAC;EAClE,IAAIL,EAAE,KAAK,KAAK,EAAE,OAAOJ,GAAG,CAACY,SAAS,CAACM,cAAc,CAAU;EAC/D,OAAOA,cAAuB;AAChC;AA6BA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUC,MAAMA,CAAChB,OAAuB;EAC5C,MAAM;IAAEa,OAAO;IAAET,SAAS;IAAEa;EAAS,CAAE,GAAGjB,OAAO;EACjD,MAAMc,YAAY,GAAGlB,KAAK,CAACW,IAAI,CAACM,OAAO,CAAC;EACxC,MAAML,cAAc,GAAGZ,KAAK,CAACW,IAAI,CAACH,SAAS,CAAC;EAC5C,MAAMW,cAAc,GAAGnB,KAAK,CAACW,IAAI,CAACU,SAAS,CAAC;EAC5C,OAAOtB,OAAO,CAACqB,MAAM,CAACD,cAAc,EAAED,YAAY,EAAEN,cAAc,CAAC;AACrE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}