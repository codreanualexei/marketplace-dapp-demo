{"ast":null,"code":"/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport * as mod from \"./modular.js\";\nimport { bitLen, bitMask, concatBytes, notImplemented } from \"./utils.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\nfunction calcFrobeniusCoefficients(Fp, nonResidue, modulus, degree, num = 1, divisor) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus = modulus ** BigInt(degree);\n  const res = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = (a * qPower - a) / _divisor % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(Fp, Fp2, base) {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x, y) {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x, y) {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine = fn => (c, P) => {\n    const affine = P.toAffine();\n    const p = fn(affine.x, affine.y);\n    return c.fromAffine({\n      x: p[0],\n      y: p[1]\n    });\n  };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return {\n    psi,\n    psi2,\n    G2psi,\n    G2psi2,\n    PSI_X,\n    PSI_Y,\n    PSI2_X,\n    PSI2_Y\n  };\n}\nexport function tower12(opts) {\n  const {\n    ORDER\n  } = opts;\n  // Fp\n  const Fp = mod.Field(ORDER);\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n  // Fp2\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n  const Fp2Add = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1)\n  });\n  const Fp2Subtract = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1)\n  });\n  const Fp2Multiply = ({\n    c0,\n    c1\n  }, rhs) => {\n    if (typeof rhs === 'bigint') return {\n      c0: Fp.mul(c0, rhs),\n      c1: Fp.mul(c1, rhs)\n    };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const {\n      c0: r0,\n      c1: r1\n    } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return {\n      c0: o0,\n      c1: o1\n    };\n  };\n  const Fp2Square = ({\n    c0,\n    c1\n  }) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return {\n      c0: Fp.mul(a, b),\n      c1: Fp.mul(c, c1)\n    };\n  };\n  const Fp2fromBigTuple = tuple => {\n    if (tuple.length !== 2) throw new Error('invalid tuple');\n    const fps = tuple.map(n => Fp.create(n));\n    return {\n      c0: fps[0],\n      c1: fps[1]\n    };\n  };\n  const FP2_ORDER = ORDER * ORDER;\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n  const Fp2 = {\n    ORDER: FP2_ORDER,\n    isLE: Fp.isLE,\n    NONRESIDUE: Fp2Nonresidue,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: {\n      c0: Fp.ZERO,\n      c1: Fp.ZERO\n    },\n    ONE: {\n      c0: Fp.ONE,\n      c1: Fp.ZERO\n    },\n    create: num => num,\n    isValid: ({\n      c0,\n      c1\n    }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({\n      c0,\n      c1\n    }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({\n      c0,\n      c1\n    }) => ({\n      c0: Fp.neg(c0),\n      c1: Fp.neg(c1)\n    }),\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\n    invertBatch: nums => mod.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) => Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({\n      c0: a,\n      c1: b\n    }) => {\n      // We wish to find the multiplicative inverse of a nonzero\n      // element a + bu in Fp2. We leverage an identity\n      //\n      // (a + bu)(a - bu) = a² + b²\n      //\n      // which holds because u² = -1. This can be rewritten as\n      //\n      // (a + bu)(a - bu)/(a² + b²) = 1\n      //\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\n      // This gives that (a - bu)/(a² + b²) is the inverse\n      // of (a + bu). Importantly, this can be computing using\n      // only a single inversion in Fp.\n      const factor = Fp.inv(Fp.create(a * a + b * b));\n      return {\n        c0: Fp.mul(factor, Fp.create(a)),\n        c1: Fp.mul(factor, Fp.create(-b))\n      };\n    },\n    sqrt: num => {\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\n      // This is generic for all quadratic extensions (Fp2)\n      const {\n        c0,\n        c1\n      } = num;\n      if (Fp.is0(c1)) {\n        // if c0 is quadratic residue\n        if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({\n          c0: Fp.sqrt(c0),\n          c1: Fp.ZERO\n        });else return Fp2.create({\n          c0: Fp.ZERO,\n          c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE))\n        });\n      }\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n      const legendre = mod.FpLegendre(Fp, d);\n      // -1, Quadratic non residue\n      if (legendre === -1) d = Fp.sub(d, a);\n      const a0 = Fp.sqrt(d);\n      const candidateSqrt = Fp2.create({\n        c0: a0,\n        c1: Fp.div(Fp.mul(c1, Fpdiv2), a0)\n      });\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n      const x1 = candidateSqrt;\n      const x2 = Fp2.neg(x1);\n      const {\n        re: re1,\n        im: im1\n      } = Fp2.reim(x1);\n      const {\n        re: re2,\n        im: im2\n      } = Fp2.reim(x2);\n      if (im1 > im2 || im1 === im2 && re1 > re2) return x1;\n      return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: x => {\n      const {\n        re: x0,\n        im: x1\n      } = Fp2.reim(x);\n      const sign_0 = x0 % _2n;\n      const zero_0 = x0 === _0n;\n      const sign_1 = x1 % _2n;\n      return BigInt(sign_0 || zero_0 && sign_1) == _1n;\n    },\n    // Bytes util\n    fromBytes(b) {\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)),\n        c1: Fp.fromBytes(b.subarray(Fp.BYTES))\n      };\n    },\n    toBytes: ({\n      c0,\n      c1\n    }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }, c) => ({\n      c0: Fp.cmov(c0, r0, c),\n      c1: Fp.cmov(c1, r1, c)\n    }),\n    reim: ({\n      c0,\n      c1\n    }) => ({\n      re: c0,\n      im: c1\n    }),\n    // multiply by u + 1\n    mulByNonresidue: ({\n      c0,\n      c1\n    }) => Fp2.mul({\n      c0,\n      c1\n    }, Fp2Nonresidue),\n    mulByB: opts.Fp2mulByB,\n    fromBigTuple: Fp2fromBigTuple,\n    frobeniusMap: ({\n      c0,\n      c1\n    }, power) => ({\n      c0,\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])\n    })\n  };\n  // Fp6\n  const Fp6Add = ({\n    c0,\n    c1,\n    c2\n  }, {\n    c0: r0,\n    c1: r1,\n    c2: r2\n  }) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2)\n  });\n  const Fp6Subtract = ({\n    c0,\n    c1,\n    c2\n  }, {\n    c0: r0,\n    c1: r1,\n    c2: r2\n  }) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2)\n  });\n  const Fp6Multiply = ({\n    c0,\n    c1,\n    c2\n  }, rhs) => {\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs)\n      };\n    }\n    const {\n      c0: r0,\n      c1: r1,\n      c2: r2\n    } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2))\n    };\n  };\n  const Fp6Square = ({\n    c0,\n    c1,\n    c2\n  }) => {\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0),\n      // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1),\n      // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4)\n    };\n  };\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 6, 2, 3);\n  const Fp6 = {\n    ORDER: Fp2.ORDER,\n    // TODO: unused, but need to verify\n    isLE: Fp2.isLE,\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: bitMask(3 * Fp2.BITS),\n    ZERO: {\n      c0: Fp2.ZERO,\n      c1: Fp2.ZERO,\n      c2: Fp2.ZERO\n    },\n    ONE: {\n      c0: Fp2.ONE,\n      c1: Fp2.ZERO,\n      c2: Fp2.ZERO\n    },\n    create: num => num,\n    isValid: ({\n      c0,\n      c1,\n      c2\n    }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({\n      c0,\n      c1,\n      c2\n    }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({\n      c0,\n      c1,\n      c2\n    }) => ({\n      c0: Fp2.neg(c0),\n      c1: Fp2.neg(c1),\n      c2: Fp2.neg(c2)\n    }),\n    eql: ({\n      c0,\n      c1,\n      c2\n    }, {\n      c0: r0,\n      c1: r1,\n      c2: r2\n    }) => Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: notImplemented,\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) => Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\n    invertBatch: nums => mod.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n    inv: ({\n      c0,\n      c1,\n      c2\n    }) => {\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n      let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n      return {\n        c0: Fp2.mul(t4, t0),\n        c1: Fp2.mul(t4, t1),\n        c2: Fp2.mul(t4, t2)\n      };\n    },\n    // Bytes utils\n    fromBytes: b => {\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES))\n      };\n    },\n    toBytes: ({\n      c0,\n      c1,\n      c2\n    }) => concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({\n      c0,\n      c1,\n      c2\n    }, {\n      c0: r0,\n      c1: r1,\n      c2: r2\n    }, c) => ({\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c)\n    }),\n    fromBigSix: t => {\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n      return {\n        c0: Fp2.fromBigTuple(t.slice(0, 2)),\n        c1: Fp2.fromBigTuple(t.slice(2, 4)),\n        c2: Fp2.fromBigTuple(t.slice(4, 6))\n      };\n    },\n    frobeniusMap: ({\n      c0,\n      c1,\n      c2\n    }, power) => ({\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])\n    }),\n    mulByFp2: ({\n      c0,\n      c1,\n      c2\n    }, rhs) => ({\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs)\n    }),\n    mulByNonresidue: ({\n      c0,\n      c1,\n      c2\n    }) => ({\n      c0: Fp2.mulByNonresidue(c2),\n      c1: c0,\n      c2: c1\n    }),\n    // Sparse multiplication\n    mul1: ({\n      c0,\n      c1,\n      c2\n    }, b1) => ({\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1)\n    }),\n    // Sparse multiplication\n    mul01({\n      c0,\n      c1,\n      c2\n    }, b0, b1) {\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1)\n      };\n    }\n  };\n  // Fp12\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp2, Fp2Nonresidue, Fp.ORDER, 12, 1, 6)[0];\n  const Fp12Add = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1)\n  });\n  const Fp12Subtract = ({\n    c0,\n    c1\n  }, {\n    c0: r0,\n    c1: r1\n  }) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1)\n  });\n  const Fp12Multiply = ({\n    c0,\n    c1\n  }, rhs) => {\n    if (typeof rhs === 'bigint') return {\n      c0: Fp6.mul(c0, rhs),\n      c1: Fp6.mul(c1, rhs)\n    };\n    let {\n      c0: r0,\n      c1: r1\n    } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)),\n      // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2))\n    };\n  };\n  const Fp12Square = ({\n    c0,\n    c1\n  }) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n      c1: Fp6.add(ab, ab)\n    }; // AB + AB\n  };\n  function Fp4Square(a, b) {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2),\n      // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2) // (a + b)² - a² - b²\n    };\n  }\n  const Fp12 = {\n    ORDER: Fp2.ORDER,\n    // TODO: unused, but need to verify\n    isLE: Fp6.isLE,\n    BITS: 2 * Fp6.BITS,\n    BYTES: 2 * Fp6.BYTES,\n    MASK: bitMask(2 * Fp6.BITS),\n    ZERO: {\n      c0: Fp6.ZERO,\n      c1: Fp6.ZERO\n    },\n    ONE: {\n      c0: Fp6.ONE,\n      c1: Fp6.ZERO\n    },\n    create: num => num,\n    isValid: ({\n      c0,\n      c1\n    }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({\n      c0,\n      c1\n    }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({\n      c0,\n      c1\n    }) => ({\n      c0: Fp6.neg(c0),\n      c1: Fp6.neg(c1)\n    }),\n    eql: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: notImplemented,\n    inv: ({\n      c0,\n      c1\n    }) => {\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n      return {\n        c0: Fp6.mul(c0, t),\n        c1: Fp6.neg(Fp6.mul(c1, t))\n      }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\n    invertBatch: nums => mod.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n    // Bytes utils\n    fromBytes: b => {\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES))\n      };\n    },\n    toBytes: ({\n      c0,\n      c1\n    }) => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({\n      c0,\n      c1\n    }, {\n      c0: r0,\n      c1: r1\n    }, c) => ({\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c)\n    }),\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: t => ({\n      c0: Fp6.fromBigSix(t.slice(0, 6)),\n      c1: Fp6.fromBigSix(t.slice(6, 12))\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power) {\n      const {\n        c0,\n        c1,\n        c2\n      } = Fp6.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: Fp6.frobeniusMap(lhs.c0, power),\n        c1: Fp6.create({\n          c0: Fp2.mul(c0, coeff),\n          c1: Fp2.mul(c1, coeff),\n          c2: Fp2.mul(c2, coeff)\n        })\n      };\n    },\n    mulByFp2: ({\n      c0,\n      c1\n    }, rhs) => ({\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs)\n    }),\n    conjugate: ({\n      c0,\n      c1\n    }) => ({\n      c0,\n      c1: Fp6.neg(c1)\n    }),\n    // Sparse multiplication\n    mul014: ({\n      c0,\n      c1\n    }, o0, o1, o4) => {\n      let t0 = Fp6.mul01(c0, o0, o1);\n      let t1 = Fp6.mul1(c1, o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0),\n        // T1 * v + T0\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1)\n      };\n    },\n    mul034: ({\n      c0,\n      c1\n    }, o0, o3, o4) => {\n      const a = Fp6.create({\n        c0: Fp2.mul(c0.c0, o0),\n        c1: Fp2.mul(c0.c1, o0),\n        c2: Fp2.mul(c0.c2, o0)\n      });\n      const b = Fp6.mul01(c1, o3, o4);\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n        c1: Fp6.sub(e, Fp6.add(a, b))\n      };\n    },\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: opts.Fp12finalExponentiate\n  };\n  return {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp4Square,\n    Fp12\n  };\n}","map":{"version":3,"names":["mod","bitLen","bitMask","concatBytes","notImplemented","_0n","BigInt","_1n","_2n","_3n","calcFrobeniusCoefficients","Fp","nonResidue","modulus","degree","num","divisor","_divisor","undefined","towerModulus","res","i","a","powers","j","qPower","power","push","pow","psiFrobenius","Fp2","base","PSI_X","ORDER","PSI_Y","psi","x","y","x2","mul","frobeniusMap","y2","PSI2_X","PSI2_Y","eql","neg","ONE","Error","psi2","mapAffine","fn","c","P","affine","toAffine","p","fromAffine","G2psi","G2psi2","tower12","opts","Field","FpNONRESIDUE","create","NONRESIDUE","Fpdiv2","div","FP2_FROBENIUS_COEFFICIENTS","Fp2Add","c0","c1","r0","r1","add","Fp2Subtract","sub","Fp2Multiply","rhs","t1","t2","o0","o1","Fp2Square","b","Fp2fromBigTuple","tuple","length","fps","map","n","FP2_ORDER","Fp2Nonresidue","FP2_NONRESIDUE","isLE","BITS","BYTES","Math","ceil","MASK","ZERO","isValid","is0","FpPow","invertBatch","nums","FpInvertBatch","sqr","addN","subN","mulN","sqrN","lhs","inv","factor","sqrt","Fp2sqrt","FpLegendre","d","legendre","a0","candidateSqrt","x1","re","re1","im","im1","reim","re2","im2","isOdd","x0","sign_0","zero_0","sign_1","fromBytes","subarray","toBytes","cmov","mulByNonresidue","mulByB","Fp2mulByB","fromBigTuple","Fp6Add","c2","r2","Fp6Subtract","Fp6Multiply","t0","Fp6Square","t3","t4","FP6_FROBENIUS_COEFFICIENTS_1","FP6_FROBENIUS_COEFFICIENTS_2","Fp6","fromBigSix","t","Array","isArray","slice","mulByFp2","mul1","b1","mul01","b0","FP12_FROBENIUS_COEFFICIENTS","Fp12Add","Fp12Subtract","Fp12Multiply","Fp12Square","ab","Fp4Square","a2","b2","first","second","Fp12","fromBigTwelve","coeff","conjugate","mul014","o4","mul034","o3","e","_cyclotomicSquare","Fp12cyclotomicSquare","_cyclotomicExp","Fp12cyclotomicExp","finalExponentiate","Fp12finalExponentiate"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/node_modules/@noble/curves/src/abstract/tower.ts"],"sourcesContent":["/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport * as mod from './modular.ts';\nimport { bitLen, bitMask, concatBytes, notImplemented } from './utils.ts';\nimport type { ProjConstructor, ProjPointType } from './weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\n// Fp₂ over complex plane\nexport type BigintTuple = [bigint, bigint];\nexport type Fp = bigint;\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u² - β) where β = -1\nexport type Fp2 = { c0: bigint; c1: bigint };\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\n// prettier-ignore\nexport type BigintTwelve = [\n  bigint, bigint, bigint, bigint, bigint, bigint,\n  bigint, bigint, bigint, bigint, bigint, bigint\n];\n\nexport type Fp2Bls = mod.IField<Fp2> & {\n  reim: (num: Fp2) => { re: Fp; im: Fp };\n  mulByB: (num: Fp2) => Fp2;\n  frobeniusMap(num: Fp2, power: number): Fp2;\n  fromBigTuple(num: [bigint, bigint]): Fp2;\n};\n\nexport type Fp12Bls = mod.IField<Fp12> & {\n  frobeniusMap(num: Fp12, power: number): Fp12;\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n  conjugate(num: Fp12): Fp12;\n  finalExponentiate(num: Fp12): Fp12;\n  fromBigTwelve(num: BigintTwelve): Fp12;\n};\n\nfunction calcFrobeniusCoefficients<T>(\n  Fp: mod.IField<T>,\n  nonResidue: T,\n  modulus: bigint,\n  degree: number,\n  num: number = 1,\n  divisor?: number\n) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus: any = modulus ** BigInt(degree);\n  const res: T[][] = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers: T[] = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(\n  Fp: mod.IField<Fp>,\n  Fp2: Fp2Bls,\n  base: Fp2\n): {\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  G2psi: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\n  G2psi2: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\n  PSI_X: Fp2;\n  PSI_Y: Fp2;\n  PSI2_X: Fp2;\n  PSI2_Y: Fp2;\n} {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine =\n    <T>(fn: (x: T, y: T) => [T, T]) =>\n    (c: ProjConstructor<T>, P: ProjPointType<T>) => {\n      const affine = P.toAffine();\n      const p = fn(affine.x, affine.y);\n      return c.fromAffine({ x: p[0], y: p[1] });\n    };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\n\nexport type Tower12Opts = {\n  ORDER: bigint;\n  NONRESIDUE?: Fp;\n  // Fp2\n  FP2_NONRESIDUE: BigintTuple;\n  Fp2sqrt?: (num: Fp2) => Fp2;\n  Fp2mulByB: (num: Fp2) => Fp2;\n  // Fp12\n  Fp12cyclotomicSquare: (num: Fp12) => Fp12;\n  Fp12cyclotomicExp: (num: Fp12, n: bigint) => Fp12;\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\n};\n\nexport function tower12(opts: Tower12Opts): {\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\n  Fp2: mod.IField<Fp2> & {\n    NONRESIDUE: Fp2;\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\n    reim: (num: Fp2) => { re: bigint; im: bigint };\n    mulByNonresidue: (num: Fp2) => Fp2;\n    mulByB: (num: Fp2) => Fp2;\n    frobeniusMap(num: Fp2, power: number): Fp2;\n  };\n  Fp6: mod.IField<Fp6> & {\n    fromBigSix: (tuple: BigintSix) => Fp6;\n    mulByNonresidue: (num: Fp6) => Fp6;\n    frobeniusMap(num: Fp6, power: number): Fp6;\n    mul1(num: Fp6, b1: Fp2): Fp6;\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  };\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\n  Fp12: mod.IField<Fp12> & {\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\n    frobeniusMap(num: Fp12, power: number): Fp12;\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n    conjugate(num: Fp12): Fp12;\n    finalExponentiate(num: Fp12): Fp12;\n    _cyclotomicSquare(num: Fp12): Fp12;\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n  };\n} {\n  const { ORDER } = opts;\n  // Fp\n  const Fp = mod.Field(ORDER);\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n\n  // Fp2\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n  const Fp2Add = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1),\n  });\n  const Fp2Subtract = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1),\n  });\n  const Fp2Multiply = ({ c0, c1 }: Fp2, rhs: Fp2) => {\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  };\n  const Fp2Square = ({ c0, c1 }: Fp2) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n  };\n  type Fp2Utils = {\n    NONRESIDUE: Fp2;\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\n    reim: (num: Fp2) => { re: bigint; im: bigint };\n    mulByNonresidue: (num: Fp2) => Fp2;\n    mulByB: (num: Fp2) => Fp2;\n    frobeniusMap(num: Fp2, power: number): Fp2;\n  };\n  const Fp2fromBigTuple = (tuple: BigintTuple | bigint[]) => {\n    if (tuple.length !== 2) throw new Error('invalid tuple');\n    const fps = tuple.map((n) => Fp.create(n)) as [Fp, Fp];\n    return { c0: fps[0], c1: fps[1] };\n  };\n\n  const FP2_ORDER = ORDER * ORDER;\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n  const Fp2: mod.IField<Fp2> & Fp2Utils = {\n    ORDER: FP2_ORDER,\n    isLE: Fp.isLE,\n    NONRESIDUE: Fp2Nonresidue,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) =>\n      Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n      // We wish to find the multiplicative inverse of a nonzero\n      // element a + bu in Fp2. We leverage an identity\n      //\n      // (a + bu)(a - bu) = a² + b²\n      //\n      // which holds because u² = -1. This can be rewritten as\n      //\n      // (a + bu)(a - bu)/(a² + b²) = 1\n      //\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\n      // This gives that (a - bu)/(a² + b²) is the inverse\n      // of (a + bu). Importantly, this can be computing using\n      // only a single inversion in Fp.\n      const factor = Fp.inv(Fp.create(a * a + b * b));\n      return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n    },\n    sqrt: (num) => {\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\n      // This is generic for all quadratic extensions (Fp2)\n      const { c0, c1 } = num;\n      if (Fp.is0(c1)) {\n        // if c0 is quadratic residue\n        if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n        else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\n      }\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n      const legendre = mod.FpLegendre(Fp, d);\n      // -1, Quadratic non residue\n      if (legendre === -1) d = Fp.sub(d, a);\n      const a0 = Fp.sqrt(d);\n      const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n      const x1 = candidateSqrt;\n      const x2 = Fp2.neg(x1);\n      const { re: re1, im: im1 } = Fp2.reim(x1);\n      const { re: re2, im: im2 } = Fp2.reim(x2);\n      if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\n      return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: (x: Fp2) => {\n      const { re: x0, im: x1 } = Fp2.reim(x);\n      const sign_0 = x0 % _2n;\n      const zero_0 = x0 === _0n;\n      const sign_1 = x1 % _2n;\n      return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n    },\n    // Bytes util\n    fromBytes(b: Uint8Array): Fp2 {\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp.cmov(c0, r0, c),\n      c1: Fp.cmov(c1, r1, c),\n    }),\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\n    mulByB: opts.Fp2mulByB,\n    fromBigTuple: Fp2fromBigTuple,\n    frobeniusMap: ({ c0, c1 }, power: number): Fp2 => ({\n      c0,\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n    }),\n  };\n  // Fp6\n  const Fp6Add = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2),\n  });\n  const Fp6Subtract = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2),\n  });\n  const Fp6Multiply = ({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) => {\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(\n        t0,\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\n      ),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\n        Fp2.mulByNonresidue(t2)\n      ),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n  };\n  const Fp6Square = ({ c0, c1, c2 }: Fp6) => {\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n  };\n  type Fp6Utils = {\n    fromBigSix: (tuple: BigintSix) => Fp6;\n    mulByNonresidue: (num: Fp6) => Fp6;\n    frobeniusMap(num: Fp6, power: number): Fp6;\n    mul1(num: Fp6, b1: Fp2): Fp6;\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  };\n\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    6,\n    2,\n    3\n  );\n\n  const Fp6: mod.IField<Fp6> & Fp6Utils = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp2.isLE,\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: bitMask(3 * Fp2.BITS),\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) =>\n      Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: notImplemented,\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) =>\n      Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n\n    inv: ({ c0, c1, c2 }) => {\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n      let t4 = Fp2.inv(\n        Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\n      );\n      return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp6 => {\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1, c2 }): Uint8Array =>\n      concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c) => ({\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c),\n    }),\n    fromBigSix: (t: BigintSix): Fp6 => {\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n      return {\n        c0: Fp2.fromBigTuple(t.slice(0, 2)),\n        c1: Fp2.fromBigTuple(t.slice(2, 4)),\n        c2: Fp2.fromBigTuple(t.slice(4, 6)),\n      };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power: number) => ({\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n    }),\n    mulByFp2: ({ c0, c1, c2 }, rhs: Fp2): Fp6 => ({\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs),\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    mul1: ({ c0, c1, c2 }, b1: Fp2): Fp6 => ({\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1),\n    }),\n    // Sparse multiplication\n    mul01({ c0, c1, c2 }, b0: Fp2, b1: Fp2): Fp6 {\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n      };\n    },\n  };\n\n  // Fp12\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    12,\n    1,\n    6\n  )[0];\n\n  const Fp12Add = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1),\n  });\n  const Fp12Subtract = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1),\n  });\n  const Fp12Multiply = ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n  };\n  const Fp12Square = ({ c0, c1 }: Fp12) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\n        Fp6.mulByNonresidue(ab)\n      ),\n      c1: Fp6.add(ab, ab),\n    }; // AB + AB\n  };\n  function Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n    };\n  }\n  type Fp12Utils = {\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\n    frobeniusMap(num: Fp12, power: number): Fp12;\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n    conjugate(num: Fp12): Fp12;\n    finalExponentiate(num: Fp12): Fp12;\n    _cyclotomicSquare(num: Fp12): Fp12;\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n  };\n\n  const Fp12: mod.IField<Fp12> & Fp12Utils = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp6.isLE,\n    BITS: 2 * Fp6.BITS,\n    BYTES: 2 * Fp6.BYTES,\n    MASK: bitMask(2 * Fp6.BITS),\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: notImplemented,\n    inv: ({ c0, c1 }) => {\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n      return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) =>\n      Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp12 => {\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1 }): Uint8Array => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c),\n    }),\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t: BigintTwelve): Fp12 => ({\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power: number) {\n      const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: Fp6.frobeniusMap(lhs.c0, power),\n        c1: Fp6.create({\n          c0: Fp2.mul(c0, coeff),\n          c1: Fp2.mul(c1, coeff),\n          c2: Fp2.mul(c2, coeff),\n        }),\n      };\n    },\n    mulByFp2: ({ c0, c1 }, rhs: Fp2): Fp12 => ({\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs),\n    }),\n    conjugate: ({ c0, c1 }): Fp12 => ({ c0, c1: Fp6.neg(c1) }),\n    // Sparse multiplication\n    mul014: ({ c0, c1 }, o0: Fp2, o1: Fp2, o4: Fp2) => {\n      let t0 = Fp6.mul01(c0, o0, o1);\n      let t1 = Fp6.mul1(c1, o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n      };\n    },\n    mul034: ({ c0, c1 }, o0: Fp2, o3: Fp2, o4: Fp2) => {\n      const a = Fp6.create({\n        c0: Fp2.mul(c0.c0, o0),\n        c1: Fp2.mul(c0.c1, o0),\n        c2: Fp2.mul(c0.c2, o0),\n      });\n      const b = Fp6.mul01(c1, o3, o4);\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n        c1: Fp6.sub(e, Fp6.add(a, b)),\n      };\n    },\n\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: opts.Fp12finalExponentiate,\n  };\n\n  return { Fp, Fp2, Fp6, Fp4Square, Fp12 };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}