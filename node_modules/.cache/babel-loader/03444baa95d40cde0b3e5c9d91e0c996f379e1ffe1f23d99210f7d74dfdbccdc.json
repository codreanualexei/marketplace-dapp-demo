{"ast":null,"code":"import { subscribe, snapshot, unstable_getInternalStates, proxy } from 'valtio/vanilla';\nfunction subscribeKey(proxyObject, key, callback, notifyInSync) {\n  let prevValue = proxyObject[key];\n  return subscribe(proxyObject, () => {\n    const nextValue = proxyObject[key];\n    if (!Object.is(prevValue, nextValue)) {\n      callback(prevValue = nextValue);\n    }\n  }, notifyInSync);\n}\nlet currentCleanups;\nfunction watch(callback, options) {\n  let alive = true;\n  const cleanups = /* @__PURE__ */new Set();\n  const subscriptions = /* @__PURE__ */new Map();\n  const cleanup = () => {\n    if (alive) {\n      alive = false;\n      cleanups.forEach(clean => clean());\n      cleanups.clear();\n      subscriptions.forEach(unsubscribe => unsubscribe());\n      subscriptions.clear();\n    }\n  };\n  const revalidate = async () => {\n    if (!alive) {\n      return;\n    }\n    cleanups.forEach(clean => clean());\n    cleanups.clear();\n    const proxiesToSubscribe = /* @__PURE__ */new Set();\n    const parent = currentCleanups;\n    currentCleanups = cleanups;\n    try {\n      const promiseOrPossibleCleanup = callback(proxyObject => {\n        proxiesToSubscribe.add(proxyObject);\n        if (alive && !subscriptions.has(proxyObject)) {\n          const unsubscribe = subscribe(proxyObject, revalidate, options == null ? void 0 : options.sync);\n          subscriptions.set(proxyObject, unsubscribe);\n        }\n        return proxyObject;\n      });\n      const couldBeCleanup = promiseOrPossibleCleanup && promiseOrPossibleCleanup instanceof Promise ? await promiseOrPossibleCleanup : promiseOrPossibleCleanup;\n      if (couldBeCleanup) {\n        if (alive) {\n          cleanups.add(couldBeCleanup);\n        } else {\n          cleanup();\n        }\n      }\n    } finally {\n      currentCleanups = parent;\n    }\n    subscriptions.forEach((unsubscribe, proxyObject) => {\n      if (!proxiesToSubscribe.has(proxyObject)) {\n        subscriptions.delete(proxyObject);\n        unsubscribe();\n      }\n    });\n  };\n  if (currentCleanups) {\n    currentCleanups.add(cleanup);\n  }\n  revalidate();\n  return cleanup;\n}\nconst DEVTOOLS = Symbol();\nfunction devtools(proxyObject, options) {\n  const {\n    enabled,\n    name = \"\",\n    ...rest\n  } = options || {};\n  let extension;\n  try {\n    extension = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {}\n  if (!extension) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\"[Warning] Please install/enable Redux devtools extension\");\n    }\n    return;\n  }\n  let isTimeTraveling = false;\n  const devtools2 = extension.connect({\n    name,\n    ...rest\n  });\n  const unsub1 = subscribe(proxyObject, ops => {\n    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(\".\")}`).join(\", \");\n    if (!action) {\n      return;\n    }\n    if (isTimeTraveling) {\n      isTimeTraveling = false;\n    } else {\n      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));\n      delete snapWithoutDevtools[DEVTOOLS];\n      devtools2.send({\n        type: action,\n        updatedAt: (/* @__PURE__ */new Date()).toLocaleString()\n      }, snapWithoutDevtools);\n    }\n  });\n  const unsub2 = devtools2.subscribe(message => {\n    var _a, _b, _c, _d, _e, _f;\n    if (message.type === \"ACTION\" && message.payload) {\n      try {\n        Object.assign(proxyObject, JSON.parse(message.payload));\n      } catch (e) {\n        console.error(\"please dispatch a serializable value that JSON.parse() and proxy() support\\n\", e);\n      }\n    }\n    if (message.type === \"DISPATCH\" && message.state) {\n      if (((_a = message.payload) == null ? void 0 : _a.type) === \"JUMP_TO_ACTION\" || ((_b = message.payload) == null ? void 0 : _b.type) === \"JUMP_TO_STATE\") {\n        isTimeTraveling = true;\n        const state = JSON.parse(message.state);\n        Object.assign(proxyObject, state);\n      }\n      proxyObject[DEVTOOLS] = message;\n    } else if (message.type === \"DISPATCH\" && ((_c = message.payload) == null ? void 0 : _c.type) === \"COMMIT\") {\n      devtools2.init(snapshot(proxyObject));\n    } else if (message.type === \"DISPATCH\" && ((_d = message.payload) == null ? void 0 : _d.type) === \"IMPORT_STATE\") {\n      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;\n      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];\n      isTimeTraveling = true;\n      computedStates.forEach(({\n        state\n      }, index) => {\n        const action = actions[index] || \"No action found\";\n        Object.assign(proxyObject, state);\n        if (index === 0) {\n          devtools2.init(snapshot(proxyObject));\n        } else {\n          devtools2.send(action, snapshot(proxyObject));\n        }\n      });\n    }\n  });\n  devtools2.init(snapshot(proxyObject));\n  return () => {\n    unsub1();\n    unsub2 == null ? void 0 : unsub2();\n  };\n}\nconst {\n  proxyStateMap: proxyStateMap$1,\n  snapCache: snapCache$1\n} = unstable_getInternalStates();\nconst isProxy$1 = x => proxyStateMap$1.has(x);\nconst isProxyMap = obj => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Map\" && proxyStateMap$1.has(obj);\n};\nfunction proxyMap(entries) {\n  const initialData = [];\n  let initialIndex = 0;\n  const indexMap = /* @__PURE__ */new Map();\n  const snapMapCache = /* @__PURE__ */new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache$1.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = x => snapMapCache.get(x) || indexMap;\n  if (entries) {\n    if (typeof entries[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\"proxyMap:\\n\tinitial state must be iterable\\n\t\ttip: structure should be [[key, value]]\");\n    }\n    for (const [key, value] of entries) {\n      indexMap.set(key, initialIndex);\n      initialData[initialIndex++] = value;\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy$1(this)) {\n        registerSnapMap();\n      }\n      const map = getMapForThis(this);\n      return map.size;\n    },\n    get(key) {\n      const map = getMapForThis(this);\n      const index = map.get(key);\n      if (index === void 0) {\n        this.epoch;\n        return void 0;\n      }\n      return this.data[index];\n    },\n    has(key) {\n      const map = getMapForThis(this);\n      this.epoch;\n      return map.has(key);\n    },\n    set(key, value) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        indexMap.set(key, this.index);\n        this.data[this.index++] = value;\n      } else {\n        this.data[index] = value;\n      }\n      this.epoch++;\n      return this;\n    },\n    delete(key) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(key);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index, key) => {\n        cb(this.data[index], key, this);\n      });\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const [key, index] of map) {\n        yield [key, this.data[index]];\n      }\n    },\n    *keys() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const key of map.keys()) {\n        yield key;\n      }\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    [Symbol.iterator]() {\n      return this.entries();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Map\";\n    },\n    toJSON() {\n      return new Map(this.entries());\n    }\n  };\n  const proxiedObject = proxy(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: {\n      enumerable: false\n    },\n    index: {\n      enumerable: false\n    },\n    epoch: {\n      enumerable: false\n    },\n    data: {\n      enumerable: false\n    },\n    toJSON: {\n      enumerable: false\n    }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\nconst {\n  proxyStateMap,\n  snapCache\n} = unstable_getInternalStates();\nconst maybeProxify = x => typeof x === \"object\" ? proxy({\n  x\n}).x : x;\nconst isProxy = x => proxyStateMap.has(x);\nconst isProxySet = obj => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Set\" && proxyStateMap.has(obj);\n};\nfunction proxySet(initialValues) {\n  const initialData = [];\n  const indexMap = /* @__PURE__ */new Map();\n  let initialIndex = 0;\n  const snapMapCache = /* @__PURE__ */new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = x => snapMapCache.get(x) || indexMap;\n  if (initialValues) {\n    if (typeof initialValues[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\"not iterable\");\n    }\n    for (const value of initialValues) {\n      if (!indexMap.has(value)) {\n        const v = maybeProxify(value);\n        indexMap.set(v, initialIndex);\n        initialData[initialIndex++] = v;\n      }\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy(this)) {\n        registerSnapMap();\n      }\n      return indexMap.size;\n    },\n    has(value) {\n      const map = getMapForThis(this);\n      const v = maybeProxify(value);\n      this.epoch;\n      return map.has(v);\n    },\n    add(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      if (!indexMap.has(v)) {\n        indexMap.set(v, this.index);\n        this.data[this.index++] = v;\n        this.epoch++;\n      }\n      return this;\n    },\n    delete(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      const index = indexMap.get(v);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(v);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach(index => {\n        cb(this.data[index], this.data[index], this);\n      });\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    keys() {\n      this.epoch;\n      return this.values();\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        const value = this.data[index];\n        yield [value, value];\n      }\n    },\n    toJSON() {\n      return new Set(this.values());\n    },\n    [Symbol.iterator]() {\n      return this.values();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Set\";\n    },\n    intersection(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      const resultSet = proxySet();\n      for (const value of this.values()) {\n        if (otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    union(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        resultSet.add(value);\n      }\n      for (const value of otherSet) {\n        resultSet.add(value);\n      }\n      return proxySet(resultSet);\n    },\n    difference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    symmetricDifference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      for (const value of otherSet.values()) {\n        if (!this.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    isSubsetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size <= other.size && [...this.values()].every(value => otherSet.has(value));\n    },\n    isSupersetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size >= other.size && [...otherSet].every(value => this.has(value));\n    },\n    isDisjointFrom(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return [...this.values()].every(value => !otherSet.has(value));\n    }\n  };\n  const proxiedObject = proxy(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: {\n      enumerable: false\n    },\n    data: {\n      enumerable: false\n    },\n    index: {\n      enumerable: false\n    },\n    epoch: {\n      enumerable: false\n    },\n    toJSON: {\n      enumerable: false\n    }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\nconst isObject = x => typeof x === \"object\" && x !== null;\nlet defaultRefSet;\nconst getDefaultRefSet = () => {\n  if (!defaultRefSet) {\n    defaultRefSet = unstable_getInternalStates().refSet;\n  }\n  return defaultRefSet;\n};\nfunction deepClone(obj, getRefSet = getDefaultRefSet) {\n  if (!isObject(obj) || getRefSet().has(obj)) {\n    return obj;\n  }\n  if (isProxySet(obj)) {\n    return proxySet([...obj]);\n  }\n  if (isProxyMap(obj)) {\n    return proxyMap([...obj.entries()]);\n  }\n  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n  Reflect.ownKeys(obj).forEach(key => {\n    baseObject[key] = deepClone(obj[key], getRefSet);\n  });\n  return baseObject;\n}\nexport { deepClone, devtools, proxyMap, proxySet, subscribeKey, watch };","map":{"version":3,"names":["subscribe","snapshot","unstable_getInternalStates","proxy","subscribeKey","proxyObject","key","callback","notifyInSync","prevValue","nextValue","Object","is","currentCleanups","watch","options","alive","cleanups","Set","subscriptions","Map","cleanup","forEach","clean","clear","unsubscribe","revalidate","proxiesToSubscribe","parent","promiseOrPossibleCleanup","add","has","sync","set","couldBeCleanup","Promise","delete","DEVTOOLS","Symbol","devtools","enabled","name","rest","extension","import","meta","env","MODE","window","__REDUX_DEVTOOLS_EXTENSION__","e","console","warn","isTimeTraveling","devtools2","connect","unsub1","ops","action","filter","_","path","map","op","String","join","snapWithoutDevtools","assign","send","type","updatedAt","Date","toLocaleString","unsub2","message","_a","_b","_c","_d","_e","_f","payload","JSON","parse","error","state","init","actions","nextLiftedState","actionsById","computedStates","index","proxyStateMap","proxyStateMap$1","snapCache","snapCache$1","isProxy$1","x","isProxyMap","obj","toStringTag","proxyMap","entries","initialData","initialIndex","indexMap","snapMapCache","WeakMap","registerSnapMap","cache","get","vObject","latestSnap","clonedMap","getMapForThis","iterator","TypeError","value","data","epoch","size","Error","length","cb","keys","values","toJSON","proxiedObject","defineProperties","enumerable","seal","maybeProxify","isProxy","isProxySet","proxySet","initialValues","v","intersection","other","otherSet","resultSet","union","difference","symmetricDifference","isSubsetOf","every","isSupersetOf","isDisjointFrom","isObject","defaultRefSet","getDefaultRefSet","refSet","deepClone","getRefSet","baseObject","Array","isArray","create","getPrototypeOf","Reflect","ownKeys"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/valtio/esm/vanilla/utils.mjs"],"sourcesContent":["import { subscribe, snapshot, unstable_getInternalStates, proxy } from 'valtio/vanilla';\n\nfunction subscribeKey(proxyObject, key, callback, notifyInSync) {\n  let prevValue = proxyObject[key];\n  return subscribe(\n    proxyObject,\n    () => {\n      const nextValue = proxyObject[key];\n      if (!Object.is(prevValue, nextValue)) {\n        callback(prevValue = nextValue);\n      }\n    },\n    notifyInSync\n  );\n}\n\nlet currentCleanups;\nfunction watch(callback, options) {\n  let alive = true;\n  const cleanups = /* @__PURE__ */ new Set();\n  const subscriptions = /* @__PURE__ */ new Map();\n  const cleanup = () => {\n    if (alive) {\n      alive = false;\n      cleanups.forEach((clean) => clean());\n      cleanups.clear();\n      subscriptions.forEach((unsubscribe) => unsubscribe());\n      subscriptions.clear();\n    }\n  };\n  const revalidate = async () => {\n    if (!alive) {\n      return;\n    }\n    cleanups.forEach((clean) => clean());\n    cleanups.clear();\n    const proxiesToSubscribe = /* @__PURE__ */ new Set();\n    const parent = currentCleanups;\n    currentCleanups = cleanups;\n    try {\n      const promiseOrPossibleCleanup = callback((proxyObject) => {\n        proxiesToSubscribe.add(proxyObject);\n        if (alive && !subscriptions.has(proxyObject)) {\n          const unsubscribe = subscribe(proxyObject, revalidate, options == null ? void 0 : options.sync);\n          subscriptions.set(proxyObject, unsubscribe);\n        }\n        return proxyObject;\n      });\n      const couldBeCleanup = promiseOrPossibleCleanup && promiseOrPossibleCleanup instanceof Promise ? await promiseOrPossibleCleanup : promiseOrPossibleCleanup;\n      if (couldBeCleanup) {\n        if (alive) {\n          cleanups.add(couldBeCleanup);\n        } else {\n          cleanup();\n        }\n      }\n    } finally {\n      currentCleanups = parent;\n    }\n    subscriptions.forEach((unsubscribe, proxyObject) => {\n      if (!proxiesToSubscribe.has(proxyObject)) {\n        subscriptions.delete(proxyObject);\n        unsubscribe();\n      }\n    });\n  };\n  if (currentCleanups) {\n    currentCleanups.add(cleanup);\n  }\n  revalidate();\n  return cleanup;\n}\n\nconst DEVTOOLS = Symbol();\nfunction devtools(proxyObject, options) {\n  const { enabled, name = \"\", ...rest } = options || {};\n  let extension;\n  try {\n    extension = (enabled != null ? enabled : (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extension) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && enabled) {\n      console.warn(\"[Warning] Please install/enable Redux devtools extension\");\n    }\n    return;\n  }\n  let isTimeTraveling = false;\n  const devtools2 = extension.connect({ name, ...rest });\n  const unsub1 = subscribe(proxyObject, (ops) => {\n    const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(\".\")}`).join(\", \");\n    if (!action) {\n      return;\n    }\n    if (isTimeTraveling) {\n      isTimeTraveling = false;\n    } else {\n      const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));\n      delete snapWithoutDevtools[DEVTOOLS];\n      devtools2.send(\n        {\n          type: action,\n          updatedAt: (/* @__PURE__ */ new Date()).toLocaleString()\n        },\n        snapWithoutDevtools\n      );\n    }\n  });\n  const unsub2 = devtools2.subscribe((message) => {\n    var _a, _b, _c, _d, _e, _f;\n    if (message.type === \"ACTION\" && message.payload) {\n      try {\n        Object.assign(proxyObject, JSON.parse(message.payload));\n      } catch (e) {\n        console.error(\n          \"please dispatch a serializable value that JSON.parse() and proxy() support\\n\",\n          e\n        );\n      }\n    }\n    if (message.type === \"DISPATCH\" && message.state) {\n      if (((_a = message.payload) == null ? void 0 : _a.type) === \"JUMP_TO_ACTION\" || ((_b = message.payload) == null ? void 0 : _b.type) === \"JUMP_TO_STATE\") {\n        isTimeTraveling = true;\n        const state = JSON.parse(message.state);\n        Object.assign(proxyObject, state);\n      }\n      proxyObject[DEVTOOLS] = message;\n    } else if (message.type === \"DISPATCH\" && ((_c = message.payload) == null ? void 0 : _c.type) === \"COMMIT\") {\n      devtools2.init(snapshot(proxyObject));\n    } else if (message.type === \"DISPATCH\" && ((_d = message.payload) == null ? void 0 : _d.type) === \"IMPORT_STATE\") {\n      const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;\n      const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];\n      isTimeTraveling = true;\n      computedStates.forEach(({ state }, index) => {\n        const action = actions[index] || \"No action found\";\n        Object.assign(proxyObject, state);\n        if (index === 0) {\n          devtools2.init(snapshot(proxyObject));\n        } else {\n          devtools2.send(action, snapshot(proxyObject));\n        }\n      });\n    }\n  });\n  devtools2.init(snapshot(proxyObject));\n  return () => {\n    unsub1();\n    unsub2 == null ? void 0 : unsub2();\n  };\n}\n\nconst { proxyStateMap: proxyStateMap$1, snapCache: snapCache$1 } = unstable_getInternalStates();\nconst isProxy$1 = (x) => proxyStateMap$1.has(x);\nconst isProxyMap = (obj) => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Map\" && proxyStateMap$1.has(obj);\n};\nfunction proxyMap(entries) {\n  const initialData = [];\n  let initialIndex = 0;\n  const indexMap = /* @__PURE__ */ new Map();\n  const snapMapCache = /* @__PURE__ */ new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache$1.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;\n  if (entries) {\n    if (typeof entries[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\n        \"proxyMap:\\n\tinitial state must be iterable\\n\t\ttip: structure should be [[key, value]]\"\n      );\n    }\n    for (const [key, value] of entries) {\n      indexMap.set(key, initialIndex);\n      initialData[initialIndex++] = value;\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy$1(this)) {\n        registerSnapMap();\n      }\n      const map = getMapForThis(this);\n      return map.size;\n    },\n    get(key) {\n      const map = getMapForThis(this);\n      const index = map.get(key);\n      if (index === void 0) {\n        this.epoch;\n        return void 0;\n      }\n      return this.data[index];\n    },\n    has(key) {\n      const map = getMapForThis(this);\n      this.epoch;\n      return map.has(key);\n    },\n    set(key, value) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        indexMap.set(key, this.index);\n        this.data[this.index++] = value;\n      } else {\n        this.data[index] = value;\n      }\n      this.epoch++;\n      return this;\n    },\n    delete(key) {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const index = indexMap.get(key);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(key);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy$1(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index, key) => {\n        cb(this.data[index], key, this);\n      });\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const [key, index] of map) {\n        yield [key, this.data[index]];\n      }\n    },\n    *keys() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const key of map.keys()) {\n        yield key;\n      }\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    [Symbol.iterator]() {\n      return this.entries();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Map\";\n    },\n    toJSON() {\n      return new Map(this.entries());\n    }\n  };\n  const proxiedObject = proxy(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: { enumerable: false },\n    index: { enumerable: false },\n    epoch: { enumerable: false },\n    data: { enumerable: false },\n    toJSON: { enumerable: false }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\n\nconst { proxyStateMap, snapCache } = unstable_getInternalStates();\nconst maybeProxify = (x) => typeof x === \"object\" ? proxy({ x }).x : x;\nconst isProxy = (x) => proxyStateMap.has(x);\nconst isProxySet = (obj) => {\n  return Symbol.toStringTag in obj && obj[Symbol.toStringTag] === \"Set\" && proxyStateMap.has(obj);\n};\nfunction proxySet(initialValues) {\n  const initialData = [];\n  const indexMap = /* @__PURE__ */ new Map();\n  let initialIndex = 0;\n  const snapMapCache = /* @__PURE__ */ new WeakMap();\n  const registerSnapMap = () => {\n    const cache = snapCache.get(vObject);\n    const latestSnap = cache == null ? void 0 : cache[1];\n    if (latestSnap && !snapMapCache.has(latestSnap)) {\n      const clonedMap = new Map(indexMap);\n      snapMapCache.set(latestSnap, clonedMap);\n    }\n  };\n  const getMapForThis = (x) => snapMapCache.get(x) || indexMap;\n  if (initialValues) {\n    if (typeof initialValues[Symbol.iterator] !== \"function\") {\n      throw new TypeError(\"not iterable\");\n    }\n    for (const value of initialValues) {\n      if (!indexMap.has(value)) {\n        const v = maybeProxify(value);\n        indexMap.set(v, initialIndex);\n        initialData[initialIndex++] = v;\n      }\n    }\n  }\n  const vObject = {\n    data: initialData,\n    index: initialIndex,\n    epoch: 0,\n    get size() {\n      if (!isProxy(this)) {\n        registerSnapMap();\n      }\n      return indexMap.size;\n    },\n    has(value) {\n      const map = getMapForThis(this);\n      const v = maybeProxify(value);\n      this.epoch;\n      return map.has(v);\n    },\n    add(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      if (!indexMap.has(v)) {\n        indexMap.set(v, this.index);\n        this.data[this.index++] = v;\n        this.epoch++;\n      }\n      return this;\n    },\n    delete(value) {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      const v = maybeProxify(value);\n      const index = indexMap.get(v);\n      if (index === void 0) {\n        return false;\n      }\n      delete this.data[index];\n      indexMap.delete(v);\n      this.epoch++;\n      return true;\n    },\n    clear() {\n      if (!isProxy(this)) {\n        throw new Error(\"Cannot perform mutations on a snapshot\");\n      }\n      this.data.length = 0;\n      this.index = 0;\n      this.epoch++;\n      indexMap.clear();\n    },\n    forEach(cb) {\n      this.epoch;\n      const map = getMapForThis(this);\n      map.forEach((index) => {\n        cb(this.data[index], this.data[index], this);\n      });\n    },\n    *values() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        yield this.data[index];\n      }\n    },\n    keys() {\n      this.epoch;\n      return this.values();\n    },\n    *entries() {\n      this.epoch;\n      const map = getMapForThis(this);\n      for (const index of map.values()) {\n        const value = this.data[index];\n        yield [value, value];\n      }\n    },\n    toJSON() {\n      return new Set(this.values());\n    },\n    [Symbol.iterator]() {\n      return this.values();\n    },\n    get [Symbol.toStringTag]() {\n      return \"Set\";\n    },\n    intersection(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      const resultSet = proxySet();\n      for (const value of this.values()) {\n        if (otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    union(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        resultSet.add(value);\n      }\n      for (const value of otherSet) {\n        resultSet.add(value);\n      }\n      return proxySet(resultSet);\n    },\n    difference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    symmetricDifference(other) {\n      this.epoch;\n      const resultSet = proxySet();\n      const otherSet = proxySet(other);\n      for (const value of this.values()) {\n        if (!otherSet.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      for (const value of otherSet.values()) {\n        if (!this.has(value)) {\n          resultSet.add(value);\n        }\n      }\n      return proxySet(resultSet);\n    },\n    isSubsetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size <= other.size && [...this.values()].every((value) => otherSet.has(value));\n    },\n    isSupersetOf(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return this.size >= other.size && [...otherSet].every((value) => this.has(value));\n    },\n    isDisjointFrom(other) {\n      this.epoch;\n      const otherSet = proxySet(other);\n      return [...this.values()].every((value) => !otherSet.has(value));\n    }\n  };\n  const proxiedObject = proxy(vObject);\n  Object.defineProperties(proxiedObject, {\n    size: { enumerable: false },\n    data: { enumerable: false },\n    index: { enumerable: false },\n    epoch: { enumerable: false },\n    toJSON: { enumerable: false }\n  });\n  Object.seal(proxiedObject);\n  return proxiedObject;\n}\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nlet defaultRefSet;\nconst getDefaultRefSet = () => {\n  if (!defaultRefSet) {\n    defaultRefSet = unstable_getInternalStates().refSet;\n  }\n  return defaultRefSet;\n};\nfunction deepClone(obj, getRefSet = getDefaultRefSet) {\n  if (!isObject(obj) || getRefSet().has(obj)) {\n    return obj;\n  }\n  if (isProxySet(obj)) {\n    return proxySet([...obj]);\n  }\n  if (isProxyMap(obj)) {\n    return proxyMap([\n      ...obj.entries()\n    ]);\n  }\n  const baseObject = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));\n  Reflect.ownKeys(obj).forEach((key) => {\n    baseObject[key] = deepClone(obj[key], getRefSet);\n  });\n  return baseObject;\n}\n\nexport { deepClone, devtools, proxyMap, proxySet, subscribeKey, watch };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}