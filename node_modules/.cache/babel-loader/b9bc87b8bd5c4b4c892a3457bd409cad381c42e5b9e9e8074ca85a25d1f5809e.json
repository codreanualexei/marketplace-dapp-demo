{"ast":null,"code":"// Silent WalletConnect wrapper that handles all errors internally\nimport { EthereumProvider } from '@walletconnect/ethereum-provider';\nexport class SilentWalletConnectProvider {\n  constructor() {\n    this.provider = null;\n    this.isConnecting = false;\n    this.retryCount = 0;\n    this.maxRetries = 3;\n  }\n  async init(config) {\n    // If already connecting, return existing provider\n    if (this.isConnecting && this.provider) {\n      return this.provider;\n    }\n    this.isConnecting = true;\n    try {\n      // Clean up existing provider if any\n      if (this.provider) {\n        try {\n          await this.provider.disconnect();\n        } catch (error) {\n          console.log('Silent cleanup error (ignored):', error);\n        }\n        this.provider = null;\n      }\n\n      // Add delay for retries\n      if (this.retryCount > 0) {\n        const delay = 1000 + this.retryCount * 500;\n        console.log(`Silent retry delay: ${delay}ms`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n\n      // Initialize provider with error suppression\n      this.provider = await EthereumProvider.init({\n        ...config,\n        // Add additional configuration to prevent errors\n        disableProviderPing: true,\n        optionalChains: [80002],\n        events: ['session_request', 'session_update', 'session_delete'],\n        methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData']\n      });\n\n      // Override provider methods to suppress errors\n      this.overrideProviderMethods();\n      this.isConnecting = false;\n      this.retryCount = 0;\n      return this.provider;\n    } catch (error) {\n      this.isConnecting = false;\n\n      // Handle connection reset errors silently\n      if (this.isConnectionResetError(error) && this.retryCount < this.maxRetries) {\n        this.retryCount++;\n        console.log(`Silent retry ${this.retryCount}/${this.maxRetries} for connection reset`);\n        return this.init(config);\n      }\n\n      // For other errors, throw them\n      throw error;\n    }\n  }\n  isConnectionResetError(error) {\n    const message = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString()) || '';\n    return message.includes('Connection request reset') || message.includes('Please try again') || message.includes('connection was reset') || message.includes('request was reset') || message.includes('No matching key. session topic doesn\\'t exist');\n  }\n  overrideProviderMethods() {\n    if (!this.provider) return;\n\n    // Override the provider's error handling\n    const originalEmit = this.provider.emit;\n    this.provider.emit = (event, ...args) => {\n      // Suppress connection reset events\n      if (event === 'error' || event === 'session_event') {\n        var _args$, _args$2;\n        const errorMessage = ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$.message) || ((_args$2 = args[0]) === null || _args$2 === void 0 ? void 0 : _args$2.toString()) || '';\n        if (this.isConnectionResetError({\n          message: errorMessage\n        })) {\n          console.log('Silent suppression of WalletConnect event:', event, errorMessage);\n          return true; // Prevent event emission\n        }\n      }\n      return originalEmit.call(this.provider, event, ...args);\n    };\n\n    // Override request method to handle errors\n    const originalRequest = this.provider.request;\n    this.provider.request = async args => {\n      try {\n        return await originalRequest.call(this.provider, args);\n      } catch (error) {\n        if (this.isConnectionResetError(error)) {\n          console.log('Silent suppression of WalletConnect request error:', error.message);\n          // Return a mock response or throw a different error\n          throw new Error('Connection temporarily unavailable');\n        }\n        throw error;\n      }\n    };\n  }\n  async disconnect() {\n    if (this.provider) {\n      try {\n        await this.provider.disconnect();\n      } catch (error) {\n        console.log('Silent disconnect error (ignored):', error);\n      }\n      this.provider = null;\n    }\n    this.isConnecting = false;\n    this.retryCount = 0;\n  }\n  getProvider() {\n    return this.provider;\n  }\n}\n\n// Singleton instance\nexport const silentWalletConnect = new SilentWalletConnectProvider();","map":{"version":3,"names":["EthereumProvider","SilentWalletConnectProvider","constructor","provider","isConnecting","retryCount","maxRetries","init","config","disconnect","error","console","log","delay","Promise","resolve","setTimeout","disableProviderPing","optionalChains","events","methods","overrideProviderMethods","isConnectionResetError","message","toString","includes","originalEmit","emit","event","args","_args$","_args$2","errorMessage","call","originalRequest","request","Error","getProvider","silentWalletConnect"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/src/utils/silentWalletConnect.ts"],"sourcesContent":["// Silent WalletConnect wrapper that handles all errors internally\nimport { EthereumProvider } from '@walletconnect/ethereum-provider';\n\nexport class SilentWalletConnectProvider {\n  private provider: InstanceType<typeof EthereumProvider> | null = null;\n  private isConnecting = false;\n  private retryCount = 0;\n  private maxRetries = 3;\n\n  async init(config: any): Promise<InstanceType<typeof EthereumProvider>> {\n    // If already connecting, return existing provider\n    if (this.isConnecting && this.provider) {\n      return this.provider;\n    }\n\n    this.isConnecting = true;\n\n    try {\n      // Clean up existing provider if any\n      if (this.provider) {\n        try {\n          await this.provider.disconnect();\n        } catch (error) {\n          console.log('Silent cleanup error (ignored):', error);\n        }\n        this.provider = null;\n      }\n\n      // Add delay for retries\n      if (this.retryCount > 0) {\n        const delay = 1000 + (this.retryCount * 500);\n        console.log(`Silent retry delay: ${delay}ms`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n\n      // Initialize provider with error suppression\n      this.provider = await EthereumProvider.init({\n        ...config,\n        // Add additional configuration to prevent errors\n        disableProviderPing: true,\n        optionalChains: [80002],\n        events: ['session_request', 'session_update', 'session_delete'],\n        methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData'],\n      });\n\n      // Override provider methods to suppress errors\n      this.overrideProviderMethods();\n\n      this.isConnecting = false;\n      this.retryCount = 0;\n      return this.provider;\n\n    } catch (error: any) {\n      this.isConnecting = false;\n      \n      // Handle connection reset errors silently\n      if (this.isConnectionResetError(error) && this.retryCount < this.maxRetries) {\n        this.retryCount++;\n        console.log(`Silent retry ${this.retryCount}/${this.maxRetries} for connection reset`);\n        return this.init(config);\n      }\n\n      // For other errors, throw them\n      throw error;\n    }\n  }\n\n  private isConnectionResetError(error: any): boolean {\n    const message = error?.message || error?.toString() || '';\n    return message.includes('Connection request reset') ||\n           message.includes('Please try again') ||\n           message.includes('connection was reset') ||\n           message.includes('request was reset') ||\n           message.includes('No matching key. session topic doesn\\'t exist');\n  }\n\n  private overrideProviderMethods(): void {\n    if (!this.provider) return;\n\n    // Override the provider's error handling\n    const originalEmit = this.provider.emit;\n    this.provider.emit = (event: string, ...args: any[]) => {\n      // Suppress connection reset events\n      if (event === 'error' || event === 'session_event') {\n        const errorMessage = args[0]?.message || args[0]?.toString() || '';\n        if (this.isConnectionResetError({ message: errorMessage })) {\n          console.log('Silent suppression of WalletConnect event:', event, errorMessage);\n          return true; // Prevent event emission\n        }\n      }\n      return originalEmit.call(this.provider, event, ...args);\n    };\n\n    // Override request method to handle errors\n    const originalRequest = this.provider.request;\n    this.provider.request = async (args: any) => {\n      try {\n        return await originalRequest.call(this.provider, args);\n      } catch (error: any) {\n        if (this.isConnectionResetError(error)) {\n          console.log('Silent suppression of WalletConnect request error:', error.message);\n          // Return a mock response or throw a different error\n          throw new Error('Connection temporarily unavailable');\n        }\n        throw error;\n      }\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.provider) {\n      try {\n        await this.provider.disconnect();\n      } catch (error) {\n        console.log('Silent disconnect error (ignored):', error);\n      }\n      this.provider = null;\n    }\n    this.isConnecting = false;\n    this.retryCount = 0;\n  }\n\n  getProvider(): InstanceType<typeof EthereumProvider> | null {\n    return this.provider;\n  }\n}\n\n// Singleton instance\nexport const silentWalletConnect = new SilentWalletConnectProvider();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}