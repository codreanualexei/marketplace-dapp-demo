{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\nimport { Field, FpInvertBatch, mod } from \"./modular.js\";\n// prettier-ignore\nimport { abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes, ensureBytes, memoized, numberToBytesLE, validateObject } from \"./utils.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = {\n  zip215: true\n};\nfunction validateOpts(curve) {\n  const opts = validateBasic(curve);\n  validateObject(curve, {\n    hash: 'function',\n    a: 'bigint',\n    d: 'bigint',\n    randomBytes: 'function'\n  }, {\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    uvRatio: 'function',\n    mapToCurve: 'function'\n  });\n  // Set defaults\n  return Object.freeze(_objectSpread({}, opts));\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << BigInt(nByteLength * 8) - _1n;\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n  function isEdValidXY(x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n  }\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n  // sqrt(u/v)\n  const uvRatio = CURVE.uvRatio || ((u, v) => {\n    try {\n      return {\n        isValid: true,\n        value: Fp.sqrt(u * Fp.inv(v))\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        value: _0n\n      };\n    }\n  });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || (bytes => bytes); // NOOP\n  const domain = CURVE.domain || ((data, ctx, phflag) => {\n    abool('phflag', phflag);\n    if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n    return data;\n  }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title, n) {\n    let banZero = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n  function aextpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p, iz) => {\n    const {\n      ex: x,\n      ey: y,\n      ez: z\n    } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return {\n      x: _0n,\n      y: _1n\n    };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return {\n      x: ax,\n      y: ay\n    };\n  });\n  const assertValidMemo = memoized(p => {\n    const {\n      a,\n      d\n    } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const {\n      ex: X,\n      ey: Y,\n      ez: Z,\n      et: T\n    } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point {\n    constructor(ex, ey, ez, et) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static fromAffine(p) {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const {\n        x,\n        y\n      } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points) {\n      const toInv = FpInvertBatch(Fp, points.map(p => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points, scalars) {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    // Compare one point to another.\n    equals(other) {\n      aextpoint(other);\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1\n      } = this;\n      const {\n        ex: X2,\n        ey: Y2,\n        ez: Z2\n      } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    negate() {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double() {\n      const {\n        a\n      } = CURVE;\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1\n      } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other) {\n      aextpoint(other);\n      const {\n        a,\n        d\n      } = CURVE;\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1,\n        et: T1\n      } = this;\n      const {\n        ex: X2,\n        ey: Y2,\n        ez: Z2,\n        et: T2\n      } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    wNAF(n) {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n    // Constant-time multiplication.\n    multiply(scalar) {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const {\n        p,\n        f\n      } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar) {\n      let acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.ZERO;\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder() {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree() {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz) {\n      return toAffineMemo(this, iz);\n    }\n    clearCofactor() {\n      const {\n        h: cofactor\n      } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex) {\n      let zip215 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const {\n        d,\n        a\n      } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let {\n        isValid,\n        value: x\n      } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({\n        x,\n        y\n      });\n    }\n    static fromPrivateKey(privKey) {\n      const {\n        scalar\n      } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes() {\n      const {\n        x,\n        y\n      } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex() {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  // base / generator point\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n  // zero / infinity / identity point\n  Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n  const {\n    BASE: G,\n    ZERO: I\n  } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n  function modN(a) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash) {\n    return modN(bytesToNumberLE(hash));\n  }\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return {\n      head,\n      prefix,\n      scalar\n    };\n  }\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key) {\n    const {\n      head,\n      prefix,\n      scalar\n    } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return {\n      head,\n      prefix,\n      scalar,\n      point,\n      pointBytes\n    };\n  }\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey) {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Uint8Array.of();\n    for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      msgs[_key - 1] = arguments[_key];\n    }\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg, privKey) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const {\n      prefix,\n      scalar,\n      pointBytes\n    } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n  const verifyOpts = VERIFY_DEFAULT;\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig, msg, publicKey) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : verifyOpts;\n    const {\n      context,\n      zip215\n    } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: () => randomBytes(Fp.BYTES),\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute() {\n      let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n      let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    }\n  };\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils\n  };\n}","map":{"version":3,"names":["pippenger","validateBasic","wNAF","Field","FpInvertBatch","mod","abool","aInRange","bytesToHex","bytesToNumberLE","concatBytes","ensureBytes","memoized","numberToBytesLE","validateObject","_0n","BigInt","_1n","_2n","_8n","VERIFY_DEFAULT","zip215","validateOpts","curve","opts","hash","a","d","randomBytes","adjustScalarBytes","domain","uvRatio","mapToCurve","Object","freeze","_objectSpread","twistedEdwards","curveDef","CURVE","Fp","n","CURVE_ORDER","prehash","cHash","nByteLength","h","cofactor","MASK","modP","create","Fn","nBitLength","isEdValidXY","x","y","x2","sqr","y2","left","add","mul","right","ONE","eql","Gx","Gy","Error","u","v","isValid","value","sqrt","inv","e","bytes","data","ctx","phflag","length","aCoordinate","title","banZero","arguments","undefined","min","aextpoint","other","Point","toAffineMemo","p","iz","ex","ey","ez","z","is0","ax","ay","zz","assertValidMemo","X","Y","Z","et","T","X2","Y2","Z2","Z4","aX2","XY","ZT","constructor","toAffine","fromAffine","normalizeZ","points","toInv","map","i","msm","scalars","_setWindowSize","windowSize","wnaf","setWindowSize","assertValidity","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","T1","T2","subtract","wNAFCached","multiply","scalar","f","multiplyUnsafe","acc","I","wNAFCachedUnsafe","isSmallOrder","isTorsionFree","unsafeLadder","clearCofactor","fromHex","hex","len","BYTES","normed","slice","lastByte","max","ORDER","isXOdd","isLastByteOdd","fromPrivateKey","privKey","getPrivateScalar","toRawBytes","toHex","BASE","modN","modN_LE","key","hashed","head","prefix","getExtendedPublicKey","point","pointBytes","getPublicKey","hashDomainToScalar","context","Uint8Array","of","_len","msgs","Array","_key","msg","sign","options","r","R","k","s","res","verifyOpts","verify","sig","publicKey","SB","error","RkA","utils","randomPrivateKey","precompute","ExtendedPoint"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/node_modules/@noble/curves/src/abstract/edwards.ts"],"sourcesContent":["/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport {\n  pippenger, validateBasic, wNAF,\n  type AffinePoint, type BasicCurve, type Group, type GroupConstructor\n} from './curve.ts';\nimport { Field, FpInvertBatch, mod } from './modular.ts';\n// prettier-ignore\nimport {\n  abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes,\n  ensureBytes, memoized, numberToBytesLE, validateObject,\n  type FHash, type Hex\n} from './utils.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & { nByteLength: number; nBitLength: number }>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType): CurveTypeWithLength {\n  const opts = validateBasic(curve);\n  validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  function isEdValidXY(x: bigint, y: bigint): boolean {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = FpInvertBatch(\n        Fp,\n        points.map((p) => p.ez)\n      );\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex): Point {\n      const { scalar } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}