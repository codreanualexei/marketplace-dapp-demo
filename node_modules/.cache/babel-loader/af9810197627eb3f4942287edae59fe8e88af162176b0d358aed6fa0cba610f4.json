{"ast":null,"code":"import { ctr } from '@noble/ciphers/aes';\nimport { pbkdf2 as pbkdf2_noble, pbkdf2Async as pbkdf2Async_noble } from '@noble/hashes/pbkdf2';\nimport { scrypt as scrypt_noble, scryptAsync as scryptAsync_noble } from '@noble/hashes/scrypt';\nimport { sha256 } from '@noble/hashes/sha2';\nimport * as Bytes from './Bytes.js';\nimport * as Hash from './Hash.js';\n/**\n * Decrypts a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * into a private key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * // Derive the key using your password.\n * const key = Keystore.toKey(keystore, { password: 'hunter2' })\n *\n * // Decrypt the private key.\n * const privateKey = Keystore.decrypt(keystore, key)\n * // @log: \"0x...\"\n * ```\n *\n * @param keystore - JSON keystore.\n * @param key - Key to use for decryption.\n * @param options - Decryption options.\n * @returns Decrypted private key.\n */\nexport function decrypt(keystore, key, options = {}) {\n  const {\n    as = 'Hex'\n  } = options;\n  const key_ = Bytes.from(typeof key === 'function' ? key() : key);\n  const encKey = Bytes.slice(key_, 0, 16);\n  const macKey = Bytes.slice(key_, 16, 32);\n  const ciphertext = Bytes.from(`0x${keystore.crypto.ciphertext}`);\n  const mac = Hash.keccak256(Bytes.concat(macKey, ciphertext));\n  if (!Bytes.isEqual(mac, Bytes.from(`0x${keystore.crypto.mac}`))) throw new Error('corrupt keystore');\n  const data = ctr(encKey, Bytes.from(`0x${keystore.crypto.cipherparams.iv}`)).decrypt(ciphertext);\n  if (as === 'Hex') return Bytes.toHex(data);\n  return data;\n}\n/**\n * Encrypts a private key as a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * using a derived key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // Generate a random private key.\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * // Derive key from password.\n * const [key, opts] = Keystore.pbkdf2({ password: 'testpassword' })\n *\n * // Encrypt the private key.\n * const encrypted = Keystore.encrypt(privateKey, key, opts)\n * // @log: {\n * // @log:   \"crypto\": {\n * // @log:     \"cipher\": \"aes-128-ctr\",\n * // @log:     \"ciphertext\": \"...\",\n * // @log:     \"cipherparams\": {\n * // @log:       \"iv\": \"...\",\n * // @log:     },\n * // @log:     \"kdf\": \"pbkdf2\",\n * // @log:     \"kdfparams\": {\n * // @log:       \"salt\": \"...\",\n * // @log:       \"dklen\": 32,\n * // @log:       \"prf\": \"hmac-sha256\",\n * // @log:       \"c\": 262144,\n * // @log:     },\n * // @log:     \"mac\": \"...\",\n * // @log:   },\n * // @log:   \"id\": \"...\",\n * // @log:   \"version\": 3,\n * // @log: }\n * ```\n *\n * @param privateKey - Private key to encrypt.\n * @param key - Key to use for encryption.\n * @param options - Encryption options.\n * @returns Encrypted keystore.\n */\nexport function encrypt(privateKey, key, options) {\n  const {\n    id = crypto.randomUUID(),\n    kdf,\n    kdfparams,\n    iv\n  } = options;\n  const key_ = Bytes.from(typeof key === 'function' ? key() : key);\n  const value_ = Bytes.from(privateKey);\n  const encKey = Bytes.slice(key_, 0, 16);\n  const macKey = Bytes.slice(key_, 16, 32);\n  const ciphertext = ctr(encKey, iv).encrypt(value_);\n  const mac = Hash.keccak256(Bytes.concat(macKey, ciphertext));\n  return {\n    crypto: {\n      cipher: 'aes-128-ctr',\n      ciphertext: Bytes.toHex(ciphertext).slice(2),\n      cipherparams: {\n        iv: Bytes.toHex(iv).slice(2)\n      },\n      kdf,\n      kdfparams,\n      mac: Bytes.toHex(mac).slice(2)\n    },\n    id,\n    version: 3\n  };\n}\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = Keystore.pbkdf2({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nexport function pbkdf2(options) {\n  const {\n    iv,\n    iterations = 262_144,\n    password\n  } = options;\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32);\n  const key = Bytes.toHex(pbkdf2_noble(sha256, password, salt, {\n    c: iterations,\n    dkLen: 32\n  }));\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      c: iterations,\n      dklen: 32,\n      prf: 'hmac-sha256',\n      salt: Bytes.toHex(salt).slice(2)\n    },\n    kdf: 'pbkdf2'\n  });\n}\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = await Keystore.pbkdf2Async({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nexport async function pbkdf2Async(options) {\n  const {\n    iv,\n    iterations = 262_144,\n    password\n  } = options;\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32);\n  const key = Bytes.toHex(await pbkdf2Async_noble(sha256, password, salt, {\n    c: iterations,\n    dkLen: 32\n  }));\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      c: iterations,\n      dklen: 32,\n      prf: 'hmac-sha256',\n      salt: Bytes.toHex(salt).slice(2)\n    },\n    kdf: 'pbkdf2'\n  });\n}\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = Keystore.scrypt({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nexport function scrypt(options) {\n  const {\n    iv,\n    n = 262_144,\n    password,\n    p = 8,\n    r = 1\n  } = options;\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32);\n  const key = Bytes.toHex(scrypt_noble(password, salt, {\n    N: n,\n    dkLen: 32,\n    r,\n    p\n  }));\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      dklen: 32,\n      n,\n      p,\n      r,\n      salt: Bytes.toHex(salt).slice(2)\n    },\n    kdf: 'scrypt'\n  });\n}\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = await Keystore.scryptAsync({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nexport async function scryptAsync(options) {\n  const {\n    iv,\n    n = 262_144,\n    password\n  } = options;\n  const p = 8;\n  const r = 1;\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32);\n  const key = Bytes.toHex(await scryptAsync_noble(password, salt, {\n    N: n,\n    dkLen: 32,\n    r,\n    p\n  }));\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      dklen: 32,\n      n,\n      p,\n      r,\n      salt: Bytes.toHex(salt).slice(2)\n    },\n    kdf: 'scrypt'\n  });\n}\n/**\n * Extracts a Key from a JSON Keystore to use for decryption.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * const key = Keystore.toKey(keystore, { password: 'hunter2' }) // [!code focus]\n *\n * const decrypted = Keystore.decrypt(keystore, key)\n * ```\n *\n * @param keystore - JSON Keystore\n * @param options - Options\n * @returns Key\n */\nexport function toKey(keystore, options) {\n  const {\n    crypto\n  } = keystore;\n  const {\n    password\n  } = options;\n  const {\n    cipherparams,\n    kdf,\n    kdfparams\n  } = crypto;\n  const {\n    iv\n  } = cipherparams;\n  const {\n    c,\n    n,\n    p,\n    r,\n    salt\n  } = kdfparams;\n  const [key] = (() => {\n    switch (kdf) {\n      case 'scrypt':\n        return scrypt({\n          iv: Bytes.from(`0x${iv}`),\n          n,\n          p,\n          r,\n          salt: Bytes.from(`0x${salt}`),\n          password\n        });\n      case 'pbkdf2':\n        return pbkdf2({\n          iv: Bytes.from(`0x${iv}`),\n          iterations: c,\n          password,\n          salt: Bytes.from(`0x${salt}`)\n        });\n      default:\n        throw new Error('unsupported kdf');\n    }\n  })();\n  return key;\n}\n/**\n * Extracts a Key asynchronously from a JSON Keystore to use for decryption.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * const key = await Keystore.toKeyAsync(keystore, { password: 'hunter2' }) // [!code focus]\n *\n * const decrypted = Keystore.decrypt(keystore, key)\n * ```\n *\n * @param keystore - JSON Keystore\n * @param options - Options\n * @returns Key\n */\nexport async function toKeyAsync(keystore, options) {\n  const {\n    crypto\n  } = keystore;\n  const {\n    password\n  } = options;\n  const {\n    cipherparams,\n    kdf,\n    kdfparams\n  } = crypto;\n  const {\n    iv\n  } = cipherparams;\n  const {\n    c,\n    n,\n    p,\n    r,\n    salt\n  } = kdfparams;\n  const [key] = await (async () => {\n    switch (kdf) {\n      case 'scrypt':\n        return await scryptAsync({\n          iv: Bytes.from(`0x${iv}`),\n          n,\n          p,\n          r,\n          salt: Bytes.from(`0x${salt}`),\n          password\n        });\n      case 'pbkdf2':\n        return await pbkdf2({\n          iv: Bytes.from(`0x${iv}`),\n          iterations: c,\n          password,\n          salt: Bytes.from(`0x${salt}`)\n        });\n      default:\n        throw new Error('unsupported kdf');\n    }\n  })();\n  return key;\n}\n///////////////////////////////////////////////////////////////////////////\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction defineKey(key, options) {\n  const iv = options.iv ? Bytes.from(options.iv) : Bytes.random(16);\n  return [key, {\n    ...options,\n    iv\n  }];\n}","map":{"version":3,"names":["ctr","pbkdf2","pbkdf2_noble","pbkdf2Async","pbkdf2Async_noble","scrypt","scrypt_noble","scryptAsync","scryptAsync_noble","sha256","Bytes","Hash","decrypt","keystore","key","options","as","key_","from","encKey","slice","macKey","ciphertext","crypto","mac","keccak256","concat","isEqual","Error","data","cipherparams","iv","toHex","encrypt","privateKey","id","randomUUID","kdf","kdfparams","value_","cipher","version","iterations","password","salt","random","c","dkLen","defineKey","dklen","prf","n","p","r","N","toKey","toKeyAsync"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/Keystore.ts"],"sourcesContent":["import { ctr } from '@noble/ciphers/aes'\nimport {\n  pbkdf2 as pbkdf2_noble,\n  pbkdf2Async as pbkdf2Async_noble,\n} from '@noble/hashes/pbkdf2'\nimport {\n  scrypt as scrypt_noble,\n  scryptAsync as scryptAsync_noble,\n} from '@noble/hashes/scrypt'\nimport { sha256 } from '@noble/hashes/sha2'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport type * as Hex from './Hex.js'\nimport type { OneOf } from './internal/types.js'\n\n/** Base Derivation Options. */\ntype BaseDeriveOpts<\n  kdf extends string = string,\n  kdfparams extends Record<string, unknown> = Record<string, unknown>,\n> = {\n  iv: Bytes.Bytes\n  kdfparams: kdfparams\n  kdf: kdf\n}\n\n/** Keystore. */\nexport type Keystore = {\n  crypto: {\n    cipher: 'aes-128-ctr'\n    ciphertext: string\n    cipherparams: {\n      iv: string\n    }\n    mac: string\n  } & Pick<DeriveOpts, 'kdf' | 'kdfparams'>\n  id: string\n  version: 3\n}\n\n/** Key. */\nexport type Key = (() => Hex.Hex) | Hex.Hex\n\n/** Derivation Options. */\nexport type DeriveOpts = Pbkdf2DeriveOpts | ScryptDeriveOpts\n\n/** PBKDF2 Derivation Options. */\nexport type Pbkdf2DeriveOpts = BaseDeriveOpts<\n  'pbkdf2',\n  {\n    c: number\n    dklen: number\n    prf: 'hmac-sha256'\n    salt: string\n  }\n>\n\n/** Scrypt Derivation Options. */\nexport type ScryptDeriveOpts = BaseDeriveOpts<\n  'scrypt',\n  {\n    dklen: number\n    n: number\n    p: number\n    r: number\n    salt: string\n  }\n>\n\n/**\n * Decrypts a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * into a private key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * // Derive the key using your password.\n * const key = Keystore.toKey(keystore, { password: 'hunter2' })\n *\n * // Decrypt the private key.\n * const privateKey = Keystore.decrypt(keystore, key)\n * // @log: \"0x...\"\n * ```\n *\n * @param keystore - JSON keystore.\n * @param key - Key to use for decryption.\n * @param options - Decryption options.\n * @returns Decrypted private key.\n */\nexport function decrypt<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  keystore: Keystore,\n  key: Key,\n  options: decrypt.Options<as> = {},\n): decrypt.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const key_ = Bytes.from(typeof key === 'function' ? key() : key)\n\n  const encKey = Bytes.slice(key_, 0, 16)\n  const macKey = Bytes.slice(key_, 16, 32)\n\n  const ciphertext = Bytes.from(`0x${keystore.crypto.ciphertext}`)\n  const mac = Hash.keccak256(Bytes.concat(macKey, ciphertext))\n\n  if (!Bytes.isEqual(mac, Bytes.from(`0x${keystore.crypto.mac}`)))\n    throw new Error('corrupt keystore')\n\n  const data = ctr(\n    encKey,\n    Bytes.from(`0x${keystore.crypto.cipherparams.iv}`),\n  ).decrypt(ciphertext)\n\n  if (as === 'Hex') return Bytes.toHex(data) as never\n  return data as never\n}\n\nexport declare namespace decrypt {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> = {\n    /** Output format. @default 'Hex' */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Hex' ? Hex.Hex : never)\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n}\n\n/**\n * Encrypts a private key as a [JSON keystore](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/)\n * using a derived key.\n *\n * Supports the following key derivation functions (KDFs):\n * - {@link ox#Keystore.(pbkdf2:function)}\n * - {@link ox#Keystore.(scrypt:function)}\n *\n * @example\n * ```ts twoslash\n * import { Keystore, Secp256k1 } from 'ox'\n *\n * // Generate a random private key.\n * const privateKey = Secp256k1.randomPrivateKey()\n *\n * // Derive key from password.\n * const [key, opts] = Keystore.pbkdf2({ password: 'testpassword' })\n *\n * // Encrypt the private key.\n * const encrypted = Keystore.encrypt(privateKey, key, opts)\n * // @log: {\n * // @log:   \"crypto\": {\n * // @log:     \"cipher\": \"aes-128-ctr\",\n * // @log:     \"ciphertext\": \"...\",\n * // @log:     \"cipherparams\": {\n * // @log:       \"iv\": \"...\",\n * // @log:     },\n * // @log:     \"kdf\": \"pbkdf2\",\n * // @log:     \"kdfparams\": {\n * // @log:       \"salt\": \"...\",\n * // @log:       \"dklen\": 32,\n * // @log:       \"prf\": \"hmac-sha256\",\n * // @log:       \"c\": 262144,\n * // @log:     },\n * // @log:     \"mac\": \"...\",\n * // @log:   },\n * // @log:   \"id\": \"...\",\n * // @log:   \"version\": 3,\n * // @log: }\n * ```\n *\n * @param privateKey - Private key to encrypt.\n * @param key - Key to use for encryption.\n * @param options - Encryption options.\n * @returns Encrypted keystore.\n */\nexport function encrypt(\n  privateKey: Bytes.Bytes | Hex.Hex,\n  key: Key,\n  options: encrypt.Options,\n): Keystore {\n  const { id = crypto.randomUUID(), kdf, kdfparams, iv } = options\n\n  const key_ = Bytes.from(typeof key === 'function' ? key() : key)\n  const value_ = Bytes.from(privateKey)\n\n  const encKey = Bytes.slice(key_, 0, 16)\n  const macKey = Bytes.slice(key_, 16, 32)\n\n  const ciphertext = ctr(encKey, iv).encrypt(value_)\n  const mac = Hash.keccak256(Bytes.concat(macKey, ciphertext))\n\n  return {\n    crypto: {\n      cipher: 'aes-128-ctr',\n      ciphertext: Bytes.toHex(ciphertext).slice(2),\n      cipherparams: { iv: Bytes.toHex(iv).slice(2) },\n      kdf,\n      kdfparams,\n      mac: Bytes.toHex(mac).slice(2),\n    } as Keystore['crypto'],\n    id,\n    version: 3,\n  }\n}\n\nexport declare namespace encrypt {\n  type Options = DeriveOpts & {\n    /** UUID. */\n    id?: string | undefined\n  }\n}\n\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = Keystore.pbkdf2({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nexport function pbkdf2(options: pbkdf2.Options) {\n  const { iv, iterations = 262_144, password } = options\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    pbkdf2_noble(sha256, password, salt, { c: iterations, dkLen: 32 }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      c: iterations,\n      dklen: 32,\n      prf: 'hmac-sha256',\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'pbkdf2',\n  }) satisfies [Key, Pbkdf2DeriveOpts]\n}\n\nexport declare namespace pbkdf2 {\n  type Options = {\n    /** The counter to use for the AES-CTR encryption. */\n    iv?: Bytes.Bytes | Hex.Hex | undefined\n    /** The number of iterations to use. @default 262_144 */\n    iterations?: number | undefined\n    /** Password to derive key from. */\n    password: string\n    /** Salt to use for key derivation. @default `Bytes.random(32)` */\n    salt?: Bytes.Bytes | Hex.Hex | undefined\n  }\n}\n\n/**\n * Derives a key from a password using [PBKDF2](https://en.wikipedia.org/wiki/PBKDF2).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = await Keystore.pbkdf2Async({ password: 'testpassword' })\n * ```\n *\n * @param options - PBKDF2 options.\n * @returns PBKDF2 key.\n */\nexport async function pbkdf2Async(options: pbkdf2.Options) {\n  const { iv, iterations = 262_144, password } = options\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    await pbkdf2Async_noble(sha256, password, salt, {\n      c: iterations,\n      dkLen: 32,\n    }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      c: iterations,\n      dklen: 32,\n      prf: 'hmac-sha256',\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'pbkdf2',\n  }) satisfies [Key, Pbkdf2DeriveOpts]\n}\n\nexport declare namespace pbkdf2Async {\n  type Options = pbkdf2.Options\n}\n\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = Keystore.scrypt({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nexport function scrypt(options: scrypt.Options) {\n  const { iv, n = 262_144, password, p = 8, r = 1 } = options\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    scrypt_noble(password, salt, { N: n, dkLen: 32, r, p }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      dklen: 32,\n      n,\n      p,\n      r,\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'scrypt',\n  }) satisfies [Key, ScryptDeriveOpts]\n}\n\nexport declare namespace scrypt {\n  type Options = {\n    /** The counter to use for the AES-CTR encryption. */\n    iv?: Bytes.Bytes | Hex.Hex | undefined\n    /** Cost factor. @default 262_144 */\n    n?: number | undefined\n    /** Parallelization factor. @default 8 */\n    p?: number | undefined\n    /** Block size. @default 1 */\n    r?: number | undefined\n    /** Password to derive key from. */\n    password: string\n    /** Salt to use for key derivation. @default `Bytes.random(32)` */\n    salt?: Bytes.Bytes | Hex.Hex | undefined\n  }\n}\n\n/**\n * Derives a key from a password using [scrypt](https://en.wikipedia.org/wiki/Scrypt).\n *\n * @example\n * ```ts twoslash\n * import { Keystore } from 'ox'\n *\n * const [key, opts] = await Keystore.scryptAsync({ password: 'testpassword' })\n * ```\n *\n * @param options - Scrypt options.\n * @returns Scrypt key.\n */\nexport async function scryptAsync(options: scrypt.Options) {\n  const { iv, n = 262_144, password } = options\n\n  const p = 8\n  const r = 1\n\n  const salt = options.salt ? Bytes.from(options.salt) : Bytes.random(32)\n  const key = Bytes.toHex(\n    await scryptAsync_noble(password, salt, { N: n, dkLen: 32, r, p }),\n  )\n\n  return defineKey(() => key, {\n    iv,\n    kdfparams: {\n      dklen: 32,\n      n,\n      p,\n      r,\n      salt: Bytes.toHex(salt).slice(2),\n    },\n    kdf: 'scrypt',\n  }) satisfies [Key, ScryptDeriveOpts]\n}\n\nexport declare namespace scryptAsync {\n  type Options = scrypt.Options\n}\n\n/**\n * Extracts a Key from a JSON Keystore to use for decryption.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * const key = Keystore.toKey(keystore, { password: 'hunter2' }) // [!code focus]\n *\n * const decrypted = Keystore.decrypt(keystore, key)\n * ```\n *\n * @param keystore - JSON Keystore\n * @param options - Options\n * @returns Key\n */\nexport function toKey(keystore: Keystore, options: toKey.Options): Key {\n  const { crypto } = keystore\n  const { password } = options\n  const { cipherparams, kdf, kdfparams } = crypto\n  const { iv } = cipherparams\n  const { c, n, p, r, salt } = kdfparams as OneOf<\n    Pbkdf2DeriveOpts['kdfparams'] | ScryptDeriveOpts['kdfparams']\n  >\n\n  const [key] = (() => {\n    switch (kdf) {\n      case 'scrypt':\n        return scrypt({\n          iv: Bytes.from(`0x${iv}`),\n          n,\n          p,\n          r,\n          salt: Bytes.from(`0x${salt}`),\n          password,\n        })\n      case 'pbkdf2':\n        return pbkdf2({\n          iv: Bytes.from(`0x${iv}`),\n          iterations: c,\n          password,\n          salt: Bytes.from(`0x${salt}`),\n        })\n      default:\n        throw new Error('unsupported kdf')\n    }\n  })()\n\n  return key\n}\n\nexport declare namespace toKey {\n  type Options = {\n    /** Password to derive key from. */\n    password: string\n  }\n}\n\n/**\n * Extracts a Key asynchronously from a JSON Keystore to use for decryption.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Keystore } from 'ox'\n *\n * // JSON keystore.\n * const keystore = { crypto: { ... }, id: '...', version: 3 }\n *\n * const key = await Keystore.toKeyAsync(keystore, { password: 'hunter2' }) // [!code focus]\n *\n * const decrypted = Keystore.decrypt(keystore, key)\n * ```\n *\n * @param keystore - JSON Keystore\n * @param options - Options\n * @returns Key\n */\nexport async function toKeyAsync(\n  keystore: Keystore,\n  options: toKeyAsync.Options,\n): Promise<Key> {\n  const { crypto } = keystore\n  const { password } = options\n  const { cipherparams, kdf, kdfparams } = crypto\n  const { iv } = cipherparams\n  const { c, n, p, r, salt } = kdfparams as OneOf<\n    Pbkdf2DeriveOpts['kdfparams'] | ScryptDeriveOpts['kdfparams']\n  >\n\n  const [key] = await (async () => {\n    switch (kdf) {\n      case 'scrypt':\n        return await scryptAsync({\n          iv: Bytes.from(`0x${iv}`),\n          n,\n          p,\n          r,\n          salt: Bytes.from(`0x${salt}`),\n          password,\n        })\n      case 'pbkdf2':\n        return await pbkdf2({\n          iv: Bytes.from(`0x${iv}`),\n          iterations: c,\n          password,\n          salt: Bytes.from(`0x${salt}`),\n        })\n      default:\n        throw new Error('unsupported kdf')\n    }\n  })()\n\n  return key\n}\n\nexport declare namespace toKeyAsync {\n  type Options = {\n    /** Password to derive key from. */\n    password: string\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n/** @internal */\n// biome-ignore lint/correctness/noUnusedVariables: _\nfunction defineKey<\n  const key extends Key,\n  const options extends defineKey.Options,\n>(key: key, options: options): [key, options & { iv: Bytes.Bytes }] {\n  const iv = options.iv ? Bytes.from(options.iv) : Bytes.random(16)\n  return [key, { ...options, iv }] as never\n}\n\n/** @internal */\ndeclare namespace defineKey {\n  type Options<\n    kdf extends string = string,\n    kdfparams extends Record<string, unknown> = Record<string, unknown>,\n  > = Omit<BaseDeriveOpts<kdf, kdfparams>, 'iv'> & {\n    iv?: Bytes.Bytes | Hex.Hex | undefined\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}