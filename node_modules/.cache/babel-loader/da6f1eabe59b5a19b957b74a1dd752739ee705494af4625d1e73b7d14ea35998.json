{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as Address from './Address.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nexport const type = 'legacy';\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n  const {\n    chainId,\n    gasPrice,\n    to\n  } = envelope;\n  if (to) Address.assert(to, {\n    strict: false\n  });\n  if (typeof chainId !== 'undefined' && chainId <= 0) throw new TransactionEnvelope.InvalidChainIdError({\n    chainId\n  });\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new TransactionEnvelope.GasPriceTooHighError({\n    gasPrice\n  });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n  const tuple = Rlp.toHex(serialized);\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n  if (!(tuple.length === 6 || tuple.length === 9)) throw new TransactionEnvelope.InvalidSerializedError({\n    attributes: _objectSpread({\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data\n    }, tuple.length > 6 ? {\n      v: chainIdOrV_,\n      r,\n      s\n    } : {}),\n    serialized,\n    type\n  });\n  const transaction = {\n    type\n  };\n  if (Hex.validate(to) && to !== '0x') transaction.to = to;\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas);\n  if (Hex.validate(data) && data !== '0x') transaction.data = data;\n  if (Hex.validate(nonce)) transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce);\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value);\n  if (Hex.validate(gasPrice) && gasPrice !== '0x') transaction.gasPrice = BigInt(gasPrice);\n  if (tuple.length === 6) return transaction;\n  const chainIdOrV = Hex.validate(chainIdOrV_) && chainIdOrV_ !== '0x' ? Number(chainIdOrV_) : 0;\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);\n    return transaction;\n  }\n  const v = chainIdOrV;\n  const chainId = Math.floor((v - 35) / 2);\n  if (chainId > 0) transaction.chainId = chainId;else if (v !== 27 && v !== 28) throw new Signature.InvalidVError({\n    value: v\n  });\n  transaction.yParity = Signature.vToYParity(v);\n  transaction.v = v;\n  transaction.s = s === '0x' ? 0n : BigInt(s);\n  transaction.r = r === '0x' ? 0n : BigInt(r);\n  assert(transaction);\n  return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nexport function from(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signature\n  } = options;\n  const envelope_ = typeof envelope === 'string' ? deserialize(envelope) : envelope;\n  assert(envelope_);\n  const signature_ = (() => {\n    if (!signature) return {};\n    const s = Signature.from(signature);\n    s.v = Signature.yParityToV(s.yParity);\n    return s;\n  })();\n  return _objectSpread(_objectSpread(_objectSpread({}, envelope_), signature_), {}, {\n    type: 'legacy'\n  });\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n  return hash(envelope, {\n    presign: true\n  });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    presign\n  } = options;\n  return Hash.keccak256(serialize(_objectSpread(_objectSpread({}, envelope), presign ? {\n    r: undefined,\n    s: undefined,\n    yParity: undefined,\n    v: undefined\n  } : {})));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope) {\n  var _ref;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    chainId = 0,\n    gas,\n    data,\n    input,\n    nonce,\n    to,\n    value,\n    gasPrice\n  } = envelope;\n  assert(envelope);\n  let serialized = [nonce ? Hex.fromNumber(nonce) : '0x', gasPrice ? Hex.fromNumber(gasPrice) : '0x', gas ? Hex.fromNumber(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? Hex.fromNumber(value) : '0x', (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : '0x'];\n  const signature = (() => {\n    if (options.signature) return {\n      r: options.signature.r,\n      s: options.signature.s,\n      v: Signature.yParityToV(options.signature.yParity)\n    };\n    if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined') return undefined;\n    return {\n      r: envelope.r,\n      s: envelope.s,\n      v: envelope.v\n    };\n  })();\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35) {\n        const inferredChainId = Math.floor((signature.v - 35) / 2);\n        if (inferredChainId > 0) return signature.v;\n        return 27 + (signature.v === 35 ? 0 : 1);\n      }\n      // EIP-155 (explicit chainId)\n      if (chainId > 0) return chainId * 2 + 35 + signature.v - 27;\n      // Pre-EIP-155 (no chainId)\n      const v = 27 + (signature.v === 27 ? 0 : 1);\n      if (signature.v !== v) throw new Signature.InvalidVError({\n        value: signature.v\n      });\n      return v;\n    })();\n    serialized = [...serialized, Hex.fromNumber(v), signature.r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.r)), signature.s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.s))];\n  } else if (chainId > 0) serialized = [...serialized, Hex.fromNumber(chainId), '0x', '0x'];\n  return Rlp.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nexport function toRpc(envelope) {\n  var _envelope$data;\n  const signature = Signature.extract(envelope);\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, envelope), {}, {\n    chainId: typeof envelope.chainId === 'number' ? Hex.fromNumber(envelope.chainId) : undefined,\n    data: (_envelope$data = envelope.data) !== null && _envelope$data !== void 0 ? _envelope$data : envelope.input,\n    type: '0x0'\n  }, typeof envelope.gas === 'bigint' ? {\n    gas: Hex.fromNumber(envelope.gas)\n  } : {}), typeof envelope.nonce === 'bigint' ? {\n    nonce: Hex.fromNumber(envelope.nonce)\n  } : {}), typeof envelope.value === 'bigint' ? {\n    value: Hex.fromNumber(envelope.value)\n  } : {}), typeof envelope.gasPrice === 'bigint' ? {\n    gasPrice: Hex.fromNumber(envelope.gasPrice)\n  } : {}), signature ? _objectSpread(_objectSpread({}, Signature.toRpc(signature)), {}, {\n    v: signature.yParity === 0 ? '0x1b' : '0x1c'\n  }) : {});\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n  try {\n    assert(envelope);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}","map":{"version":3,"names":["Address","Hash","Hex","Rlp","Signature","TransactionEnvelope","type","assert","envelope","chainId","gasPrice","to","strict","InvalidChainIdError","BigInt","GasPriceTooHighError","deserialize","serialized","tuple","toHex","nonce","gas","value","data","chainIdOrV_","r","s","length","InvalidSerializedError","attributes","_objectSpread","v","transaction","validate","chainIdOrV","Number","Math","floor","InvalidVError","yParity","vToYParity","from","options","arguments","undefined","signature","envelope_","signature_","yParityToV","getSignPayload","hash","presign","keccak256","serialize","_ref","input","fromNumber","inferredChainId","trimLeft","fromHex","toRpc","_envelope$data","extract","_unused"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/TransactionEnvelopeLegacy.ts"],"sourcesContent":["import * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Branded,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TransactionEnvelope.js'\n\nexport type TransactionEnvelopeLegacy<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  PartialBy<\n    TransactionEnvelope.Base<type, signed, bigintType, numberType>,\n    'chainId'\n  > & {\n    /** Base fee per gas. */\n    gasPrice?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TransactionEnvelopeLegacy<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x0'\n>\n\nexport type Serialized = Branded<`0x${string}`, 'legacy'>\n\nexport type Signed = TransactionEnvelopeLegacy<true>\n\nexport const type = 'legacy'\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope: PartialBy<TransactionEnvelopeLegacy, 'type'>) {\n  const { chainId, gasPrice, to } = envelope\n  if (to) Address.assert(to, { strict: false })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.GasPriceTooHighError({ gasPrice })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | TransactionEnvelope.GasPriceTooHighError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Hex.Hex,\n): Compute<TransactionEnvelopeLegacy> {\n  const tuple = Rlp.toHex(serialized)\n\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] =\n    tuple as readonly Hex.Hex[]\n\n  if (!(tuple.length === 6 || tuple.length === 9))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        ...(tuple.length > 6\n          ? {\n              v: chainIdOrV_,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  const transaction = {\n    type,\n  } as TransactionEnvelopeLegacy\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = BigInt(gasPrice)\n\n  if (tuple.length === 6) return transaction\n\n  const chainIdOrV =\n    Hex.validate(chainIdOrV_) && chainIdOrV_ !== '0x'\n      ? Number(chainIdOrV_ as Hex.Hex)\n      : 0\n\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV)\n    return transaction\n  }\n\n  const v = chainIdOrV\n  const chainId: number | undefined = Math.floor((v - 35) / 2)\n  if (chainId > 0) transaction.chainId = chainId\n  else if (v !== 27 && v !== 28) throw new Signature.InvalidVError({ value: v })\n\n  transaction.yParity = Signature.vToYParity(v)\n  transaction.v = v\n  transaction.s = s === '0x' ? 0n : BigInt(s!)\n  transaction.r = r === '0x' ? 0n : BigInt(r!)\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nexport function from<\n  const envelope extends\n    | UnionPartialBy<TransactionEnvelopeLegacy, 'type'>\n    | Hex.Hex,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope:\n    | envelope\n    | UnionPartialBy<TransactionEnvelopeLegacy, 'type'>\n    | Hex.Hex,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TransactionEnvelopeLegacy\n\n  assert(envelope_)\n\n  const signature_ = (() => {\n    if (!signature) return {}\n    const s = Signature.from(signature) as any\n    s.v = Signature.yParityToV(s.yParity)\n    return s\n  })()\n\n  return {\n    ...envelope_,\n    ...signature_,\n    type: 'legacy',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends\n      | UnionPartialBy<TransactionEnvelopeLegacy, 'type'>\n      | Hex.Hex = TransactionEnvelopeLegacy | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TransactionEnvelopeLegacy\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature\n            ? Readonly<\n                signature & {\n                  v: signature['yParity'] extends 0 ? 27 : 28\n                }\n              >\n            : {}) & {\n            readonly type: 'legacy'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TransactionEnvelopeLegacy<false>,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TransactionEnvelopeLegacy<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TransactionEnvelopeLegacy, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope\n\n  assert(envelope)\n\n  let serialized = [\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    gasPrice ? Hex.fromNumber(gasPrice) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n  ]\n\n  const signature = (() => {\n    if (options.signature)\n      return {\n        r: options.signature.r,\n        s: options.signature.s,\n        v: Signature.yParityToV(options.signature.yParity),\n      }\n\n    if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined')\n      return undefined\n    return {\n      r: envelope.r,\n      s: envelope.s,\n      v: envelope.v!,\n    }\n  })()\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35) {\n        const inferredChainId = Math.floor((signature.v - 35) / 2)\n        if (inferredChainId > 0) return signature.v\n        return 27 + (signature.v === 35 ? 0 : 1)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0) return chainId * 2 + 35 + signature.v - 27\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27 + (signature.v === 27 ? 0 : 1)\n      if (signature.v !== v)\n        throw new Signature.InvalidVError({ value: signature.v })\n      return v\n    })()\n\n    serialized = [\n      ...serialized,\n      Hex.fromNumber(v),\n      signature.r === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.r)),\n      signature.s === 0n ? '0x' : Hex.trimLeft(Hex.fromNumber(signature.s)),\n    ]\n  } else if (chainId > 0)\n    serialized = [...serialized, Hex.fromNumber(chainId), '0x', '0x']\n\n  return Rlp.fromHex(serialized) as never\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Hex.trimLeft.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Signature.InvalidVError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nexport function toRpc(envelope: Omit<TransactionEnvelopeLegacy, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)!\n\n  return {\n    ...envelope,\n    chainId:\n      typeof envelope.chainId === 'number'\n        ? Hex.fromNumber(envelope.chainId)\n        : undefined,\n    data: envelope.data ?? envelope.input,\n    type: '0x0',\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.gasPrice === 'bigint'\n      ? { gasPrice: Hex.fromNumber(envelope.gasPrice) }\n      : {}),\n    ...(signature\n      ? {\n          ...Signature.toRpc(signature),\n          v: signature.yParity === 0 ? '0x1b' : '0x1c',\n        }\n      : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(\n  envelope: PartialBy<TransactionEnvelopeLegacy, 'type'>,\n) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}