{"ast":null,"code":"import { utf8DecodeJs } from \"./utils/utf8.mjs\";\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\nexport class CachedKeyDecoder {\n  constructor() {\n    let maxKeyLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MAX_KEY_LENGTH;\n    let maxLengthPerKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MAX_LENGTH_PER_KEY;\n    this.hit = 0;\n    this.miss = 0;\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n  canBeCached(byteLength) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n  find(bytes, inputOffset, byteLength) {\n    const records = this.caches[byteLength - 1];\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n  store(bytes, value) {\n    const records = this.caches[bytes.length - 1];\n    const record = {\n      bytes,\n      str: value\n    };\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[Math.random() * records.length | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n  decode(bytes, inputOffset, byteLength) {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}","map":{"version":3,"names":["utf8DecodeJs","DEFAULT_MAX_KEY_LENGTH","DEFAULT_MAX_LENGTH_PER_KEY","CachedKeyDecoder","constructor","maxKeyLength","arguments","length","undefined","maxLengthPerKey","hit","miss","caches","i","push","canBeCached","byteLength","find","bytes","inputOffset","records","FIND_CHUNK","record","recordBytes","j","str","store","value","Math","random","decode","cachedValue","slicedCopyOfBytes","Uint8Array","prototype","slice","call"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@msgpack/msgpack/src/CachedKeyDecoder.ts"],"sourcesContent":["import { utf8DecodeJs } from \"./utils/utf8.ts\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n  readonly maxKeyLength: number;\n  readonly maxLengthPerKey: number;\n\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}