{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as AccessList from './AccessList.js';\nimport * as Address from './Address.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nexport const serializedType = '0x01';\nexport const type = 'eip2930';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n  const {\n    chainId,\n    gasPrice,\n    to\n  } = envelope;\n  if (chainId <= 0) throw new TransactionEnvelope.InvalidChainIdError({\n    chainId\n  });\n  if (to) Address.assert(to, {\n    strict: false\n  });\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new TransactionEnvelope.GasPriceTooHighError({\n    gasPrice\n  });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1));\n  const [chainId, nonce, gasPrice, gas, to, value, data, accessList, yParity, r, s] = transactionArray;\n  if (!(transactionArray.length === 8 || transactionArray.length === 11)) throw new TransactionEnvelope.InvalidSerializedError({\n    attributes: _objectSpread({\n      chainId,\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data,\n      accessList\n    }, transactionArray.length > 8 ? {\n      yParity,\n      r,\n      s\n    } : {}),\n    serialized,\n    type\n  });\n  let transaction = {\n    chainId: Number(chainId),\n    type\n  };\n  if (Hex.validate(to) && to !== '0x') transaction.to = to;\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas);\n  if (Hex.validate(data) && data !== '0x') transaction.data = data;\n  if (Hex.validate(nonce)) transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce);\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value);\n  if (Hex.validate(gasPrice) && gasPrice !== '0x') transaction.gasPrice = BigInt(gasPrice);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = AccessList.fromTupleList(accessList);\n  const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n  if (signature) transaction = _objectSpread(_objectSpread({}, transaction), signature);\n  assert(transaction);\n  return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */\nexport function from(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signature\n  } = options;\n  const envelope_ = typeof envelope === 'string' ? deserialize(envelope) : envelope;\n  assert(envelope_);\n  return _objectSpread(_objectSpread(_objectSpread({}, envelope_), signature ? Signature.from(signature) : {}), {}, {\n    type: 'eip2930'\n  });\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n  return hash(envelope, {\n    presign: true\n  });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    presign\n  } = options;\n  return Hash.keccak256(serialize(_objectSpread(_objectSpread({}, envelope), presign ? {\n    r: undefined,\n    s: undefined,\n    yParity: undefined,\n    v: undefined\n  } : {})));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope) {\n  var _ref;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    chainId,\n    gas,\n    data,\n    input,\n    nonce,\n    to,\n    value,\n    accessList,\n    gasPrice\n  } = envelope;\n  assert(envelope);\n  const accessTupleList = AccessList.toTupleList(accessList);\n  const signature = Signature.extract(options.signature || envelope);\n  const serialized = [Hex.fromNumber(chainId), nonce ? Hex.fromNumber(nonce) : '0x', gasPrice ? Hex.fromNumber(gasPrice) : '0x', gas ? Hex.fromNumber(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? Hex.fromNumber(value) : '0x', (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : '0x', accessTupleList, ...(signature ? Signature.toTuple(signature) : [])];\n  return Hex.concat('0x01', Rlp.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */\nexport function toRpc(envelope) {\n  var _envelope$data;\n  const signature = Signature.extract(envelope);\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, envelope), {}, {\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: (_envelope$data = envelope.data) !== null && _envelope$data !== void 0 ? _envelope$data : envelope.input\n  }, typeof envelope.gas === 'bigint' ? {\n    gas: Hex.fromNumber(envelope.gas)\n  } : {}), typeof envelope.nonce === 'bigint' ? {\n    nonce: Hex.fromNumber(envelope.nonce)\n  } : {}), typeof envelope.value === 'bigint' ? {\n    value: Hex.fromNumber(envelope.value)\n  } : {}), typeof envelope.gasPrice === 'bigint' ? {\n    gasPrice: Hex.fromNumber(envelope.gasPrice)\n  } : {}), {}, {\n    type: '0x1'\n  }, signature ? Signature.toRpc(signature) : {});\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n  try {\n    assert(envelope);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}","map":{"version":3,"names":["AccessList","Address","Hash","Hex","Rlp","Signature","TransactionEnvelope","serializedType","type","assert","envelope","chainId","gasPrice","to","InvalidChainIdError","strict","BigInt","GasPriceTooHighError","deserialize","serialized","transactionArray","toHex","slice","nonce","gas","value","data","accessList","yParity","r","s","length","InvalidSerializedError","attributes","_objectSpread","transaction","Number","validate","fromTupleList","signature","fromTuple","undefined","from","options","arguments","envelope_","getSignPayload","hash","presign","keccak256","serialize","v","_ref","input","accessTupleList","toTupleList","extract","fromNumber","toTuple","concat","fromHex","toRpc","_envelope$data","_unused"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/TransactionEnvelopeEip2930.ts"],"sourcesContent":["import * as AccessList from './AccessList.js'\nimport * as Address from './Address.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TransactionEnvelope.js'\n\nexport type TransactionEnvelopeEip2930<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** Base fee per gas. */\n    gasPrice?: bigintType | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TransactionEnvelopeEip2930<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x1'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport const serializedType = '0x01' as const\nexport type SerializedType = typeof serializedType\n\nexport type Signed = TransactionEnvelopeEip2930<true>\n\nexport const type = 'eip2930' as const\nexport type Type = typeof type\n\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(\n  envelope: PartialBy<TransactionEnvelopeEip2930, 'type'>,\n) {\n  const { chainId, gasPrice, to } = envelope\n  if (chainId <= 0)\n    throw new TransactionEnvelope.InvalidChainIdError({ chainId })\n  if (to) Address.assert(to, { strict: false })\n  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n    throw new TransactionEnvelope.GasPriceTooHighError({ gasPrice })\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | Address.assert.ErrorType\n    | TransactionEnvelope.InvalidChainIdError\n    | TransactionEnvelope.GasPriceTooHighError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Serialized,\n): TransactionEnvelopeEip2930 {\n  const transactionArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const [\n    chainId,\n    nonce,\n    gasPrice,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    yParity,\n    r,\n    s,\n  ] = transactionArray as readonly Hex.Hex[]\n\n  if (!(transactionArray.length === 8 || transactionArray.length === 11))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 8\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    chainId: Number(chainId as Hex.Hex),\n    type,\n  } as TransactionEnvelopeEip2930\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = BigInt(gasPrice)\n  if (accessList!.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as any)\n\n  const signature =\n    r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TransactionEnvelopeEip2930\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */\nexport function from<\n  const envelope extends\n    | UnionPartialBy<TransactionEnvelopeEip2930, 'type'>\n    | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope:\n    | envelope\n    | UnionPartialBy<TransactionEnvelopeEip2930, 'type'>\n    | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TransactionEnvelopeEip2930\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip2930',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends\n      | UnionPartialBy<TransactionEnvelopeEip2930, 'type'>\n      | Hex.Hex = TransactionEnvelopeEip2930 | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TransactionEnvelopeEip2930\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip2930'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TransactionEnvelopeEip2930,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TransactionEnvelopeEip2930<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TransactionEnvelopeEip2930, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } =\n    envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n\n  const signature = Signature.extract(options.signature || (envelope as any))\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    gasPrice ? Hex.fromNumber(gasPrice) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? input ?? '0x',\n    accessTupleList,\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as const\n\n  return Hex.concat('0x01', Rlp.fromHex(serialized)) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */\nexport function toRpc(envelope: Omit<TransactionEnvelopeEip2930, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)!\n\n  return {\n    ...envelope,\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: envelope.data ?? envelope.input,\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.gasPrice === 'bigint'\n      ? { gasPrice: Hex.fromNumber(envelope.gasPrice) }\n      : {}),\n    type: '0x1',\n    ...(signature ? Signature.toRpc(signature) : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(\n  envelope: PartialBy<TransactionEnvelopeEip2930, 'type'>,\n) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}