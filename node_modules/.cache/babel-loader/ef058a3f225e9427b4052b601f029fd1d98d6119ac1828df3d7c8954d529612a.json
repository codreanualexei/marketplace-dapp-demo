{"ast":null,"code":"import { x25519 } from '@noble/curves/ed25519';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\n/** Re-export of noble/curves X25519 utilities. */\nexport const noble = x25519;\n/**\n * Creates a new X25519 key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const { privateKey, publicKey } = X25519.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    as = 'Hex'\n  } = options;\n  const privateKey = randomPrivateKey({\n    as\n  });\n  const publicKey = getPublicKey({\n    privateKey,\n    as\n  });\n  return {\n    privateKey: privateKey,\n    publicKey: publicKey\n  };\n}\n/**\n * Computes the X25519 public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const publicKey = X25519.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey(options) {\n  const {\n    as = 'Hex',\n    privateKey\n  } = options;\n  const privateKeyBytes = Bytes.from(privateKey);\n  const publicKeyBytes = x25519.getPublicKey(privateKeyBytes);\n  if (as === 'Hex') return Hex.fromBytes(publicKeyBytes);\n  return publicKeyBytes;\n}\n/**\n * Computes a shared secret using X25519 elliptic curve Diffie-Hellman between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const { privateKey: privateKeyA } = X25519.createKeyPair()\n * const { publicKey: publicKeyB } = X25519.createKeyPair()\n *\n * const sharedSecret = X25519.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret(options) {\n  const {\n    as = 'Hex',\n    privateKey,\n    publicKey\n  } = options;\n  const privateKeyBytes = Bytes.from(privateKey);\n  const publicKeyBytes = Bytes.from(publicKey);\n  const sharedSecretBytes = x25519.getSharedSecret(privateKeyBytes, publicKeyBytes);\n  if (as === 'Hex') return Hex.fromBytes(sharedSecretBytes);\n  return sharedSecretBytes;\n}\n/**\n * Generates a random X25519 private key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const privateKey = X25519.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    as = 'Hex'\n  } = options;\n  const bytes = x25519.utils.randomPrivateKey();\n  if (as === 'Hex') return Hex.fromBytes(bytes);\n  return bytes;\n}","map":{"version":3,"names":["x25519","Bytes","Hex","noble","createKeyPair","options","arguments","length","undefined","as","privateKey","randomPrivateKey","publicKey","getPublicKey","privateKeyBytes","from","publicKeyBytes","fromBytes","getSharedSecret","sharedSecretBytes","bytes","utils"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/X25519.ts"],"sourcesContent":["import { x25519 } from '@noble/curves/ed25519'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\n\n/** Re-export of noble/curves X25519 utilities. */\nexport const noble = x25519\n\n/**\n * Creates a new X25519 key pair consisting of a private key and its corresponding public key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const { privateKey, publicKey } = X25519.createKeyPair()\n * ```\n *\n * @param options - The options to generate the key pair.\n * @returns The generated key pair containing both private and public keys.\n */\nexport function createKeyPair<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: createKeyPair.Options<as> = {},\n): createKeyPair.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const privateKey = randomPrivateKey({ as })\n  const publicKey = getPublicKey({ privateKey, as })\n\n  return {\n    privateKey: privateKey as never,\n    publicKey: publicKey as never,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private and public keys.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> = {\n    privateKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n    publicKey:\n      | (as extends 'Bytes' ? Bytes.Bytes : never)\n      | (as extends 'Hex' ? Hex.Hex : never)\n  }\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | randomPrivateKey.ErrorType\n    | getPublicKey.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes the X25519 public key from a provided private key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const publicKey = X25519.getPublicKey({ privateKey: '0x...' })\n * ```\n *\n * @param options - The options to compute the public key.\n * @returns The computed public key.\n */\nexport function getPublicKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getPublicKey.Options<as>,\n): getPublicKey.ReturnType<as> {\n  const { as = 'Hex', privateKey } = options\n  const privateKeyBytes = Bytes.from(privateKey)\n  const publicKeyBytes = x25519.getPublicKey(privateKeyBytes)\n  if (as === 'Hex') return Hex.fromBytes(publicKeyBytes) as never\n  return publicKeyBytes as never\n}\n\nexport declare namespace getPublicKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned public key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to compute the public key from.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using X25519 elliptic curve Diffie-Hellman between a private key and a public key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const { privateKey: privateKeyA } = X25519.createKeyPair()\n * const { publicKey: publicKeyB } = X25519.createKeyPair()\n *\n * const sharedSecret = X25519.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): getSharedSecret.ReturnType<as> {\n  const { as = 'Hex', privateKey, publicKey } = options\n  const privateKeyBytes = Bytes.from(privateKey)\n  const publicKeyBytes = Bytes.from(publicKey)\n  const sharedSecretBytes = x25519.getSharedSecret(\n    privateKeyBytes,\n    publicKeyBytes,\n  )\n  if (as === 'Hex') return Hex.fromBytes(sharedSecretBytes) as never\n  return sharedSecretBytes as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation.\n     */\n    privateKey: Hex.Hex | Bytes.Bytes\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: Hex.Hex | Bytes.Bytes\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Bytes.from.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Generates a random X25519 private key.\n *\n * @example\n * ```ts twoslash\n * import { X25519 } from 'ox'\n *\n * const privateKey = X25519.randomPrivateKey()\n * ```\n *\n * @param options - The options to generate the private key.\n * @returns The generated private key.\n */\nexport function randomPrivateKey<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: randomPrivateKey.Options<as> = {},\n): randomPrivateKey.ReturnType<as> {\n  const { as = 'Hex' } = options\n  const bytes = x25519.utils.randomPrivateKey()\n  if (as === 'Hex') return Hex.fromBytes(bytes) as never\n  return bytes as never\n}\n\nexport declare namespace randomPrivateKey {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned private key.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Hex.fromBytes.ErrorType | Errors.GlobalErrorType\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,uBAAuB;AAC9C,OAAO,KAAKC,KAAK,MAAM,YAAY;AAEnC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAE/B;AACA,OAAO,MAAMC,KAAK,GAAGH,MAAM;AAE3B;;;;;;;;;;;;;AAaA,OAAM,SAAUI,aAAaA,CAAA,EACY;EAAA,IAAvCC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAqC,EAAE;EAEvC,MAAM;IAAEG,EAAE,GAAG;EAAK,CAAE,GAAGJ,OAAO;EAC9B,MAAMK,UAAU,GAAGC,gBAAgB,CAAC;IAAEF;EAAE,CAAE,CAAC;EAC3C,MAAMG,SAAS,GAAGC,YAAY,CAAC;IAAEH,UAAU;IAAED;EAAE,CAAE,CAAC;EAElD,OAAO;IACLC,UAAU,EAAEA,UAAmB;IAC/BE,SAAS,EAAEA;GACZ;AACH;AA2BA;;;;;;;;;;;;;AAaA,OAAM,SAAUC,YAAYA,CAC1BR,OAAiC;EAEjC,MAAM;IAAEI,EAAE,GAAG,KAAK;IAAEC;EAAU,CAAE,GAAGL,OAAO;EAC1C,MAAMS,eAAe,GAAGb,KAAK,CAACc,IAAI,CAACL,UAAU,CAAC;EAC9C,MAAMM,cAAc,GAAGhB,MAAM,CAACa,YAAY,CAACC,eAAe,CAAC;EAC3D,IAAIL,EAAE,KAAK,KAAK,EAAE,OAAOP,GAAG,CAACe,SAAS,CAACD,cAAc,CAAU;EAC/D,OAAOA,cAAuB;AAChC;AAyBA;;;;;;;;;;;;;;;;;;;AAmBA,OAAM,SAAUE,eAAeA,CAC7Bb,OAAoC;EAEpC,MAAM;IAAEI,EAAE,GAAG,KAAK;IAAEC,UAAU;IAAEE;EAAS,CAAE,GAAGP,OAAO;EACrD,MAAMS,eAAe,GAAGb,KAAK,CAACc,IAAI,CAACL,UAAU,CAAC;EAC9C,MAAMM,cAAc,GAAGf,KAAK,CAACc,IAAI,CAACH,SAAS,CAAC;EAC5C,MAAMO,iBAAiB,GAAGnB,MAAM,CAACkB,eAAe,CAC9CJ,eAAe,EACfE,cAAc,CACf;EACD,IAAIP,EAAE,KAAK,KAAK,EAAE,OAAOP,GAAG,CAACe,SAAS,CAACE,iBAAiB,CAAU;EAClE,OAAOA,iBAA0B;AACnC;AA6BA;;;;;;;;;;;;;AAaA,OAAM,SAAUR,gBAAgBA,CAAA,EACY;EAAA,IAA1CN,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwC,EAAE;EAE1C,MAAM;IAAEG,EAAE,GAAG;EAAK,CAAE,GAAGJ,OAAO;EAC9B,MAAMe,KAAK,GAAGpB,MAAM,CAACqB,KAAK,CAACV,gBAAgB,EAAE;EAC7C,IAAIF,EAAE,KAAK,KAAK,EAAE,OAAOP,GAAG,CAACe,SAAS,CAACG,KAAK,CAAU;EACtD,OAAOA,KAAc;AACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}