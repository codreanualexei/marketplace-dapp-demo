{"ast":null,"code":"import{ethers}from'ethers';import MarketplaceABI from'../contracts/abis/Marketplace.json';import StrDomainsNFTABI from'../contracts/abis/StrDomainsNFT.json';import RoyaltySplitterABI from'../contracts/abis/RoyaltySplitter.json';export class MarketplaceSDK{constructor(signer,marketplaceAddress,nftAddress){let develop=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;this.provider=void 0;this.signer=void 0;this.marketplaceAddress=void 0;this.nftAddress=void 0;this.marketplaceContract=void 0;this.nftContract=void 0;this.develop=void 0;this.collectionCountTokens=void 0;this.cachedActiveListingCount=void 0;this.develop=develop;this.signer=signer;this.provider=signer.provider;this.marketplaceAddress=marketplaceAddress;this.nftAddress=nftAddress;// Create contract instances\nthis.marketplaceContract=new ethers.Contract(marketplaceAddress,MarketplaceABI,signer);this.nftContract=new ethers.Contract(nftAddress,StrDomainsNFTABI,signer);}// Update signer when wallet changes\nupdateSigner(signer){this.signer=signer;this.provider=signer.provider;this.marketplaceContract=new ethers.Contract(this.marketplaceAddress,MarketplaceABI,signer);this.nftContract=new ethers.Contract(this.nftAddress,StrDomainsNFTABI,signer);}// Buy a listed token\nasync buyToken(listingId){try{const listing=await this.marketplaceContract.getListing(listingId);const{price,active}=listing;if(!active){this.warn('This listing is not active.');return null;}this.warn(\"Buying token for \".concat(ethers.formatEther(price),\" MATIC...\"));const tx=await this.marketplaceContract.buy(listingId,{value:price});const receipt=await tx.wait();this.warn(\"Purchase successful!\");return receipt.hash;}catch(error){this.error('Error purchasing token:',error);return null;}}// Update a listed token price\nasync updateListing(listingId,newPrice){try{const tx=await this.marketplaceContract.updateListing(listingId,ethers.parseEther(newPrice));this.warn(\"Listing \".concat(listingId,\" updated with new price: \").concat(newPrice,\" MATIC\"));const receipt=await tx.wait();return receipt.hash;}catch(error){this.error('Error updating listing:',error);return null;}}// List a token on the marketplace\nasync listToken(tokenId,price){try{await this.approveTokenForSale(tokenId);const approved=await this.nftContract.getApproved(tokenId);if(approved!==this.marketplaceAddress){this.warn(\"Please approve tokenId: \".concat(tokenId,\" for Marketplace address: \").concat(this.marketplaceAddress,\", or check the Marketplace listings\"));return null;}const tx=await this.marketplaceContract.listToken(this.nftAddress,tokenId,ethers.parseEther(price));const receipt=await tx.wait();return receipt.hash;}catch(error){this.error(\"Error listing your tokenId: \".concat(tokenId,\", check your ownership\"));return null;}}// Cancel a listing\nasync cancelListing(listingId){try{const tx=await this.marketplaceContract.cancelListing(listingId);const receipt=await tx.wait();this.warn(\"Listing \".concat(listingId,\" has been cancelled.\"));return receipt.hash;}catch(error){this.error(\"Error cancelling listing, check the listingId: \".concat(listingId,\" is active, or it exists\"));return null;}}// Get Marketplace fees\nasync getMarketplaceFees(){try{const fees=await this.marketplaceContract.accruedFees();return fees;}catch(error){this.error('Error fetching fees details:',error);return null;}}// Get listing details\nasync getListing(listingId){try{const listing=await this.marketplaceContract.getListing(listingId);return listing;}catch(error){this.error('Error fetching listing details:',error);return null;}}// Get tokenData from collection\nasync getTokenData(tokenId){try{const data=await this.nftContract.getTokenData(tokenId);return data;}catch(error){this.error('Getting token:',error);return null;}}// Get token data from collection\nasync getStrDomainFromCollection(tokenId){try{const data=await this.nftContract.getTokenData(tokenId);const formattedToken={tokenId:tokenId,creator:data[0],mintTimestamp:Number(data[1]),uri:data[2],lastPrice:data[3].toString(),lastPriceTimestamp:data[4].toString()};return formattedToken;}catch(e){// Don't log error, just return null\nreturn null;}}// Scraping all tokens from the collection\nasync getAllStrDomainsFromCollection(){const tokenList=[];let tokenId=1;let consecutiveFailures=0;const MAX_CONSECUTIVE_FAILURES=3;const MAX_TOKENS=50;// Limit to avoid RPC issues\nwhile(tokenId<=MAX_TOKENS&&consecutiveFailures<MAX_CONSECUTIVE_FAILURES){try{const tokenData=await this.getStrDomainFromCollection(tokenId);if(tokenData){tokenList.push(tokenData);consecutiveFailures=0;}else{consecutiveFailures++;}tokenId++;}catch(error){var _error$reason;consecutiveFailures++;if(error.code==='CALL_EXCEPTION'&&(_error$reason=error.reason)!==null&&_error$reason!==void 0&&_error$reason.includes('ERC721NonexistentToken')){tokenId++;continue;}this.warn(\"Error at token \".concat(tokenId,\", continuing...\"));tokenId++;}}this.collectionCountTokens=tokenList.length;this.warn(\"Found \".concat(tokenList.length,\" tokens in collection\"));return tokenList;}// Fetch all NFTs from the collection that belong to the connected wallet\nasync getMyDomainsFromCollection(){const myTokenList=[];let tokenId=1;let consecutiveFailures=0;const MAX_CONSECUTIVE_FAILURES=3;const MAX_TOKENS=20;// Reduced to avoid RPC issues\nconst myAddress=await this.signer.getAddress();// Helper to delay between calls\nconst delay=ms=>new Promise(resolve=>setTimeout(resolve,ms));while(tokenId<=MAX_TOKENS&&consecutiveFailures<MAX_CONSECUTIVE_FAILURES){try{const owner=await this.nftContract.ownerOf(tokenId);if(owner.toLowerCase()===myAddress.toLowerCase()){const tokenData=await this.getStrDomainFromCollection(tokenId);if(tokenData){myTokenList.push(tokenData);this.log(\"Found your domain: Token #\".concat(tokenId));}}consecutiveFailures=0;tokenId++;// Small delay to avoid RPC rate limiting\nawait delay(100);}catch(error){var _error$reason2,_error$reason3,_error$message,_error$message2;consecutiveFailures++;if(error.code==='CALL_EXCEPTION'&&((_error$reason2=error.reason)!==null&&_error$reason2!==void 0&&_error$reason2.includes('ERC721NonexistentToken')||(_error$reason3=error.reason)!==null&&_error$reason3!==void 0&&_error$reason3.includes('nonexistent')||(_error$message=error.message)!==null&&_error$message!==void 0&&_error$message.includes('could not decode'))){tokenId++;await delay(100);continue;}// RPC error - wait longer before continuing\nif((_error$message2=error.message)!==null&&_error$message2!==void 0&&_error$message2.includes('Internal JSON-RPC')){this.warn(\"RPC rate limit hit at token \".concat(tokenId,\", slowing down...\"));await delay(500);}this.warn(\"Error at tokenId \".concat(tokenId,\", continuing...\"));tokenId++;await delay(200);}}this.warn(\"Found \".concat(myTokenList.length,\" domains owned by you\"));return myTokenList;}// Count all the tokens from the collection\nasync countCollectionTokens(){const tokenList=[];let tokenId=1;let consecutiveFailures=0;const MAX_CONSECUTIVE_FAILURES=3;const MAX_TOKENS=50;// Limit to avoid RPC issues\nwhile(tokenId<=MAX_TOKENS&&consecutiveFailures<MAX_CONSECUTIVE_FAILURES){try{const tokenData=await this.getStrDomainFromCollection(tokenId);if(tokenData){tokenList.push(tokenData);consecutiveFailures=0;}else{consecutiveFailures++;}tokenId++;}catch(error){var _error$reason4,_error$reason5,_error$message3;consecutiveFailures++;if(error.code==='CALL_EXCEPTION'&&((_error$reason4=error.reason)!==null&&_error$reason4!==void 0&&_error$reason4.includes('ERC721NonexistentToken')||(_error$reason5=error.reason)!==null&&_error$reason5!==void 0&&_error$reason5.includes('nonexistent')||(_error$message3=error.message)!==null&&_error$message3!==void 0&&_error$message3.includes('could not decode'))){tokenId++;continue;}this.warn(\"Error at token \".concat(tokenId,\", continuing...\"));tokenId++;}}this.collectionCountTokens=tokenList.length;this.warn(\"Counted \".concat(tokenList.length,\" tokens in collection\"));return tokenList.length;}// Scraping all splitter contracts from the collection\nasync getAllSplitterContractsFromCollection(){this.collectionCountTokens=await this.countCollectionTokens();if(!this.collectionCountTokens){this.warn('no token counter, please run Marketplace.getStrDomainFromCollection()');return[];}const splitterList=[];let tokenId=1;for(tokenId=1;tokenId<=this.collectionCountTokens;tokenId++){try{const splitterData=await this.nftContract.royaltyInfo(tokenId,40000000);splitterList.push(splitterData[0]);}catch(error){this.error('Unexpected error fetching token:',error);break;}}return splitterList;}// Get total count of listings\nasync getListingCount(){try{const result=await this.marketplaceContract.lastListingId();return Number(result);}catch(error){this.error('Error getting listing count:',error);return 0;}}// Count active listings by scanning IDs (with limits to avoid RPC overload)\nasync getActiveListingCount(){let maxScan=arguments.length>0&&arguments[0]!==undefined?arguments[0]:500;try{const lastId=await this.getListingCount();if(lastId===0)return 0;let active=0;let scanned=0;for(let id=lastId;id>=1;id--){try{const listing=await this.marketplaceContract.getListing(id);if(listing!==null&&listing!==void 0&&listing.active)active++;}catch(_){// ignore missing IDs\n}scanned++;if(scanned>=maxScan)break;// small delay\nawait new Promise(r=>setTimeout(r,50));}this.cachedActiveListingCount=active;return active;}catch(e){this.error('Error counting active listings:',e);return 0;}}// Get a page of active listings by scanning from the end and skipping inactive/missing\nasync getActiveListingsPage(page,perPage){const results=[];try{const lastId=await this.getListingCount();if(lastId===0)return results;// Determine how many active to skip\nconst toSkip=(page-1)*perPage;let skipped=0;let collected=0;for(let id=lastId;id>=1;id--){try{const listing=await this.marketplaceContract.getListing(id);if(!(listing!==null&&listing!==void 0&&listing.active)){continue;}if(skipped<toSkip){skipped++;continue;}let tokenData;try{tokenData=await this.getStrDomainFromCollection(Number(listing.tokenId));}catch(_){}results.push({listingId:id,active:listing.active,seller:listing.seller,tokenId:Number(listing.tokenId),price:ethers.formatEther(listing.price),strCollectionAddress:listing.nft,tokenData:tokenData||undefined});collected++;if(collected>=perPage)break;}catch(_){// ignore and continue\n}// small delay\nawait new Promise(r=>setTimeout(r,60));}}catch(e){this.error('Error fetching active listings page:',e);}return results;}// Get paginated listings (smart pagination - only fetch what's needed)\nasync getListingsPaginated(startId,limit){let activeOnly=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;const listedTokens=[];const endId=startId+limit-1;this.log(\"Fetching listings \".concat(startId,\" to \").concat(endId,\" (\").concat(activeOnly?'active only':'all',\")\"));// Helper to delay between calls\nconst delay=ms=>new Promise(resolve=>setTimeout(resolve,ms));for(let listingId=startId;listingId<=endId;listingId++){try{const listing=await this.marketplaceContract.getListing(listingId);// Filter by active if needed\nif(!activeOnly||listing.active){let tokenData;try{tokenData=await this.getStrDomainFromCollection(Number(listing.tokenId));}catch(e){// Token data optional\n}listedTokens.push({listingId,active:listing.active,seller:listing.seller,tokenId:Number(listing.tokenId),price:ethers.formatEther(listing.price),strCollectionAddress:listing.nft,tokenData:tokenData||undefined});}// Small delay to avoid RPC spam\nawait delay(100);}catch(e){// Listing doesn't exist or error, continue\nawait delay(50);continue;}}this.log(\"Fetched \".concat(listedTokens.length,\" listings from range \").concat(startId,\"-\").concat(endId));return listedTokens;}// Get all active listed tokens on marketplace (legacy method - for compatibility)\nasync getAllActiveListedDomainsOnMarketplaceWithTokenData(){const listedTokens=[];try{let lastListingId=0;// Try to get lastListingId\ntry{const result=await this.marketplaceContract.lastListingId();lastListingId=Number(result);this.log('lastListingId:',lastListingId);}catch(error){this.warn('lastListingId() not available, using fallback method');return await this.scanForListings(true);}if(lastListingId===0){this.warn('No listings found - lastListingId is 0');return[];}// Use pagination to fetch all (with delays)\nreturn await this.getListingsPaginated(1,lastListingId,true);}catch(error){this.error('Error fetching listed tokens:',error);return[];}}// Fallback: Scan for listings without lastListingId\nasync scanForListings(){let activeOnly=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;const listedTokens=[];const MAX_SCAN=20;// Reduced to avoid RPC spam\nlet consecutiveFailures=0;let rpcErrorCount=0;this.warn('Scanning for listings (no lastListingId available)...');// Helper to delay between calls\nconst delay=ms=>new Promise(resolve=>setTimeout(resolve,ms));for(let listingId=1;listingId<=MAX_SCAN;listingId++){try{// Exponential backoff if we've hit RPC errors\nif(rpcErrorCount>0){const backoffDelay=Math.min(1000*Math.pow(2,rpcErrorCount),5000);this.log(\"Backing off \".concat(backoffDelay,\"ms before next call...\"));await delay(backoffDelay);}else{// Normal delay\nawait delay(300);}const listing=await this.marketplaceContract.getListing(listingId);// Reset failure counters on success\nconsecutiveFailures=0;rpcErrorCount=Math.max(0,rpcErrorCount-1);// Gradually reduce backoff\n// Filter by active if needed\nif(!activeOnly||listing.active){let tokenData;try{await delay(200);// Delay before token data\ntokenData=await this.getStrDomainFromCollection(Number(listing.tokenId));}catch(e){// Token data optional\n}listedTokens.push({listingId,active:listing.active,seller:listing.seller,tokenId:Number(listing.tokenId),price:ethers.formatEther(listing.price),strCollectionAddress:listing.nft,tokenData:tokenData||undefined});}}catch(e){var _e$message;consecutiveFailures++;// If RPC error, increase backoff\nif((_e$message=e.message)!==null&&_e$message!==void 0&&_e$message.includes('Internal JSON-RPC')||e.code===-32603){rpcErrorCount++;this.warn(\"RPC error #\".concat(rpcErrorCount,\" at listing \").concat(listingId,\", backing off...\"));// If too many RPC errors, stop early\nif(rpcErrorCount>=3){this.warn(\"Too many RPC errors, stopping scan early\");break;}}// Stop after 5 consecutive failures\nif(consecutiveFailures>=5){this.log(\"Stopped scanning at listing \".concat(listingId,\" after \").concat(consecutiveFailures,\" failures\"));break;}}}this.log(\"Found \".concat(listedTokens.length,\" listings via scanning\"));return listedTokens;}// Get all listed tokens on marketplace (legacy - for compatibility)\nasync getAllListedDomainsOnMarketplaceWithTokenData(){try{let lastListingId=0;try{const result=await this.marketplaceContract.lastListingId();lastListingId=Number(result);}catch(error){this.warn('lastListingId() not available, using fallback');return await this.scanForListings(false);}if(lastListingId===0){this.warn('No listings found');return[];}// Use pagination to fetch all\nreturn await this.getListingsPaginated(1,lastListingId,false);}catch(error){this.error('Error fetching listed tokens:',error);return[];}}// Get my all listed tokens on marketplace (legacy - fetches all)\nasync getMyAllListedDomainsOnMarketplaceWithTokenData(){try{const myAddress=(await this.signer.getAddress()).toLowerCase();let lastListingId=0;try{const result=await this.marketplaceContract.lastListingId();lastListingId=Number(result);}catch(error){this.warn('lastListingId() not available, using fallback');const allListings=await this.scanForListings(false);return allListings.filter(l=>l.seller.toLowerCase()===myAddress);}if(lastListingId===0){this.warn('No listings found');return[];}// Fetch all listings for this user\nconst allListings=await this.getListingsPaginated(1,lastListingId,false);return allListings.filter(l=>l.seller.toLowerCase()===myAddress);}catch(error){this.error('Error fetching listed tokens:',error);return[];}}// Get paginated NFTs from collection\nasync getDomainsPaginated(startTokenId,limit,filterByOwner){const tokenList=[];const endTokenId=startTokenId+limit-1;this.log(\"Fetching tokens \".concat(startTokenId,\" to \").concat(endTokenId));const delay=ms=>new Promise(resolve=>setTimeout(resolve,ms));const targetOwner=filterByOwner===null||filterByOwner===void 0?void 0:filterByOwner.toLowerCase();for(let tokenId=startTokenId;tokenId<=endTokenId;tokenId++){try{// If filtering by owner, check ownership first\nif(targetOwner){const owner=await this.nftContract.ownerOf(tokenId);if(owner.toLowerCase()!==targetOwner){await delay(50);continue;}}const tokenData=await this.getStrDomainFromCollection(tokenId);if(tokenData){tokenList.push(tokenData);}await delay(100);}catch(error){// Token doesn't exist, continue\nawait delay(50);continue;}}this.log(\"Fetched \".concat(tokenList.length,\" tokens from range \").concat(startTokenId,\"-\").concat(endTokenId));return tokenList;}// Get available fee balance from a splitter\nasync getSplitterBalance(splitterAddress,walletAddress){try{const contractInstance=new ethers.Contract(splitterAddress,RoyaltySplitterABI,this.signer);const balance=await contractInstance.ethBalance(walletAddress);return balance;}catch(error){this.error('Unexpected error fetching balance:',error);return null;}}// Get all splitter balances for a given wallet across the collection\nasync getSplitterBalanceOfWallet(walletAddress){const balances=[];try{const splitterAddresses=await this.getAllSplitterContractsFromCollection();if(!splitterAddresses||splitterAddresses.length===0){this.warn('No splitter contracts found in collection.');return balances;}for(const splitterAddress of splitterAddresses){try{const contract=new ethers.Contract(splitterAddress,RoyaltySplitterABI,this.signer);const rawBalance=await contract.ethBalance(walletAddress);const balance=ethers.formatEther(rawBalance);if(rawBalance>0n){balances.push({splitter:splitterAddress,balance});}}catch(innerErr){this.warn(\"Failed to fetch balance from splitter: \".concat(splitterAddress),innerErr.message);}}}catch(error){this.error('Error fetching splitter balances:',error);}return balances;}// Owner only - Approve token for sale\nasync approveTokenForSale(tokenId){try{const tx=await this.nftContract.approve(this.marketplaceAddress,tokenId);const receipt=await tx.wait();return receipt.hash;}catch(error){this.error(\"Error approve your NFT tokenId: \".concat(tokenId,\", check your ownership\"));return null;}}// Withdraw royalty from a specific splitter\nasync withdrawRoyaltyFromSplitter(splitterAddress){try{const contract=new ethers.Contract(splitterAddress,RoyaltySplitterABI,this.signer);const walletAddress=await this.signer.getAddress();const rawBalance=await contract.ethBalance(walletAddress);if(rawBalance<=0n){this.warn(\"\\u23ED Skipping \".concat(splitterAddress,\": no funds to withdraw.\"));return null;}const balance=ethers.formatEther(rawBalance);const tx=await contract.withdraw();if(!tx||!tx.hash){this.warn(\"No transaction hash returned from withdraw() on \".concat(splitterAddress));return null;}const receipt=await tx.wait();this.warn(\"Withdrawn from splitter \".concat(splitterAddress,\" | Tx: \").concat(receipt.hash,\" | Amount: \").concat(balance));return{splitter:splitterAddress,transactionHash:receipt.hash,withdrawn:balance};}catch(err){this.warn(\"Failed to withdraw from splitter: \".concat(splitterAddress,\" | \").concat(err.message));return null;}}// Withdraw royalty fees from all existing splitter contracts\nasync withdrawAllRoyaltyFees(){try{const walletAddress=await this.signer.getAddress();const splitterBalances=await this.getSplitterBalanceOfWallet(walletAddress);if(!splitterBalances||splitterBalances.length===0){this.warn('No splitter contracts with available balances found.');return null;}const receipts=[];for(const item of splitterBalances){const result=await this.withdrawRoyaltyFromSplitter(item.splitter);if(result){receipts.push(result);}}return receipts;}catch(error){this.error('Error withdrawing all royalty fees:',error);return null;}}// Withdraw marketplace fees (only owner of the contract)\nasync withdrawMarketPlaceFees(){const isAdmin=await this.isAdmin();try{if(!isAdmin){this.warn('You are not an admin of the Marketplace contract. Withdraw not allowed.');return null;}const tx=await this.marketplaceContract.withdrawFees();const receipt=await tx.wait();this.warn(\"Marketplace fees withdrawn successfully! Tx hash: \".concat(receipt.hash));return receipt.hash;}catch(error){this.error('Error withdrawing marketplace fees, or check the fees balance');return null;}}// Check if connected wallet is admin\nasync isAdmin(){try{const ADMIN_ROLE='0x0000000000000000000000000000000000000000000000000000000000000000';const isAdmin=await this.nftContract.hasRole(ADMIN_ROLE,await this.signer.getAddress());if(!isAdmin){this.warn('Please connect with an admin account before running isAdmin method.');}return isAdmin;}catch(e){return false;}}// Admin only - Mint domain\nasync mintDomain(originalCreator,URI){if(!(await this.isAdmin()))return null;try{const tx=await this.nftContract.mint(originalCreator,URI);const receipt=await tx.wait();return receipt.hash;}catch(error){this.error('Error minting domain NFT, check you are the owner of the contract, or have minter role');return null;}}// Logging methods\nlog(){if(this.develop)console.log(...arguments);}warn(){if(this.develop)console.warn(...arguments);}error(){if(this.develop)console.error(...arguments);}// Set develop mode on/off\nsetDevelopMode(enabled){this.develop=!!enabled;this.warn(\"Develop mode set to \".concat(this.develop));}}","map":{"version":3,"names":["ethers","MarketplaceABI","StrDomainsNFTABI","RoyaltySplitterABI","MarketplaceSDK","constructor","signer","marketplaceAddress","nftAddress","develop","arguments","length","undefined","provider","marketplaceContract","nftContract","collectionCountTokens","cachedActiveListingCount","Contract","updateSigner","buyToken","listingId","listing","getListing","price","active","warn","concat","formatEther","tx","buy","value","receipt","wait","hash","error","updateListing","newPrice","parseEther","listToken","tokenId","approveTokenForSale","approved","getApproved","cancelListing","getMarketplaceFees","fees","accruedFees","getTokenData","data","getStrDomainFromCollection","formattedToken","creator","mintTimestamp","Number","uri","lastPrice","toString","lastPriceTimestamp","e","getAllStrDomainsFromCollection","tokenList","consecutiveFailures","MAX_CONSECUTIVE_FAILURES","MAX_TOKENS","tokenData","push","_error$reason","code","reason","includes","getMyDomainsFromCollection","myTokenList","myAddress","getAddress","delay","ms","Promise","resolve","setTimeout","owner","ownerOf","toLowerCase","log","_error$reason2","_error$reason3","_error$message","_error$message2","message","countCollectionTokens","_error$reason4","_error$reason5","_error$message3","getAllSplitterContractsFromCollection","splitterList","splitterData","royaltyInfo","getListingCount","result","lastListingId","getActiveListingCount","maxScan","lastId","scanned","id","_","r","getActiveListingsPage","page","perPage","results","toSkip","skipped","collected","seller","strCollectionAddress","nft","getListingsPaginated","startId","limit","activeOnly","listedTokens","endId","getAllActiveListedDomainsOnMarketplaceWithTokenData","scanForListings","MAX_SCAN","rpcErrorCount","backoffDelay","Math","min","pow","max","_e$message","getAllListedDomainsOnMarketplaceWithTokenData","getMyAllListedDomainsOnMarketplaceWithTokenData","allListings","filter","l","getDomainsPaginated","startTokenId","filterByOwner","endTokenId","targetOwner","getSplitterBalance","splitterAddress","walletAddress","contractInstance","balance","ethBalance","getSplitterBalanceOfWallet","balances","splitterAddresses","contract","rawBalance","splitter","innerErr","approve","withdrawRoyaltyFromSplitter","withdraw","transactionHash","withdrawn","err","withdrawAllRoyaltyFees","splitterBalances","receipts","item","withdrawMarketPlaceFees","isAdmin","withdrawFees","ADMIN_ROLE","hasRole","mintDomain","originalCreator","URI","mint","console","setDevelopMode","enabled"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/src/sdk/MarketplaceSDK.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport MarketplaceABI from '../contracts/abis/Marketplace.json';\nimport StrDomainsNFTABI from '../contracts/abis/StrDomainsNFT.json';\nimport RoyaltySplitterABI from '../contracts/abis/RoyaltySplitter.json';\n\nexport interface TokenData {\n  creator: string;\n  mintTimestamp: number;\n  uri: string;\n  lastPrice: string;\n  lastPriceTimestamp: string;\n}\n\nexport interface FormattedToken extends TokenData {\n  tokenId: number;\n}\n\nexport interface Listing {\n  seller: string;\n  nft: string;\n  tokenId: bigint;\n  price: bigint;\n  active: boolean;\n}\n\nexport interface ListedToken {\n  listingId: number;\n  active: boolean;\n  seller: string;\n  tokenId: number;\n  price: string;\n  strCollectionAddress: string;\n  tokenData?: FormattedToken;\n}\n\nexport interface SplitterBalance {\n  splitter: string;\n  balance: string;\n}\n\nexport class MarketplaceSDK {\n  private provider: ethers.Provider;\n  private signer: ethers.Signer;\n  private marketplaceAddress: string;\n  private nftAddress: string;\n  private marketplaceContract: ethers.Contract;\n  private nftContract: ethers.Contract;\n  private develop: boolean;\n  public collectionCountTokens?: number;\n  private cachedActiveListingCount?: number;\n\n  constructor(\n    signer: ethers.Signer,\n    marketplaceAddress: string,\n    nftAddress: string,\n    develop: boolean = false\n  ) {\n    this.develop = develop;\n    this.signer = signer;\n    this.provider = signer.provider!;\n    this.marketplaceAddress = marketplaceAddress;\n    this.nftAddress = nftAddress;\n\n    // Create contract instances\n    this.marketplaceContract = new ethers.Contract(\n      marketplaceAddress,\n      MarketplaceABI,\n      signer\n    );\n    this.nftContract = new ethers.Contract(nftAddress, StrDomainsNFTABI, signer);\n\n  }\n\n  // Update signer when wallet changes\n  updateSigner(signer: ethers.Signer) {\n    this.signer = signer;\n    this.provider = signer.provider!;\n    \n    this.marketplaceContract = new ethers.Contract(\n      this.marketplaceAddress,\n      MarketplaceABI,\n      signer\n    );\n    this.nftContract = new ethers.Contract(\n      this.nftAddress,\n      StrDomainsNFTABI,\n      signer\n    );\n  }\n\n  // Buy a listed token\n  async buyToken(listingId: number): Promise<string | null> {\n    try {\n      const listing = await this.marketplaceContract.getListing(listingId);\n      const { price, active } = listing;\n\n      if (!active) {\n        this.warn('This listing is not active.');\n        return null;\n      }\n\n      this.warn(`Buying token for ${ethers.formatEther(price)} MATIC...`);\n      const tx = await this.marketplaceContract.buy(listingId, {\n        value: price,\n      });\n      const receipt = await tx.wait();\n\n      this.warn(`Purchase successful!`);\n      return receipt.hash;\n    } catch (error: any) {\n      this.error('Error purchasing token:', error);\n      return null;\n    }\n  }\n\n  // Update a listed token price\n  async updateListing(listingId: number, newPrice: string): Promise<string | null> {\n    try {\n      const tx = await this.marketplaceContract.updateListing(\n        listingId,\n        ethers.parseEther(newPrice)\n      );\n      this.warn(`Listing ${listingId} updated with new price: ${newPrice} MATIC`);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error('Error updating listing:', error);\n      return null;\n    }\n  }\n\n  // List a token on the marketplace\n  async listToken(tokenId: number, price: string): Promise<string | null> {\n    try {\n      await this.approveTokenForSale(tokenId);\n\n      const approved = await this.nftContract.getApproved(tokenId);\n\n      if (approved !== this.marketplaceAddress) {\n        this.warn(\n          `Please approve tokenId: ${tokenId} for Marketplace address: ${this.marketplaceAddress}, or check the Marketplace listings`\n        );\n        return null;\n      }\n\n      const tx = await this.marketplaceContract.listToken(\n        this.nftAddress,\n        tokenId,\n        ethers.parseEther(price)\n      );\n\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(`Error listing your tokenId: ${tokenId}, check your ownership`);\n      return null;\n    }\n  }\n\n  // Cancel a listing\n  async cancelListing(listingId: number): Promise<string | null> {\n    try {\n      const tx = await this.marketplaceContract.cancelListing(listingId);\n      const receipt = await tx.wait();\n      this.warn(`Listing ${listingId} has been cancelled.`);\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(\n        `Error cancelling listing, check the listingId: ${listingId} is active, or it exists`\n      );\n      return null;\n    }\n  }\n\n  // Get Marketplace fees\n  async getMarketplaceFees(): Promise<bigint | null> {\n    try {\n      const fees = await this.marketplaceContract.accruedFees();\n      return fees;\n    } catch (error: any) {\n      this.error('Error fetching fees details:', error);\n      return null;\n    }\n  }\n\n  // Get listing details\n  async getListing(listingId: number): Promise<Listing | null> {\n    try {\n      const listing = await this.marketplaceContract.getListing(listingId);\n      return listing;\n    } catch (error: any) {\n      this.error('Error fetching listing details:', error);\n      return null;\n    }\n  }\n\n  // Get tokenData from collection\n  async getTokenData(tokenId: number): Promise<any> {\n    try {\n      const data = await this.nftContract.getTokenData(tokenId);\n      return data;\n    } catch (error: any) {\n      this.error('Getting token:', error);\n      return null;\n    }\n  }\n\n  // Get token data from collection\n  async getStrDomainFromCollection(tokenId: number): Promise<FormattedToken | null> {\n    try {\n      const data = await this.nftContract.getTokenData(tokenId);\n      const formattedToken: FormattedToken = {\n        tokenId: tokenId,\n        creator: data[0],\n        mintTimestamp: Number(data[1]),\n        uri: data[2],\n        lastPrice: data[3].toString(),\n        lastPriceTimestamp: data[4].toString(),\n      };\n\n      return formattedToken;\n    } catch (e: any) {\n      // Don't log error, just return null\n      return null;\n    }\n  }\n\n  // Scraping all tokens from the collection\n  async getAllStrDomainsFromCollection(): Promise<FormattedToken[]> {\n    const tokenList: FormattedToken[] = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 50; // Limit to avoid RPC issues\n    \n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n          consecutiveFailures = 0;\n        } else {\n          consecutiveFailures++;\n        }\n        tokenId++;\n      } catch (error: any) {\n        consecutiveFailures++;\n        if (\n          error.code === 'CALL_EXCEPTION' &&\n          error.reason?.includes('ERC721NonexistentToken')\n        ) {\n          tokenId++;\n          continue;\n        }\n        this.warn(`Error at token ${tokenId}, continuing...`);\n        tokenId++;\n      }\n    }\n\n    this.collectionCountTokens = tokenList.length;\n    this.warn(`Found ${tokenList.length} tokens in collection`);\n    return tokenList;\n  }\n\n  // Fetch all NFTs from the collection that belong to the connected wallet\n  async getMyDomainsFromCollection(): Promise<FormattedToken[]> {\n    const myTokenList: FormattedToken[] = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 20; // Reduced to avoid RPC issues\n\n    const myAddress = await this.signer.getAddress();\n    \n    // Helper to delay between calls\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const owner = await this.nftContract.ownerOf(tokenId);\n\n        if (owner.toLowerCase() === myAddress.toLowerCase()) {\n          const tokenData = await this.getStrDomainFromCollection(tokenId);\n          if (tokenData) {\n            myTokenList.push(tokenData);\n            this.log(`Found your domain: Token #${tokenId}`);\n          }\n        }\n\n        consecutiveFailures = 0;\n        tokenId++;\n        \n        // Small delay to avoid RPC rate limiting\n        await delay(100);\n      } catch (error: any) {\n        consecutiveFailures++;\n        \n        if (\n          error.code === 'CALL_EXCEPTION' &&\n          (error.reason?.includes('ERC721NonexistentToken') || \n           error.reason?.includes('nonexistent') ||\n           error.message?.includes('could not decode'))\n        ) {\n          tokenId++;\n          await delay(100);\n          continue;\n        }\n\n        // RPC error - wait longer before continuing\n        if (error.message?.includes('Internal JSON-RPC')) {\n          this.warn(`RPC rate limit hit at token ${tokenId}, slowing down...`);\n          await delay(500);\n        }\n        \n        this.warn(`Error at tokenId ${tokenId}, continuing...`);\n        tokenId++;\n        await delay(200);\n      }\n    }\n\n    this.warn(`Found ${myTokenList.length} domains owned by you`);\n    return myTokenList;\n  }\n\n  // Count all the tokens from the collection\n  async countCollectionTokens(): Promise<number> {\n    const tokenList: FormattedToken[] = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 50; // Limit to avoid RPC issues\n    \n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n          consecutiveFailures = 0;\n        } else {\n          consecutiveFailures++;\n        }\n        tokenId++;\n      } catch (error: any) {\n        consecutiveFailures++;\n        if (\n          error.code === 'CALL_EXCEPTION' &&\n          (error.reason?.includes('ERC721NonexistentToken') ||\n           error.reason?.includes('nonexistent') ||\n           error.message?.includes('could not decode'))\n        ) {\n          tokenId++;\n          continue;\n        }\n        this.warn(`Error at token ${tokenId}, continuing...`);\n        tokenId++;\n      }\n    }\n\n    this.collectionCountTokens = tokenList.length;\n    this.warn(`Counted ${tokenList.length} tokens in collection`);\n    return tokenList.length;\n  }\n\n  // Scraping all splitter contracts from the collection\n  async getAllSplitterContractsFromCollection(): Promise<string[]> {\n    this.collectionCountTokens = await this.countCollectionTokens();\n    if (!this.collectionCountTokens) {\n      this.warn(\n        'no token counter, please run Marketplace.getStrDomainFromCollection()'\n      );\n      return [];\n    }\n    const splitterList: string[] = [];\n    let tokenId = 1;\n    for (tokenId = 1; tokenId <= this.collectionCountTokens; tokenId++) {\n      try {\n        const splitterData = await this.nftContract.royaltyInfo(tokenId, 40000000);\n        splitterList.push(splitterData[0]);\n      } catch (error: any) {\n        this.error('Unexpected error fetching token:', error);\n        break;\n      }\n    }\n\n    return splitterList;\n  }\n\n  // Get total count of listings\n  async getListingCount(): Promise<number> {\n    try {\n      const result = await this.marketplaceContract.lastListingId();\n      return Number(result);\n    } catch (error: any) {\n      this.error('Error getting listing count:', error);\n      return 0;\n    }\n  }\n\n  // Count active listings by scanning IDs (with limits to avoid RPC overload)\n  async getActiveListingCount(maxScan: number = 500): Promise<number> {\n    try {\n      const lastId = await this.getListingCount();\n      if (lastId === 0) return 0;\n\n      let active = 0;\n      let scanned = 0;\n      for (let id = lastId; id >= 1; id--) {\n        try {\n          const listing = await this.marketplaceContract.getListing(id);\n          if (listing?.active) active++;\n        } catch (_) {\n          // ignore missing IDs\n        }\n        scanned++;\n        if (scanned >= maxScan) break;\n        // small delay\n        await new Promise(r => setTimeout(r, 50));\n      }\n      this.cachedActiveListingCount = active;\n      return active;\n    } catch (e) {\n      this.error('Error counting active listings:', e);\n      return 0;\n    }\n  }\n\n  // Get a page of active listings by scanning from the end and skipping inactive/missing\n  async getActiveListingsPage(page: number, perPage: number): Promise<ListedToken[]> {\n    const results: ListedToken[] = [];\n    try {\n      const lastId = await this.getListingCount();\n      if (lastId === 0) return results;\n\n      // Determine how many active to skip\n      const toSkip = (page - 1) * perPage;\n      let skipped = 0;\n      let collected = 0;\n\n      for (let id = lastId; id >= 1; id--) {\n        try {\n          const listing = await this.marketplaceContract.getListing(id);\n          if (!listing?.active) {\n            continue;\n          }\n\n          if (skipped < toSkip) {\n            skipped++;\n            continue;\n          }\n\n          let tokenData;\n          try {\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (_) {}\n\n          results.push({\n            listingId: id,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined,\n          });\n          collected++;\n          if (collected >= perPage) break;\n        } catch (_) {\n          // ignore and continue\n        }\n        // small delay\n        await new Promise(r => setTimeout(r, 60));\n      }\n    } catch (e) {\n      this.error('Error fetching active listings page:', e);\n    }\n    return results;\n  }\n\n  // Get paginated listings (smart pagination - only fetch what's needed)\n  async getListingsPaginated(\n    startId: number,\n    limit: number,\n    activeOnly: boolean = true\n  ): Promise<ListedToken[]> {\n    const listedTokens: ListedToken[] = [];\n    const endId = startId + limit - 1;\n    \n    this.log(`Fetching listings ${startId} to ${endId} (${activeOnly ? 'active only' : 'all'})`);\n    \n    // Helper to delay between calls\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    \n    for (let listingId = startId; listingId <= endId; listingId++) {\n      try {\n        const listing = await this.marketplaceContract.getListing(listingId);\n\n        // Filter by active if needed\n        if (!activeOnly || listing.active) {\n          let tokenData;\n          try {\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (e) {\n            // Token data optional\n          }\n\n          listedTokens.push({\n            listingId,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined,\n          });\n        }\n        \n        // Small delay to avoid RPC spam\n        await delay(100);\n      } catch (e: any) {\n        // Listing doesn't exist or error, continue\n        await delay(50);\n        continue;\n      }\n    }\n\n    this.log(`Fetched ${listedTokens.length} listings from range ${startId}-${endId}`);\n    return listedTokens;\n  }\n\n  // Get all active listed tokens on marketplace (legacy method - for compatibility)\n  async getAllActiveListedDomainsOnMarketplaceWithTokenData(): Promise<ListedToken[]> {\n    const listedTokens: ListedToken[] = [];\n    \n    try {\n      let lastListingId: number = 0;\n      \n      // Try to get lastListingId\n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n        this.log('lastListingId:', lastListingId);\n      } catch (error: any) {\n        this.warn('lastListingId() not available, using fallback method');\n        return await this.scanForListings(true);\n      }\n\n      if (lastListingId === 0) {\n        this.warn('No listings found - lastListingId is 0');\n        return [];\n      }\n\n      // Use pagination to fetch all (with delays)\n      return await this.getListingsPaginated(1, lastListingId, true);\n    } catch (error: any) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Fallback: Scan for listings without lastListingId\n  private async scanForListings(activeOnly: boolean = true): Promise<ListedToken[]> {\n    const listedTokens: ListedToken[] = [];\n    const MAX_SCAN = 20; // Reduced to avoid RPC spam\n    let consecutiveFailures = 0;\n    let rpcErrorCount = 0;\n    \n    this.warn('Scanning for listings (no lastListingId available)...');\n    \n    // Helper to delay between calls\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    \n    for (let listingId = 1; listingId <= MAX_SCAN; listingId++) {\n      try {\n        // Exponential backoff if we've hit RPC errors\n        if (rpcErrorCount > 0) {\n          const backoffDelay = Math.min(1000 * Math.pow(2, rpcErrorCount), 5000);\n          this.log(`Backing off ${backoffDelay}ms before next call...`);\n          await delay(backoffDelay);\n        } else {\n          // Normal delay\n          await delay(300);\n        }\n        \n        const listing = await this.marketplaceContract.getListing(listingId);\n        \n        // Reset failure counters on success\n        consecutiveFailures = 0;\n        rpcErrorCount = Math.max(0, rpcErrorCount - 1); // Gradually reduce backoff\n        \n        // Filter by active if needed\n        if (!activeOnly || listing.active) {\n          let tokenData;\n          try {\n            await delay(200); // Delay before token data\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (e) {\n            // Token data optional\n          }\n\n          listedTokens.push({\n            listingId,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined,\n          });\n        }\n      } catch (e: any) {\n        consecutiveFailures++;\n        \n        // If RPC error, increase backoff\n        if (e.message?.includes('Internal JSON-RPC') || e.code === -32603) {\n          rpcErrorCount++;\n          this.warn(`RPC error #${rpcErrorCount} at listing ${listingId}, backing off...`);\n          \n          // If too many RPC errors, stop early\n          if (rpcErrorCount >= 3) {\n            this.warn(`Too many RPC errors, stopping scan early`);\n            break;\n          }\n        }\n        \n        // Stop after 5 consecutive failures\n        if (consecutiveFailures >= 5) {\n          this.log(`Stopped scanning at listing ${listingId} after ${consecutiveFailures} failures`);\n          break;\n        }\n      }\n    }\n    \n    this.log(`Found ${listedTokens.length} listings via scanning`);\n    return listedTokens;\n  }\n\n  // Get all listed tokens on marketplace (legacy - for compatibility)\n  async getAllListedDomainsOnMarketplaceWithTokenData(): Promise<ListedToken[]> {\n    try {\n      let lastListingId: number = 0;\n      \n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n      } catch (error: any) {\n        this.warn('lastListingId() not available, using fallback');\n        return await this.scanForListings(false);\n      }\n\n      if (lastListingId === 0) {\n        this.warn('No listings found');\n        return [];\n      }\n\n      // Use pagination to fetch all\n      return await this.getListingsPaginated(1, lastListingId, false);\n    } catch (error: any) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Get my all listed tokens on marketplace (legacy - fetches all)\n  async getMyAllListedDomainsOnMarketplaceWithTokenData(): Promise<ListedToken[]> {\n    try {\n      const myAddress = (await this.signer.getAddress()).toLowerCase();\n      let lastListingId: number = 0;\n      \n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n      } catch (error: any) {\n        this.warn('lastListingId() not available, using fallback');\n        const allListings = await this.scanForListings(false);\n        return allListings.filter(l => l.seller.toLowerCase() === myAddress);\n      }\n\n      if (lastListingId === 0) {\n        this.warn('No listings found');\n        return [];\n      }\n\n      // Fetch all listings for this user\n      const allListings = await this.getListingsPaginated(1, lastListingId, false);\n      return allListings.filter(l => l.seller.toLowerCase() === myAddress);\n    } catch (error: any) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Get paginated NFTs from collection\n  async getDomainsPaginated(\n    startTokenId: number,\n    limit: number,\n    filterByOwner?: string\n  ): Promise<FormattedToken[]> {\n    const tokenList: FormattedToken[] = [];\n    const endTokenId = startTokenId + limit - 1;\n    \n    this.log(`Fetching tokens ${startTokenId} to ${endTokenId}`);\n    \n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    const targetOwner = filterByOwner?.toLowerCase();\n    \n    for (let tokenId = startTokenId; tokenId <= endTokenId; tokenId++) {\n      try {\n        // If filtering by owner, check ownership first\n        if (targetOwner) {\n          const owner = await this.nftContract.ownerOf(tokenId);\n          if (owner.toLowerCase() !== targetOwner) {\n            await delay(50);\n            continue;\n          }\n        }\n        \n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n        }\n        \n        await delay(100);\n      } catch (error: any) {\n        // Token doesn't exist, continue\n        await delay(50);\n        continue;\n      }\n    }\n\n    this.log(`Fetched ${tokenList.length} tokens from range ${startTokenId}-${endTokenId}`);\n    return tokenList;\n  }\n\n  // Get available fee balance from a splitter\n  async getSplitterBalance(\n    splitterAddress: string,\n    walletAddress: string\n  ): Promise<bigint | null> {\n    try {\n      const contractInstance = new ethers.Contract(\n        splitterAddress,\n        RoyaltySplitterABI,\n        this.signer\n      );\n      const balance = await contractInstance.ethBalance(walletAddress);\n      return balance;\n    } catch (error: any) {\n      this.error('Unexpected error fetching balance:', error);\n      return null;\n    }\n  }\n\n  // Get all splitter balances for a given wallet across the collection\n  async getSplitterBalanceOfWallet(walletAddress: string): Promise<SplitterBalance[]> {\n    const balances: SplitterBalance[] = [];\n\n    try {\n      const splitterAddresses = await this.getAllSplitterContractsFromCollection();\n\n      if (!splitterAddresses || splitterAddresses.length === 0) {\n        this.warn('No splitter contracts found in collection.');\n        return balances;\n      }\n\n      for (const splitterAddress of splitterAddresses) {\n        try {\n          const contract = new ethers.Contract(\n            splitterAddress,\n            RoyaltySplitterABI,\n            this.signer\n          );\n          const rawBalance = await contract.ethBalance(walletAddress);\n          const balance = ethers.formatEther(rawBalance);\n\n          if (rawBalance > 0n) {\n            balances.push({\n              splitter: splitterAddress,\n              balance,\n            });\n          }\n        } catch (innerErr: any) {\n          this.warn(\n            `Failed to fetch balance from splitter: ${splitterAddress}`,\n            innerErr.message\n          );\n        }\n      }\n    } catch (error: any) {\n      this.error('Error fetching splitter balances:', error);\n    }\n\n    return balances;\n  }\n\n  // Owner only - Approve token for sale\n  async approveTokenForSale(tokenId: number): Promise<string | null> {\n    try {\n      const tx = await this.nftContract.approve(this.marketplaceAddress, tokenId);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(\n        `Error approve your NFT tokenId: ${tokenId}, check your ownership`\n      );\n      return null;\n    }\n  }\n\n  // Withdraw royalty from a specific splitter\n  async withdrawRoyaltyFromSplitter(splitterAddress: string): Promise<any> {\n    try {\n      const contract = new ethers.Contract(\n        splitterAddress,\n        RoyaltySplitterABI,\n        this.signer\n      );\n      const walletAddress = await this.signer.getAddress();\n      const rawBalance = await contract.ethBalance(walletAddress);\n\n      if (rawBalance <= 0n) {\n        this.warn(` Skipping ${splitterAddress}: no funds to withdraw.`);\n        return null;\n      }\n\n      const balance = ethers.formatEther(rawBalance);\n\n      const tx = await contract.withdraw();\n      if (!tx || !tx.hash) {\n        this.warn(\n          `No transaction hash returned from withdraw() on ${splitterAddress}`\n        );\n        return null;\n      }\n\n      const receipt = await tx.wait();\n\n      this.warn(\n        `Withdrawn from splitter ${splitterAddress} | Tx: ${receipt.hash} | Amount: ${balance}`\n      );\n\n      return {\n        splitter: splitterAddress,\n        transactionHash: receipt.hash,\n        withdrawn: balance,\n      };\n    } catch (err: any) {\n      this.warn(\n        `Failed to withdraw from splitter: ${splitterAddress} | ${err.message}`\n      );\n      return null;\n    }\n  }\n\n  // Withdraw royalty fees from all existing splitter contracts\n  async withdrawAllRoyaltyFees(): Promise<any[] | null> {\n    try {\n      const walletAddress = await this.signer.getAddress();\n      const splitterBalances = await this.getSplitterBalanceOfWallet(walletAddress);\n\n      if (!splitterBalances || splitterBalances.length === 0) {\n        this.warn('No splitter contracts with available balances found.');\n        return null;\n      }\n\n      const receipts = [];\n\n      for (const item of splitterBalances) {\n        const result = await this.withdrawRoyaltyFromSplitter(item.splitter);\n        if (result) {\n          receipts.push(result);\n        }\n      }\n\n      return receipts;\n    } catch (error: any) {\n      this.error('Error withdrawing all royalty fees:', error);\n      return null;\n    }\n  }\n\n  // Withdraw marketplace fees (only owner of the contract)\n  async withdrawMarketPlaceFees(): Promise<string | null> {\n    const isAdmin = await this.isAdmin();\n\n    try {\n      if (!isAdmin) {\n        this.warn(\n          'You are not an admin of the Marketplace contract. Withdraw not allowed.'\n        );\n        return null;\n      }\n\n      const tx = await this.marketplaceContract.withdrawFees();\n      const receipt = await tx.wait();\n\n      this.warn(`Marketplace fees withdrawn successfully! Tx hash: ${receipt.hash}`);\n\n      return receipt.hash;\n    } catch (error: any) {\n      this.error('Error withdrawing marketplace fees, or check the fees balance');\n      return null;\n    }\n  }\n\n  // Check if connected wallet is admin\n  async isAdmin(): Promise<boolean> {\n    try {\n      const ADMIN_ROLE =\n        '0x0000000000000000000000000000000000000000000000000000000000000000';\n      const isAdmin = await this.nftContract.hasRole(\n        ADMIN_ROLE,\n        await this.signer.getAddress()\n      );\n      if (!isAdmin) {\n        this.warn('Please connect with an admin account before running isAdmin method.');\n      }\n      return isAdmin;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Admin only - Mint domain\n  async mintDomain(originalCreator: string, URI: string): Promise<string | null> {\n    if (!(await this.isAdmin())) return null;\n\n    try {\n      const tx = await this.nftContract.mint(originalCreator, URI);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(\n        'Error minting domain NFT, check you are the owner of the contract, or have minter role'\n      );\n      return null;\n    }\n  }\n\n  // Logging methods\n  log(...args: any[]) {\n    if (this.develop) console.log(...args);\n  }\n\n  warn(...args: any[]) {\n    if (this.develop) console.warn(...args);\n  }\n\n  error(...args: any[]) {\n    if (this.develop) console.error(...args);\n  }\n\n  // Set develop mode on/off\n  setDevelopMode(enabled: boolean) {\n    this.develop = !!enabled;\n    this.warn(`Develop mode set to ${this.develop}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}