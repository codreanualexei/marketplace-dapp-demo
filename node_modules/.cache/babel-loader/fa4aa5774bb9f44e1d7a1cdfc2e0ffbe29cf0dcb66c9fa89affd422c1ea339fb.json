{"ast":null,"code":"import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\nexport class CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return this;\n        }\n      default:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          }\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n          return CID.createV0(multihash);\n        }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest\n          } = this.multihash;\n          const multihash = Digest.create(code, digest);\n          return CID.createV1(this.code, multihash);\n        }\n      case 1:\n        {\n          return this;\n        }\n      default:\n        {\n          throw Error(\"Can not convert CID version \".concat(this.version, \" to version 0. This is a bug please report\"));\n        }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && Digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {\n      bytes,\n      version,\n      _baseCache\n    } = this;\n    switch (version) {\n      case 0:\n        return toStringV0(bytes, _baseCache, base || base58btc.encoder);\n      default:\n        return toStringV1(bytes, _baseCache, base || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(\"Version 0 CID must use dag-pb (code: \".concat(DAG_PB_CODE, \") block encoding\"));\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [cid, bytes.subarray(specs.size)];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(\"Invalid CID version \".concat(version));\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    case 'Q':\n      {\n        const decoder = base || base58btc;\n        return [base58btc.prefix, decoder.decode(\"\".concat(base58btc.prefix).concat(source))];\n      }\n    case base58btc.prefix:\n      {\n        const decoder = base || base58btc;\n        return [base58btc.prefix, decoder.decode(source)];\n      }\n    case base32.prefix:\n      {\n        const decoder = base || base32;\n        return [base32.prefix, decoder.decode(source)];\n      }\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n        }\n        return [source[0], base.decode(source)];\n      }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(\"Cannot string encode V0 in \".concat(base.name, \" encoding\"));\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = \"CID.isCID(v) is deprecated and will be removed in the next major release.\\nFollowing code pattern:\\n\\nif (CID.isCID(value)) {\\n  doSomethingWithCID(value)\\n}\\n\\nIs replaced with:\\n\\nconst cid = CID.asCID(value)\\nif (cid) {\\n  // Make sure to use cid instead of value\\n  doSomethingWithCID(cid)\\n}\\n\";","map":{"version":3,"names":["varint","Digest","base58btc","base32","coerce","CID","constructor","version","code","multihash","bytes","byteOffset","byteLength","asCID","_baseCache","Map","Object","defineProperties","hidden","readonly","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest","create","createV1","concat","equals","other","toString","base","toStringV0","encoder","toStringV1","toJSON","hash","Symbol","toStringTag","for","isCID","value","deprecate","IS_CID_DEPRECATION","cidSymbol","toBaseEncodedString","codec","buffer","multibaseName","prefix","encodeCID","decode","cid","remainder","decodeFirst","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","initialBytes","offset","next","i","RangeError","parse","source","parseCIDtoBytes","set","decoder","cache","name","get","encode","slice","codeOffset","encodingLength","hashOffset","Uint8Array","encodeTo","writable","configurable","enumerable","range","message","test","console","warn"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/multiformats/esm/src/cid.js"],"sourcesContent":["import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\nexport class CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest} = this.multihash;\n        const multihash = Digest.create(code, digest);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && Digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [\n      cid,\n      bytes.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(`${ base58btc.prefix }${ source }`)\n      ];\n    }\n  case base58btc.prefix: {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case base32.prefix: {\n      const decoder = base || base32;\n      return [\n        base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}