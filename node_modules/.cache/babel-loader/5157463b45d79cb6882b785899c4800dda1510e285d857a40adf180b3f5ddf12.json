{"ast":null,"code":"import _wrapAsyncGenerator from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nimport _awaitAsyncGenerator from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _asyncGeneratorDelegate from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport { prettyByte } from \"./utils/prettyByte.mjs\";\nimport { ExtensionCodec } from \"./ExtensionCodec.mjs\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.mjs\";\nimport { utf8Decode } from \"./utils/utf8.mjs\";\nimport { ensureUint8Array } from \"./utils/typedArrays.mjs\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.mjs\";\nimport { DecodeError } from \"./DecodeError.mjs\";\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\nconst mapKeyConverter = key => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\nclass StackPool {\n  constructor() {\n    this.stack = [];\n    this.stackHeadPosition = -1;\n  }\n  get length() {\n    return this.stackHeadPosition + 1;\n  }\n  top() {\n    return this.stack[this.stackHeadPosition];\n  }\n  pushArrayState(size) {\n    const state = this.getUninitializedStateFromPool();\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n  pushMapState(size) {\n    const state = this.getUninitializedStateFromPool();\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n  getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null\n      };\n      this.stack.push(partialState);\n    }\n    return this.stack[this.stackHeadPosition];\n  }\n  release(state) {\n    const topStackState = this.stack[this.stackHeadPosition];\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n    if (state.type === STATE_ARRAY) {\n      const partialState = state;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n    this.stackHeadPosition--;\n  }\n  reset() {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\nconst HEAD_BYTE_REQUIRED = -1;\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\");\n  }\n}\nconst MORE_DATA = new RangeError(\"Insufficient data\");\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\nexport class Decoder {\n  constructor(options) {\n    var _options$extensionCod, _options$useBigInt, _options$rawStrings, _options$maxStrLength, _options$maxBinLength, _options$maxArrayLeng, _options$maxMapLength, _options$maxExtLength, _options$mapKeyConver;\n    this.totalPos = 0;\n    this.pos = 0;\n    this.view = EMPTY_VIEW;\n    this.bytes = EMPTY_BYTES;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack = new StackPool();\n    this.entered = false;\n    this.extensionCodec = (_options$extensionCod = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _options$extensionCod !== void 0 ? _options$extensionCod : ExtensionCodec.defaultCodec;\n    this.context = options === null || options === void 0 ? void 0 : options.context; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n    this.useBigInt64 = (_options$useBigInt = options === null || options === void 0 ? void 0 : options.useBigInt64) !== null && _options$useBigInt !== void 0 ? _options$useBigInt : false;\n    this.rawStrings = (_options$rawStrings = options === null || options === void 0 ? void 0 : options.rawStrings) !== null && _options$rawStrings !== void 0 ? _options$rawStrings : false;\n    this.maxStrLength = (_options$maxStrLength = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _options$maxStrLength !== void 0 ? _options$maxStrLength : UINT32_MAX;\n    this.maxBinLength = (_options$maxBinLength = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _options$maxBinLength !== void 0 ? _options$maxBinLength : UINT32_MAX;\n    this.maxArrayLength = (_options$maxArrayLeng = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _options$maxArrayLeng !== void 0 ? _options$maxArrayLeng : UINT32_MAX;\n    this.maxMapLength = (_options$maxMapLength = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _options$maxMapLength !== void 0 ? _options$maxMapLength : UINT32_MAX;\n    this.maxExtLength = (_options$maxExtLength = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _options$maxExtLength !== void 0 ? _options$maxExtLength : UINT32_MAX;\n    this.keyDecoder = (options === null || options === void 0 ? void 0 : options.keyDecoder) !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = (_options$mapKeyConver = options === null || options === void 0 ? void 0 : options.mapKeyConverter) !== null && _options$mapKeyConver !== void 0 ? _options$mapKeyConver : mapKeyConverter;\n  }\n  clone() {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder\n    });\n  }\n  reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n  setBuffer(buffer) {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n  appendBuffer(buffer) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n  hasRemaining(size) {\n    return this.view.byteLength - this.pos >= size;\n  }\n  createExtraByteError(posToShow) {\n    const {\n      view,\n      pos\n    } = this;\n    return new RangeError(\"Extra \".concat(view.byteLength - pos, \" of \").concat(view.byteLength, \" byte(s) found at buffer[\").concat(posToShow, \"]\"));\n  }\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  decode(buffer) {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n    try {\n      this.entered = true;\n      this.reinitializeState();\n      this.setBuffer(buffer);\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n  *decodeMulti(buffer) {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n    try {\n      this.entered = true;\n      this.reinitializeState();\n      this.setBuffer(buffer);\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n  async decodeAsync(stream) {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n    try {\n      this.entered = true;\n      let decoded = false;\n      let object;\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const buffer = _step.value;\n          {\n            if (decoded) {\n              this.entered = false;\n              throw this.createExtraByteError(this.totalPos);\n            }\n            this.appendBuffer(buffer);\n            try {\n              object = this.doDecodeSync();\n              decoded = true;\n            } catch (e) {\n              if (!(e instanceof RangeError)) {\n                throw e; // rethrow\n              }\n              // fallthrough\n            }\n            this.totalPos += this.pos;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            await _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n      const {\n        headByte,\n        pos,\n        totalPos\n      } = this;\n      throw new RangeError(\"Insufficient data in parsing \".concat(prettyByte(headByte), \" at \").concat(totalPos, \" (\").concat(pos, \" in the current buffer)\"));\n    } finally {\n      this.entered = false;\n    }\n  }\n  decodeArrayStream(stream) {\n    return this.decodeMultiAsync(stream, true);\n  }\n  decodeStream(stream) {\n    return this.decodeMultiAsync(stream, false);\n  }\n  decodeMultiAsync(stream, isArray) {\n    var _this = this;\n    return _wrapAsyncGenerator(function* () {\n      if (_this.entered) {\n        const instance = _this.clone();\n        yield* _asyncGeneratorDelegate(_asyncIterator(instance.decodeMultiAsync(stream, isArray)), _awaitAsyncGenerator);\n        return;\n      }\n      try {\n        _this.entered = true;\n        let isArrayHeaderRequired = isArray;\n        let arrayItemsLeft = -1;\n        var _iteratorAbruptCompletion2 = false;\n        var _didIteratorError2 = false;\n        var _iteratorError2;\n        try {\n          for (var _iterator2 = _asyncIterator(stream), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n            const buffer = _step2.value;\n            {\n              if (isArray && arrayItemsLeft === 0) {\n                throw _this.createExtraByteError(_this.totalPos);\n              }\n              _this.appendBuffer(buffer);\n              if (isArrayHeaderRequired) {\n                arrayItemsLeft = _this.readArraySize();\n                isArrayHeaderRequired = false;\n                _this.complete();\n              }\n              try {\n                while (true) {\n                  yield _this.doDecodeSync();\n                  if (--arrayItemsLeft === 0) {\n                    break;\n                  }\n                }\n              } catch (e) {\n                if (!(e instanceof RangeError)) {\n                  throw e; // rethrow\n                }\n                // fallthrough\n              }\n              _this.totalPos += _this.pos;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n              yield _awaitAsyncGenerator(_iterator2.return());\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } finally {\n        _this.entered = false;\n      }\n    })();\n  }\n  doDecodeSync() {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object;\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(\"Unrecognized type byte: \".concat(prettyByte(headByte)));\n      }\n      this.complete();\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top();\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n          state.map[state.key] = object;\n          state.readCount++;\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n      return object;\n    }\n  }\n  readHeadByte() {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n    return this.headByte;\n  }\n  complete() {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n  readArraySize() {\n    const headByte = this.readHeadByte();\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default:\n        {\n          if (headByte < 0xa0) {\n            return headByte - 0x90;\n          } else {\n            throw new DecodeError(\"Unrecognized array type byte: \".concat(prettyByte(headByte)));\n          }\n        }\n    }\n  }\n  pushMapState(size) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(\"Max length exceeded: map length (\".concat(size, \") > maxMapLengthLength (\").concat(this.maxMapLength, \")\"));\n    }\n    this.stack.pushMapState(size);\n  }\n  pushArrayState(size) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(\"Max length exceeded: array length (\".concat(size, \") > maxArrayLength (\").concat(this.maxArrayLength, \")\"));\n    }\n    this.stack.pushArrayState(size);\n  }\n  decodeString(byteLength, headerOffset) {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n  /**\n   * @throws {@link RangeError}\n   */\n  decodeUtf8String(byteLength, headerOffset) {\n    var _this$keyDecoder;\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\"Max length exceeded: UTF-8 byte length (\".concat(byteLength, \") > maxStrLength (\").concat(this.maxStrLength, \")\"));\n    }\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n    const offset = this.pos + headerOffset;\n    let object;\n    if (this.stateIsMapKey() && (_this$keyDecoder = this.keyDecoder) !== null && _this$keyDecoder !== void 0 && _this$keyDecoder.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n  stateIsMapKey() {\n    if (this.stack.length > 0) {\n      const state = this.stack.top();\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n  /**\n   * @throws {@link RangeError}\n   */\n  decodeBinary(byteLength, headOffset) {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(\"Max length exceeded: bin length (\".concat(byteLength, \") > maxBinLength (\").concat(this.maxBinLength, \")\"));\n    }\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n  decodeExtension(size, headOffset) {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(\"Max length exceeded: ext length (\".concat(size, \") > maxExtLength (\").concat(this.maxExtLength, \")\"));\n    }\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n  lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n  lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n  lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n  readU8() {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n  readI8() {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n  readU16() {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n  readI16() {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n  readU32() {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n  readI32() {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n  readU64() {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readI64() {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readU64AsBigInt() {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readI64AsBigInt() {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n  readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n  readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}","map":{"version":3,"names":["prettyByte","ExtensionCodec","getInt64","getUint64","UINT32_MAX","utf8Decode","ensureUint8Array","CachedKeyDecoder","DecodeError","STATE_ARRAY","STATE_MAP_KEY","STATE_MAP_VALUE","mapKeyConverter","key","StackPool","constructor","stack","stackHeadPosition","length","top","pushArrayState","size","state","getUninitializedStateFromPool","type","position","array","Array","pushMapState","readCount","map","partialState","undefined","push","release","topStackState","Error","reset","HEAD_BYTE_REQUIRED","EMPTY_VIEW","DataView","ArrayBuffer","EMPTY_BYTES","Uint8Array","buffer","getInt8","e","RangeError","MORE_DATA","sharedCachedKeyDecoder","Decoder","options","_options$extensionCod","_options$useBigInt","_options$rawStrings","_options$maxStrLength","_options$maxBinLength","_options$maxArrayLeng","_options$maxMapLength","_options$maxExtLength","_options$mapKeyConver","totalPos","pos","view","bytes","headByte","entered","extensionCodec","defaultCodec","context","useBigInt64","rawStrings","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","clone","reinitializeState","setBuffer","byteOffset","byteLength","appendBuffer","hasRemaining","remainingData","subarray","newData","newBuffer","set","createExtraByteError","posToShow","concat","decode","instance","object","doDecodeSync","decodeMulti","decodeAsync","stream","decoded","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","value","err","return","decodeArrayStream","decodeMultiAsync","decodeStream","isArray","_this","_wrapAsyncGenerator","_asyncGeneratorDelegate","_awaitAsyncGenerator","isArrayHeaderRequired","arrayItemsLeft","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","readArraySize","complete","DECODE","readHeadByte","decodeString","readF32","readF64","readU8","readU16","readU32","readU64AsBigInt","readU64","readI8","readI16","readI32","readI64AsBigInt","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","headerOffset","stateIsMapKey","decodeUtf8String","_this$keyDecoder","offset","canBeCached","headOffset","extType","data","getUint8","getUint16","getUint32","getInt16","getInt32","getBigUint64","getBigInt64","getFloat32","getFloat64"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@msgpack/msgpack/src/Decoder.ts"],"sourcesContent":["import { prettyByte } from \"./utils/prettyByte.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.ts\";\nimport { utf8Decode } from \"./utils/utf8.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.ts\";\nimport { DecodeError } from \"./DecodeError.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\nimport type { KeyDecoder } from \"./CachedKeyDecoder.ts\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * By default, string values will be decoded as UTF-8 strings. However, if this option is true,\n     * string values will be returned as Uint8Arrays without additional decoding.\n     *\n     * This is useful if the strings may contain invalid UTF-8 sequences.\n     *\n     * Note that this option only applies to string values, not map keys. Additionally, when\n     * enabled, raw string length is limited by the maxBinLength option.\n     */\n    rawStrings: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n\n    /**\n     * A function to convert decoded map key to a valid JS key type.\n     *\n     * Defaults to a function that throws an error if the key is not a string or a number.\n     */\n    mapKeyConverter: (key: unknown) => MapKeyType;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst mapKeyConverter = (key: unknown): MapKeyType => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\nclass StackPool {\n  private readonly stack: Array<StackState> = [];\n  private stackHeadPosition = -1;\n\n  public get length(): number {\n    return this.stackHeadPosition + 1;\n  }\n\n  public top(): StackState | undefined {\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public pushArrayState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\n\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n\n  public pushMapState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackMapState;\n\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n\n  private getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState: Partial<StackState> = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null,\n      };\n\n      this.stack.push(partialState as StackState);\n    }\n\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public release(state: StackState): void {\n    const topStackState = this.stack[this.stackHeadPosition];\n\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n\n    if (state.type === STATE_ARRAY) {\n      const partialState = state as Partial<StackArrayState>;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state as Partial<StackMapState>;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n\n    this.stackHeadPosition--;\n  }\n\n  public reset(): void {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView<ArrayBufferLike>(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array<ArrayBufferLike>(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\n    );\n  }\n}\n\nconst MORE_DATA = new RangeError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly rawStrings: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n  private readonly mapKeyConverter: (key: unknown) => MapKeyType;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack = new StackPool();\n\n  private entered = false;\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.rawStrings = options?.rawStrings ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n  }\n\n  private clone(): Decoder<ContextType> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): unknown {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): Generator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): Promise<unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n\n    try {\n      this.entered = true;\n\n      let decoded = false;\n      let object: unknown;\n      for await (const buffer of stream) {\n        if (decoded) {\n          this.entered = false;\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        try {\n          object = this.doDecodeSync();\n          decoded = true;\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n\n      const { headByte, pos, totalPos } = this;\n      throw new RangeError(\n        `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n      );\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>, isArray: boolean): AsyncGenerator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMultiAsync(stream, isArray);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      let isArrayHeaderRequired = isArray;\n      let arrayItemsLeft = -1;\n\n      for await (const buffer of stream) {\n        if (isArray && arrayItemsLeft === 0) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        if (isArrayHeaderRequired) {\n          arrayItemsLeft = this.readArraySize();\n          isArrayHeaderRequired = false;\n          this.complete();\n        }\n\n        try {\n          while (true) {\n            yield this.doDecodeSync();\n            if (--arrayItemsLeft === 0) {\n              break;\n            }\n          }\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top()!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.pushMapState(size);\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.pushArrayState(size);\n  }\n\n  private decodeString(byteLength: number, headerOffset: number): string | Uint8Array {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack.top()!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readU64AsBigInt(): bigint {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64AsBigInt(): bigint {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}