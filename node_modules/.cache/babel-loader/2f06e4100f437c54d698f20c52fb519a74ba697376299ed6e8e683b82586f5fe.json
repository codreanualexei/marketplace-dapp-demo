{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n// TODO(v3): checksum address.\nimport { AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../errors/abi.js';\nimport { isAddressEqual } from '../address/isAddressEqual.js';\nimport { toBytes } from '../encoding/toBytes.js';\nimport { keccak256 } from '../hash/keccak256.js';\nimport { toEventSelector } from '../hash/toEventSelector.js';\nimport { decodeEventLog } from './decodeEventLog.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs(parameters) {\n  const {\n    abi,\n    args,\n    logs,\n    strict = true\n  } = parameters;\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined;\n    if (Array.isArray(parameters.eventName)) return parameters.eventName;\n    return [parameters.eventName];\n  })();\n  return logs.map(log => {\n    try {\n      const abiItem = abi.find(abiItem => abiItem.type === 'event' && log.topics[0] === toEventSelector(abiItem));\n      if (!abiItem) return null;\n      const event = decodeEventLog(_objectSpread(_objectSpread({}, log), {}, {\n        abi: [abiItem],\n        strict\n      }));\n      // Check that the decoded event name matches the provided event name.\n      if (eventName && !eventName.includes(event.eventName)) return null;\n      // Check that the decoded event args match the provided args.\n      if (!includesArgs({\n        args: event.args,\n        inputs: abiItem.inputs,\n        matchArgs: args\n      })) return null;\n      return _objectSpread(_objectSpread({}, event), log);\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof AbiEventSignatureNotFoundError) return null;\n      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n        var _err$abiItem$inputs;\n        // If strict mode is on, and log data/topics do not match event definition, skip.\n        if (strict) return null;\n        eventName = err.abiItem.name;\n        isUnnamed = (_err$abiItem$inputs = err.abiItem.inputs) === null || _err$abiItem$inputs === void 0 ? void 0 : _err$abiItem$inputs.some(x => !('name' in x && x.name));\n      }\n      // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n      return _objectSpread(_objectSpread({}, log), {}, {\n        args: isUnnamed ? [] : {},\n        eventName\n      });\n    }\n  }).filter(Boolean);\n}\nfunction includesArgs(parameters) {\n  const {\n    args,\n    inputs,\n    matchArgs\n  } = parameters;\n  if (!matchArgs) return true;\n  if (!args) return false;\n  function isEqual(input, value, arg) {\n    try {\n      if (input.type === 'address') return isAddressEqual(value, arg);\n      if (input.type === 'string' || input.type === 'bytes') return keccak256(toBytes(value)) === arg;\n      return value === arg;\n    } catch (_unused) {\n      return false;\n    }\n  }\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true;\n      const input = inputs[index];\n      if (!input) return false;\n      const value_ = Array.isArray(value) ? value : [value];\n      return value_.some(value => isEqual(input, value, args[index]));\n    });\n  }\n  if (typeof args === 'object' && !Array.isArray(args) && typeof matchArgs === 'object' && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(_ref => {\n    let [key, value] = _ref;\n    if (value === null || value === undefined) return true;\n    const input = inputs.find(input => input.name === key);\n    if (!input) return false;\n    const value_ = Array.isArray(value) ? value : [value];\n    return value_.some(value => isEqual(input, value, args[key]));\n  });\n  return false;\n}","map":{"version":3,"names":["AbiEventSignatureNotFoundError","DecodeLogDataMismatch","DecodeLogTopicsMismatch","isAddressEqual","toBytes","keccak256","toEventSelector","decodeEventLog","parseEventLogs","parameters","abi","args","logs","strict","eventName","undefined","Array","isArray","map","log","abiItem","find","type","topics","event","_objectSpread","includes","includesArgs","inputs","matchArgs","err","isUnnamed","_err$abiItem$inputs","name","some","x","filter","Boolean","isEqual","input","value","arg","_unused","every","index","value_","Object","entries","_ref","key"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@walletconnect/universal-provider/node_modules/viem/utils/abi/parseEventLogs.ts"],"sourcesContent":["// TODO(v3): checksum address.\n\nimport type { Abi, AbiEvent, AbiEventParameter, Address } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName, GetEventArgs } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport { isAddressEqual } from '../address/isAddressEqual.js'\nimport { toBytes } from '../encoding/toBytes.js'\nimport { keccak256 } from '../hash/keccak256.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  allArgs = GetEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>,\n    {\n      EnableUnion: true\n      IndexedOnly: false\n      Required: false\n    }\n  >,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Arguments for the event. */\n  args?: allArgs | undefined\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>(\n  parameters: ParseEventLogsParameters<abi, eventName, strict>,\n): ParseEventLogsReturnType<abi, eventName, strict> {\n  const { abi, args, logs, strict = true } = parameters\n\n  const eventName = (() => {\n    if (!parameters.eventName) return undefined\n    if (Array.isArray(parameters.eventName)) return parameters.eventName\n    return [parameters.eventName as string]\n  })()\n\n  return logs\n    .map((log) => {\n      try {\n        const abiItem = (abi as Abi).find(\n          (abiItem) =>\n            abiItem.type === 'event' &&\n            log.topics[0] === toEventSelector(abiItem),\n        ) as AbiEvent\n        if (!abiItem) return null\n\n        const event = decodeEventLog({\n          ...log,\n          abi: [abiItem],\n          strict,\n        })\n\n        // Check that the decoded event name matches the provided event name.\n        if (eventName && !eventName.includes(event.eventName)) return null\n\n        // Check that the decoded event args match the provided args.\n        if (\n          !includesArgs({\n            args: event.args,\n            inputs: abiItem.inputs,\n            matchArgs: args,\n          })\n        )\n          return null\n\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n\nfunction includesArgs(parameters: {\n  args: unknown\n  inputs: AbiEvent['inputs']\n  matchArgs: unknown\n}) {\n  const { args, inputs, matchArgs } = parameters\n\n  if (!matchArgs) return true\n  if (!args) return false\n\n  function isEqual(input: AbiEventParameter, value: unknown, arg: unknown) {\n    try {\n      if (input.type === 'address')\n        return isAddressEqual(value as Address, arg as Address)\n      if (input.type === 'string' || input.type === 'bytes')\n        return keccak256(toBytes(value as string)) === arg\n      return value === arg\n    } catch {\n      return false\n    }\n  }\n\n  if (Array.isArray(args) && Array.isArray(matchArgs)) {\n    return matchArgs.every((value, index) => {\n      if (value === null || value === undefined) return true\n      const input = inputs[index]\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) => isEqual(input, value, args[index]))\n    })\n  }\n\n  if (\n    typeof args === 'object' &&\n    !Array.isArray(args) &&\n    typeof matchArgs === 'object' &&\n    !Array.isArray(matchArgs)\n  )\n    return Object.entries(matchArgs).every(([key, value]) => {\n      if (value === null || value === undefined) return true\n      const input = inputs.find((input) => input.name === key)\n      if (!input) return false\n      const value_ = Array.isArray(value) ? value : [value]\n      return value_.some((value) =>\n        isEqual(input, value, (args as Record<string, unknown>)[key]),\n      )\n    })\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}