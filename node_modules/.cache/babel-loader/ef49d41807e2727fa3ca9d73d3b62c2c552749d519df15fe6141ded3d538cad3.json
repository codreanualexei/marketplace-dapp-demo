{"ast":null,"code":"import { desc as t } from \"./base.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction e(e, r) {\n  return (n, s, i) => {\n    const o = t => {\n      var _t$renderRoot$querySe, _t$renderRoot;\n      return (_t$renderRoot$querySe = (_t$renderRoot = t.renderRoot) === null || _t$renderRoot === void 0 ? void 0 : _t$renderRoot.querySelector(e)) !== null && _t$renderRoot$querySe !== void 0 ? _t$renderRoot$querySe : null;\n    };\n    if (r) {\n      const {\n        get: e,\n        set: r\n      } = \"object\" == typeof s ? n : i !== null && i !== void 0 ? i : (() => {\n        const t = Symbol();\n        return {\n          get() {\n            return this[t];\n          },\n          set(e) {\n            this[t] = e;\n          }\n        };\n      })();\n      return t(n, s, {\n        get() {\n          let t = e.call(this);\n          return void 0 === t && (t = o(this), (null !== t || this.hasUpdated) && r.call(this, t)), t;\n        }\n      });\n    }\n    return t(n, s, {\n      get() {\n        return o(this);\n      }\n    });\n  };\n}\nexport { e as query };","map":{"version":3,"names":["e","r","n","s","i","o","t","_t$renderRoot$querySe","_t$renderRoot","renderRoot","querySelector","get","set","Symbol","call","hasUpdated","query"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@lit/reactive-element/src/decorators/query.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport type {ReactiveElement} from '../reactive-element.js';\nimport {desc, type Interface} from './base.js';\n\nconst DEV_MODE = true;\n\nlet issueWarning: (code: string, warning: string) => void;\n\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  globalThis.litIssuedWarnings ??= new Set();\n\n  /**\n   * Issue a warning if we haven't already, based either on `code` or `warning`.\n   * Warnings are disabled automatically only by `warning`; disabling via `code`\n   * can be done by users.\n   */\n  issueWarning = (code: string, warning: string) => {\n    warning += code\n      ? ` See https://lit.dev/msg/${code} for more information.`\n      : '';\n    if (\n      !globalThis.litIssuedWarnings!.has(warning) &&\n      !globalThis.litIssuedWarnings!.has(code)\n    ) {\n      console.warn(warning);\n      globalThis.litIssuedWarnings!.add(warning);\n    }\n  };\n}\n\nexport type QueryDecorator = {\n  // legacy\n  (\n    proto: Interface<ReactiveElement>,\n    name: PropertyKey,\n    descriptor?: PropertyDescriptor\n    // Note TypeScript requires the return type to be `void|any`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): void | any;\n\n  // standard\n  <C extends Interface<ReactiveElement>, V extends Element | null>(\n    value: ClassAccessorDecoratorTarget<C, V>,\n    context: ClassAccessorDecoratorContext<C, V>\n  ): ClassAccessorDecoratorResult<C, V>;\n};\n\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n * @param cache An optional boolean which when true performs the DOM query only\n *     once and caches the result.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * ```ts\n * class MyElement {\n *   @query('#first')\n *   first: HTMLDivElement;\n *\n *   render() {\n *     return html`\n *       <div id=\"first\"></div>\n *       <div id=\"second\"></div>\n *     `;\n *   }\n * }\n * ```\n * @category Decorator\n */\nexport function query(selector: string, cache?: boolean): QueryDecorator {\n  return (<C extends Interface<ReactiveElement>, V extends Element | null>(\n    protoOrTarget: ClassAccessorDecoratorTarget<C, V>,\n    nameOrContext: PropertyKey | ClassAccessorDecoratorContext<C, V>,\n    descriptor?: PropertyDescriptor\n  ) => {\n    const doQuery = (el: Interface<ReactiveElement>): V => {\n      const result = (el.renderRoot?.querySelector(selector) ?? null) as V;\n      if (DEV_MODE && result === null && cache && !el.hasUpdated) {\n        const name =\n          typeof nameOrContext === 'object'\n            ? nameOrContext.name\n            : nameOrContext;\n        issueWarning(\n          '',\n          `@query'd field ${JSON.stringify(String(name))} with the 'cache' ` +\n            `flag set for selector '${selector}' has been accessed before ` +\n            `the first update and returned null. This is expected if the ` +\n            `renderRoot tree has not been provided beforehand (e.g. via ` +\n            `Declarative Shadow DOM). Therefore the value hasn't been cached.`\n        );\n      }\n      // TODO: if we want to allow users to assert that the query will never\n      // return null, we need a new option and to throw here if the result\n      // is null.\n      return result;\n    };\n    if (cache) {\n      // Accessors to wrap from either:\n      //   1. The decorator target, in the case of standard decorators\n      //   2. The property descriptor, in the case of experimental decorators\n      //      on auto-accessors.\n      //   3. Functions that access our own cache-key property on the instance,\n      //      in the case of experimental decorators on fields.\n      const {get, set} =\n        typeof nameOrContext === 'object'\n          ? protoOrTarget\n          : descriptor ??\n            (() => {\n              const key = DEV_MODE\n                ? Symbol(`${String(nameOrContext)} (@query() cache)`)\n                : Symbol();\n              type WithCache = ReactiveElement & {\n                [key: symbol]: Element | null;\n              };\n              return {\n                get() {\n                  return (this as WithCache)[key];\n                },\n                set(v) {\n                  (this as WithCache)[key] = v;\n                },\n              };\n            })();\n      return desc(protoOrTarget, nameOrContext, {\n        get(this: ReactiveElement): V {\n          let result: V = get!.call(this);\n          if (result === undefined) {\n            result = doQuery(this);\n            if (result !== null || this.hasUpdated) {\n              set!.call(this, result);\n            }\n          }\n          return result;\n        },\n      });\n    } else {\n      // This object works as the return type for both standard and\n      // experimental decorators.\n      return desc(protoOrTarget, nameOrContext, {\n        get(this: ReactiveElement) {\n          return doQuery(this);\n        },\n      });\n    }\n  }) as QueryDecorator;\n}\n"],"mappings":";;;;;;AAqFgB,SAAAA,EAAMA,CAAA,EAAkBC,CAAA;EACtC,QACEC,CAAA,EACAC,CAAA,EACAC,CAAA;IAEA,MAAMC,CAAA,GAAWC,CAAA;MAAA,IAAAC,qBAAA,EAAAC,aAAA;MAAA,QAAAD,qBAAA,IAAAC,aAAA,GACCF,CAAA,CAAGG,UAAA,cAAAD,aAAA,uBAAHA,aAAA,CAAeE,aAAA,CAAcV,CAAA,eAAAO,qBAAA,cAAAA,qBAAA,GAAa;IAAA;IAoB5D,IAAIN,CAAA,EAAO;MAOT;QAAMU,GAAA,EAACX,CAAA;QAAGY,GAAA,EAAEX;MAAA,IACe,mBAAlBE,CAAA,GACHD,CAAA,GACAE,CAAA,aAAAA,CAAA,cAAAA,CAAA,GACA;QACE,MAAME,CAAA,GAEFO,MAAA;QAIJ,OAAO;UACLF,IAAA;YACE,OAAQ,KAAmBL,CAAA,CAC5B;UAAA;UACDM,IAAIZ,CAAA;YACD,KAAmBM,CAAA,IAAON,CAC5B;UAAA;QAAA,CAEJ;MAAA,GAfD;MAgBN,OAAOM,CAAA,CAAKJ,CAAA,EAAeC,CAAA,EAAe;QACxCQ,IAAA;UACE,IAAIL,CAAA,GAAYN,CAAA,CAAKc,IAAA,CAAK;UAO1B,YANe,MAAXR,CAAA,KACFA,CAAA,GAASD,CAAA,CAAQ,QACF,SAAXC,CAAA,IAAmB,KAAKS,UAAA,KAC1Bd,CAAA,CAAKa,IAAA,CAAK,MAAMR,CAAA,IAGbA,CACR;QAAA;MAAA,EAEJ;IAAA;IAGC,OAAOA,CAAA,CAAKJ,CAAA,EAAeC,CAAA,EAAe;MACxCQ,IAAA;QACE,OAAON,CAAA,CAAQ,KAChB;MAAA;IAAA,EAGN;EAAA,CACH;AAAA;AAAA,SAAAL,CAAA,IAAAgB,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}