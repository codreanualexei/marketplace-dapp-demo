{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"address\", \"factory\", \"factoryData\", \"hash\", \"signature\", \"universalSignatureVerifierAddress\"];\nimport { universalSignatureValidatorAbi } from '../../constants/abis.js';\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js';\nimport { CallExecutionError } from '../../errors/contract.js';\nimport { encodeDeployData } from '../../utils/abi/encodeDeployData.js';\nimport { getAddress } from '../../utils/address/getAddress.js';\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js';\nimport { isHex } from '../../utils/data/isHex.js';\nimport { bytesToHex } from '../../utils/encoding/toHex.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { encodeFunctionData, hexToBool } from '../../utils/index.js';\nimport { isErc6492Signature } from '../../utils/signature/isErc6492Signature.js';\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js';\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js';\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js';\nimport { call } from './call.js';\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash(client, parameters) {\n  var _client$chain;\n  const {\n      address,\n      factory,\n      factoryData,\n      hash,\n      signature,\n      universalSignatureVerifierAddress = (_client$chain = client.chain) === null || _client$chain === void 0 || (_client$chain = _client$chain.contracts) === null || _client$chain === void 0 || (_client$chain = _client$chain.universalSignatureVerifier) === null || _client$chain === void 0 ? void 0 : _client$chain.address\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature;\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature) return serializeSignature(signature);\n    return bytesToHex(signature);\n  })();\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signatureHex;\n    // If the signature is already wrapped, return the signature.\n    if (isErc6492Signature(signatureHex)) return signatureHex;\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return serializeErc6492Signature({\n      address: factory,\n      data: factoryData,\n      signature: signatureHex\n    });\n  })();\n  try {\n    const args = universalSignatureVerifierAddress ? _objectSpread({\n      to: universalSignatureVerifierAddress,\n      data: encodeFunctionData({\n        abi: universalSignatureValidatorAbi,\n        functionName: 'isValidSig',\n        args: [address, hash, wrappedSignature]\n      })\n    }, rest) : _objectSpread({\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, wrappedSignature],\n        bytecode: universalSignatureValidatorByteCode\n      })\n    }, rest);\n    const {\n      data\n    } = await getAction(client, call, 'call')(args);\n    return hexToBool(data !== null && data !== void 0 ? data : '0x0');\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(getAddress(address), await recoverAddress({\n        hash,\n        signature\n      }));\n      if (verified) return true;\n    } catch (_unused) {}\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false;\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["universalSignatureValidatorAbi","universalSignatureValidatorByteCode","CallExecutionError","encodeDeployData","getAddress","isAddressEqual","isHex","bytesToHex","getAction","encodeFunctionData","hexToBool","isErc6492Signature","recoverAddress","serializeErc6492Signature","serializeSignature","call","verifyHash","client","parameters","_client$chain","address","factory","factoryData","hash","signature","universalSignatureVerifierAddress","chain","contracts","universalSignatureVerifier","rest","_objectWithoutProperties","_excluded","signatureHex","wrappedSignature","data","args","_objectSpread","to","abi","functionName","bytecode","error","verified","_unused"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@walletconnect/universal-provider/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalSignatureValidatorAbi } from '../../constants/abis.js'\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { InvalidHexBooleanError } from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex, Signature } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport { getAddress } from '../../utils/address/getAddress.js'\nimport { isAddressEqual } from '../../utils/address/isAddressEqual.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { bytesToHex, type ToHexErrorType } from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { encodeFunctionData, hexToBool } from '../../utils/index.js'\nimport { isErc6492Signature } from '../../utils/signature/isErc6492Signature.js'\nimport { recoverAddress } from '../../utils/signature/recoverAddress.js'\nimport { serializeErc6492Signature } from '../../utils/signature/serializeErc6492Signature.js'\nimport { serializeSignature } from '../../utils/signature/serializeSignature.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The hash to be verified. */\n  hash: Hex\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray | Signature\n  universalSignatureVerifierAddress?: Address | undefined\n} & OneOf<{ factory: Address; factoryData: Hex } | {}>\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | CallErrorType\n  | IsHexErrorType\n  | ToHexErrorType\n  | InvalidHexBooleanError\n  | EncodeDeployDataErrorType\n  | ErrorType\n\n/**\n * Verifies a message hash onchain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  parameters: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const {\n    address,\n    factory,\n    factoryData,\n    hash,\n    signature,\n    universalSignatureVerifierAddress = client.chain?.contracts\n      ?.universalSignatureVerifier?.address,\n    ...rest\n  } = parameters\n\n  const signatureHex = (() => {\n    if (isHex(signature)) return signature\n    if (typeof signature === 'object' && 'r' in signature && 's' in signature)\n      return serializeSignature(signature)\n    return bytesToHex(signature)\n  })()\n\n  const wrappedSignature = await (async () => {\n    // If no `factory` or `factoryData` is provided, it is assumed that the\n    // address is not a Smart Account, or the Smart Account is already deployed.\n    if (!factory && !factoryData) return signatureHex\n\n    // If the signature is already wrapped, return the signature.\n    if (isErc6492Signature(signatureHex)) return signatureHex\n\n    // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper\n    // to perform counterfactual validation.\n    return serializeErc6492Signature({\n      address: factory!,\n      data: factoryData!,\n      signature: signatureHex,\n    })\n  })()\n\n  try {\n    const args = universalSignatureVerifierAddress\n      ? ({\n          to: universalSignatureVerifierAddress,\n          data: encodeFunctionData({\n            abi: universalSignatureValidatorAbi,\n            functionName: 'isValidSig',\n            args: [address, hash, wrappedSignature],\n          }),\n          ...rest,\n        } as unknown as CallParameters)\n      : ({\n          data: encodeDeployData({\n            abi: universalSignatureValidatorAbi,\n            args: [address, hash, wrappedSignature],\n            bytecode: universalSignatureValidatorByteCode,\n          }),\n          ...rest,\n        } as unknown as CallParameters)\n\n    const { data } = await getAction(client, call, 'call')(args)\n\n    return hexToBool(data ?? '0x0')\n  } catch (error) {\n    // Fallback attempt to verify the signature via ECDSA recovery.\n    try {\n      const verified = isAddressEqual(\n        getAddress(address),\n        await recoverAddress({ hash, signature }),\n      )\n      if (verified) return true\n    } catch {}\n\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n"],"mappings":";;;AAIA,SAASA,8BAA8B,QAAQ,yBAAyB;AACxE,SAASC,mCAAmC,QAAQ,8BAA8B;AAClF,SAASC,kBAAkB,QAAQ,0BAA0B;AAM7D,SAEEC,gBAAgB,QACX,qCAAqC;AAC5C,SAASC,UAAU,QAAQ,mCAAmC;AAC9D,SAASC,cAAc,QAAQ,uCAAuC;AACtE,SAA8BC,KAAK,QAAQ,2BAA2B;AACtE,SAASC,UAAU,QAA6B,+BAA+B;AAC/E,SAASC,SAAS,QAAQ,0BAA0B;AACpD,SAASC,kBAAkB,EAAEC,SAAS,QAAQ,sBAAsB;AACpE,SAASC,kBAAkB,QAAQ,6CAA6C;AAChF,SAASC,cAAc,QAAQ,yCAAyC;AACxE,SAASC,yBAAyB,QAAQ,oDAAoD;AAC9F,SAASC,kBAAkB,QAAQ,6CAA6C;AAChF,SAAkDC,IAAI,QAAQ,WAAW;AAyBzE;;;;;;;AAOA,OAAO,eAAeC,UAAUA,CAC9BC,MAAgC,EAChCC,UAAgC;EAAA,IAAAC,aAAA;EAEhC,MAAM;MACJC,OAAO;MACPC,OAAO;MACPC,WAAW;MACXC,IAAI;MACJC,SAAS;MACTC,iCAAiC,IAAAN,aAAA,GAAGF,MAAM,CAACS,KAAK,cAAAP,aAAA,gBAAAA,aAAA,GAAZA,aAAA,CAAcQ,SAAS,cAAAR,aAAA,gBAAAA,aAAA,GAAvBA,aAAA,CAChCS,0BAA0B,cAAAT,aAAA,uBADMA,aAAA,CACJC;IACzB,CACR,GAAGF,UAAU;IADTW,IAAI,GAAAC,wBAAA,CACLZ,UAAU,EAAAa,SAAA;EAEd,MAAMC,YAAY,GAAG,CAAC,MAAK;IACzB,IAAI1B,KAAK,CAACkB,SAAS,CAAC,EAAE,OAAOA,SAAS;IACtC,IAAI,OAAOA,SAAS,KAAK,QAAQ,IAAI,GAAG,IAAIA,SAAS,IAAI,GAAG,IAAIA,SAAS,EACvE,OAAOV,kBAAkB,CAACU,SAAS,CAAC;IACtC,OAAOjB,UAAU,CAACiB,SAAS,CAAC;EAC9B,CAAC,EAAC,CAAE;EAEJ,MAAMS,gBAAgB,GAAG,MAAM,CAAC,YAAW;IACzC;IACA;IACA,IAAI,CAACZ,OAAO,IAAI,CAACC,WAAW,EAAE,OAAOU,YAAY;IAEjD;IACA,IAAIrB,kBAAkB,CAACqB,YAAY,CAAC,EAAE,OAAOA,YAAY;IAEzD;IACA;IACA,OAAOnB,yBAAyB,CAAC;MAC/BO,OAAO,EAAEC,OAAQ;MACjBa,IAAI,EAAEZ,WAAY;MAClBE,SAAS,EAAEQ;KACZ,CAAC;EACJ,CAAC,EAAC,CAAE;EAEJ,IAAI;IACF,MAAMG,IAAI,GAAGV,iCAAiC,GAAAW,aAAA;MAExCC,EAAE,EAAEZ,iCAAiC;MACrCS,IAAI,EAAEzB,kBAAkB,CAAC;QACvB6B,GAAG,EAAEtC,8BAA8B;QACnCuC,YAAY,EAAE,YAAY;QAC1BJ,IAAI,EAAE,CAACf,OAAO,EAAEG,IAAI,EAAEU,gBAAgB;OACvC;IAAC,GACCJ,IAAI,IAAAO,aAAA;MAGPF,IAAI,EAAE/B,gBAAgB,CAAC;QACrBmC,GAAG,EAAEtC,8BAA8B;QACnCmC,IAAI,EAAE,CAACf,OAAO,EAAEG,IAAI,EAAEU,gBAAgB,CAAC;QACvCO,QAAQ,EAAEvC;OACX;IAAC,GACC4B,IAAI,CACsB;IAEnC,MAAM;MAAEK;IAAI,CAAE,GAAG,MAAM1B,SAAS,CAACS,MAAM,EAAEF,IAAI,EAAE,MAAM,CAAC,CAACoB,IAAI,CAAC;IAE5D,OAAOzB,SAAS,CAACwB,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAI,KAAK,CAAC;EACjC,CAAC,CAAC,OAAOO,KAAK,EAAE;IACd;IACA,IAAI;MACF,MAAMC,QAAQ,GAAGrC,cAAc,CAC7BD,UAAU,CAACgB,OAAO,CAAC,EACnB,MAAMR,cAAc,CAAC;QAAEW,IAAI;QAAEC;MAAS,CAAE,CAAC,CAC1C;MACD,IAAIkB,QAAQ,EAAE,OAAO,IAAI;IAC3B,CAAC,CAAC,OAAAC,OAAA,EAAM,CAAC;IAET,IAAIF,KAAK,YAAYvC,kBAAkB,EAAE;MACvC;MACA;MACA;MACA,OAAO,KAAK;IACd;IAEA,MAAMuC,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}