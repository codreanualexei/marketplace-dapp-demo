{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as Errors from './Errors.js';\nimport { getUrl } from './internal/errors.js';\nimport * as promise from './internal/promise.js';\nimport * as internal from './internal/rpcTransport.js';\n/**\n * Creates a HTTP JSON-RPC Transport from a URL.\n *\n * @example\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @param url - URL to perform the JSON-RPC requests to.\n * @param options - Transport options.\n * @returns HTTP JSON-RPC Transport.\n */\nexport function fromHttp(url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return internal.create({\n    async request(body_, options_) {\n      var _options$fetchFn, _options$timeout, _JSON$stringify;\n      const {\n        fetchFn = (_options$fetchFn = options.fetchFn) !== null && _options$fetchFn !== void 0 ? _options$fetchFn : fetch,\n        fetchOptions: fetchOptions_ = options.fetchOptions,\n        timeout = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : 10000\n      } = options_;\n      const body = JSON.stringify(body_);\n      const fetchOptions = typeof fetchOptions_ === 'function' ? await fetchOptions_(body_) : fetchOptions_;\n      const response = await promise.withTimeout(_ref => {\n        var _fetchOptions$method, _fetchOptions$signal;\n        let {\n          signal\n        } = _ref;\n        const init = _objectSpread(_objectSpread({}, fetchOptions), {}, {\n          body,\n          headers: _objectSpread({\n            'Content-Type': 'application/json'\n          }, fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.headers),\n          method: (_fetchOptions$method = fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.method) !== null && _fetchOptions$method !== void 0 ? _fetchOptions$method : 'POST',\n          signal: (_fetchOptions$signal = fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.signal) !== null && _fetchOptions$signal !== void 0 ? _fetchOptions$signal : timeout > 0 ? signal : null\n        });\n        const request = new Request(url, init);\n        return fetchFn(request);\n      }, {\n        timeout,\n        signal: true\n      });\n      const data = await (async _response$headers$get => {\n        if ((_response$headers$get = response.headers.get('Content-Type')) !== null && _response$headers$get !== void 0 && _response$headers$get.startsWith('application/json')) return response.json();\n        return response.text().then(data => {\n          try {\n            return JSON.parse(data || '{}');\n          } catch (_err) {\n            if (response.ok) throw new MalformedResponseError({\n              response: data\n            });\n            return {\n              error: data\n            };\n          }\n        });\n      })();\n      if (!response.ok) throw new HttpError({\n        body,\n        details: (_JSON$stringify = JSON.stringify(data.error)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : response.statusText,\n        response,\n        url\n      });\n      return data;\n    }\n  }, {\n    raw: options.raw\n  });\n}\n/** Thrown when a HTTP request fails. */\nexport class HttpError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      body,\n      details,\n      response,\n      url\n    } = _ref2;\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\"Status: \".concat(response.status), \"URL: \".concat(getUrl(url)), body ? \"Body: \".concat(JSON.stringify(body)) : undefined]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'RpcTransport.HttpError'\n    });\n  }\n}\n/** Thrown when a HTTP response is malformed. */\nexport class MalformedResponseError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      response\n    } = _ref3;\n    super('HTTP Response could not be parsed as JSON.', {\n      metaMessages: [\"Response: \".concat(response)]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'RpcTransport.MalformedResponseError'\n    });\n  }\n}","map":{"version":3,"names":["Errors","getUrl","promise","internal","fromHttp","url","options","arguments","length","undefined","create","request","body_","options_","_options$fetchFn","_options$timeout","_JSON$stringify","fetchFn","fetch","fetchOptions","fetchOptions_","timeout","body","JSON","stringify","response","withTimeout","_ref","_fetchOptions$method","_fetchOptions$signal","signal","init","_objectSpread","headers","method","Request","data","_response$headers$get","get","startsWith","json","text","then","parse","_err","ok","MalformedResponseError","error","HttpError","details","statusText","raw","BaseError","constructor","_ref2","metaMessages","concat","status","Object","defineProperty","_ref3"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/RpcTransport.ts"],"sourcesContent":["import * as Errors from './Errors.js'\nimport { getUrl } from './internal/errors.js'\nimport * as promise from './internal/promise.js'\nimport type * as RpcSchema_internal from './internal/rpcSchema.js'\nimport * as internal from './internal/rpcTransport.js'\nimport type { Compute } from './internal/types.js'\nimport type * as RpcResponse from './RpcResponse.js'\nimport type * as RpcSchema from './RpcSchema.js'\n\n/** Root type for an RPC Transport. */\nexport type RpcTransport<\n  raw extends boolean = false,\n  options extends Record<string, unknown> = {},\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = Compute<{\n  request: RequestFn<raw, options, schema>\n}>\n\n/** HTTP-based RPC Transport. */\nexport type Http<\n  raw extends boolean = false,\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = RpcTransport<raw, HttpOptions, schema>\n\nexport type HttpOptions = {\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?:\n    | Omit<RequestInit, 'body'>\n    | ((\n        method: RpcSchema.Generic['Request'],\n      ) => Omit<RequestInit, 'body'> | Promise<Omit<RequestInit, 'body'>>)\n    | undefined\n  /** Function to use to make the request. @default fetch */\n  fetchFn?: typeof fetch | undefined\n  /** Timeout for the request in milliseconds. @default 10_000 */\n  timeout?: number | undefined\n}\n\nexport type RequestFn<\n  raw extends boolean = false,\n  options extends Record<string, unknown> = {},\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n> = <\n  methodName extends RpcSchema.MethodNameGeneric,\n  raw_override extends boolean | undefined = undefined,\n>(\n  parameters: Compute<\n    RpcSchema_internal.ExtractRequestOpaque<schema, methodName>\n  >,\n  options?: internal.Options<raw_override, options, schema> | undefined,\n) => Promise<\n  raw_override extends boolean\n    ? raw_override extends true\n      ? RpcResponse.RpcResponse<RpcSchema.ExtractReturnType<schema, methodName>>\n      : RpcSchema.ExtractReturnType<schema, methodName>\n    : raw extends true\n      ? RpcResponse.RpcResponse<RpcSchema.ExtractReturnType<schema, methodName>>\n      : RpcSchema.ExtractReturnType<schema, methodName>\n>\n\n/**\n * Creates a HTTP JSON-RPC Transport from a URL.\n *\n * @example\n * ```ts twoslash\n * import { RpcTransport } from 'ox'\n *\n * const transport = RpcTransport.fromHttp('https://1.rpc.thirdweb.com')\n *\n * const blockNumber = await transport.request({ method: 'eth_blockNumber' })\n * // @log: '0x1a2b3c'\n * ```\n *\n * @param url - URL to perform the JSON-RPC requests to.\n * @param options - Transport options.\n * @returns HTTP JSON-RPC Transport.\n */\nexport function fromHttp<\n  raw extends boolean = false,\n  schema extends RpcSchema.Generic = RpcSchema.Default,\n>(url: string, options: fromHttp.Options<raw, schema> = {}): Http<raw, schema> {\n  return internal.create<HttpOptions, schema, raw>(\n    {\n      async request(body_, options_) {\n        const {\n          fetchFn = options.fetchFn ?? fetch,\n          fetchOptions: fetchOptions_ = options.fetchOptions,\n          timeout = options.timeout ?? 10_000,\n        } = options_\n\n        const body = JSON.stringify(body_)\n\n        const fetchOptions =\n          typeof fetchOptions_ === 'function'\n            ? await fetchOptions_(body_)\n            : fetchOptions_\n\n        const response = await promise.withTimeout(\n          ({ signal }) => {\n            const init: RequestInit = {\n              ...fetchOptions,\n              body,\n              headers: {\n                'Content-Type': 'application/json',\n                ...fetchOptions?.headers,\n              },\n              method: fetchOptions?.method ?? 'POST',\n              signal: fetchOptions?.signal ?? (timeout > 0 ? signal : null),\n            }\n            const request = new Request(url, init)\n            return fetchFn(request)\n          },\n          {\n            timeout,\n            signal: true,\n          },\n        )\n\n        const data = await (async () => {\n          if (\n            response.headers.get('Content-Type')?.startsWith('application/json')\n          )\n            return response.json()\n          return response.text().then((data) => {\n            try {\n              return JSON.parse(data || '{}')\n            } catch (_err) {\n              if (response.ok)\n                throw new MalformedResponseError({\n                  response: data,\n                })\n              return { error: data }\n            }\n          })\n        })()\n\n        if (!response.ok)\n          throw new HttpError({\n            body,\n            details: JSON.stringify(data.error) ?? response.statusText,\n            response,\n            url,\n          })\n\n        return data as never\n      },\n    },\n    { raw: options.raw },\n  )\n}\n\nexport declare namespace fromHttp {\n  type Options<\n    raw extends boolean = false,\n    schema extends RpcSchema.Generic = RpcSchema.Default,\n  > = internal.Options<raw, HttpOptions, schema>\n\n  type ErrorType =\n    | promise.withTimeout.ErrorType\n    | HttpError\n    | Errors.GlobalErrorType\n}\n\n/** Thrown when a HTTP request fails. */\nexport class HttpError extends Errors.BaseError {\n  override readonly name = 'RpcTransport.HttpError'\n\n  constructor({\n    body,\n    details,\n    response,\n    url,\n  }: { body: unknown; details: string; response: Response; url: string }) {\n    super('HTTP request failed.', {\n      details,\n      metaMessages: [\n        `Status: ${response.status}`,\n        `URL: ${getUrl(url)}`,\n        body ? `Body: ${JSON.stringify(body)}` : undefined,\n      ],\n    })\n  }\n}\n\n/** Thrown when a HTTP response is malformed. */\nexport class MalformedResponseError extends Errors.BaseError {\n  override readonly name = 'RpcTransport.MalformedResponseError'\n\n  constructor({ response }: { response: string }) {\n    super('HTTP Response could not be parsed as JSON.', {\n      metaMessages: [`Response: ${response}`],\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}