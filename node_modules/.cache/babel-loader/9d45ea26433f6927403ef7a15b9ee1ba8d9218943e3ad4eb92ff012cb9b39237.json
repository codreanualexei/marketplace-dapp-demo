{"ast":null,"code":"/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\n// prettier-ignore\nimport { abytes, aexists, aoutput, clean, copyBytes, createView, Hash, toBytes, u32 } from \"./utils.js\";\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: s2 << 31 | s3 >>> 1,\n    s2: s1 << 31 | s2 >>> 1,\n    s1: s0 << 31 | s1 >>> 1,\n    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1) // reduce % poly\n  };\n};\nconst swapLE = n => (n >>> 0 & 0xff) << 24 | (n >>> 8 & 0xff) << 16 | (n >>> 16 & 0xff) << 8 | n >>> 24 & 0xff | 0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k) {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = t >>> 1 | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\nconst estimateWindow = bytes => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\nclass GHASH {\n  // We select bits per window adaptively based on expectedLength\n  constructor(key, expectedLength) {\n    this.blockLen = BLOCK_SIZE;\n    this.outputLen = BLOCK_SIZE;\n    this.s0 = 0;\n    this.s1 = 0;\n    this.s2 = 0;\n    this.s3 = 0;\n    this.finished = false;\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({\n        s0: swapLE(k0),\n        s1: swapLE(k1),\n        s2: swapLE(k2),\n        s3: swapLE(k3)\n      });\n      ({\n        s0: k0,\n        s1: k1,\n        s2: k2,\n        s3: k3\n      } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W)) throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = this.windowSize = 2 ** W;\n    const items = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0,\n          s1 = 0,\n          s2 = 0,\n          s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = byte >>> W - j - 1 & 1;\n          if (!bit) continue;\n          const {\n            s0: d0,\n            s1: d1,\n            s2: d2,\n            s3: d3\n          } = doubles[W * w + j];\n          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;\n        }\n        items.push({\n          s0,\n          s1,\n          s2,\n          s3\n        });\n      }\n    }\n    this.t = items;\n  }\n  _updateBlock(s0, s1, s2, s3) {\n    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;\n    const {\n      W,\n      t,\n      windowSize\n    } = this;\n    // prettier-ignore\n    let o0 = 0,\n      o1 = 0,\n      o2 = 0,\n      o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = num >>> 8 * bytePos & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = byte >>> W * bitPos & mask;\n          const {\n            s0: e0,\n            s1: e1,\n            s2: e2,\n            s3: e3\n          } = t[w * windowSize + bit];\n          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data) {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      clean(ZEROS32); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const {\n      t\n    } = this;\n    // clean precompute table\n    for (const elm of t) {\n      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;\n    }\n  }\n  digestInto(out) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const {\n      s0,\n      s1,\n      s2,\n      s3\n    } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest() {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\nclass Polyval extends GHASH {\n  constructor(key, expectedLength) {\n    key = toBytes(key);\n    abytes(key);\n    const ghKey = _toGHASHKey(copyBytes(key));\n    super(ghKey, expectedLength);\n    clean(ghKey);\n  }\n  update(data) {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n      clean(ZEROS32);\n    }\n    return this;\n  }\n  digestInto(out) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const {\n      s0,\n      s1,\n      s2,\n      s3\n    } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\nfunction wrapConstructorWithKey(hashCons) {\n  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n  return hashC;\n}\n/** GHash MAC for AES-GCM. */\nexport const ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\n/** Polyval MAC for AES-SIV. */\nexport const polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));","map":{"version":3,"names":["abytes","aexists","aoutput","clean","copyBytes","createView","Hash","toBytes","u32","BLOCK_SIZE","ZEROS16","Uint8Array","ZEROS32","POLY","mul2","s0","s1","s2","s3","hiBit","swapLE","n","_toGHASHKey","k","reverse","carry","i","length","t","estimateWindow","bytes","GHASH","constructor","key","expectedLength","blockLen","outputLen","finished","kView","k0","getUint32","k1","k2","k3","doubles","push","W","includes","Error","bits","windows","windowSize","items","w","byte","j","bit","d0","d1","d2","d3","_updateBlock","o0","o1","o2","o3","mask","num","bytePos","bitPos","e0","e1","e2","e3","update","data","b32","blocks","Math","floor","left","set","subarray","destroy","elm","digestInto","out","o32","digest","res","Polyval","ghKey","wrapConstructorWithKey","hashCons","hashC","msg","tmp","create","ghash","polyval"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@noble/ciphers/src/_polyval.ts"],"sourcesContent":["/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput,\n  clean, copyBytes, createView, Hash, type Input, toBytes, u32,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0: number, s1: number, s2: number, s3: number) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: (s2 << 31) | (s3 >>> 1),\n    s2: (s1 << 31) | (s2 >>> 1),\n    s1: (s0 << 31) | (s1 >>> 1),\n    s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n  };\n};\n\nconst swapLE = (n: number) =>\n  (((n >>> 0) & 0xff) << 24) |\n  (((n >>> 8) & 0xff) << 16) |\n  (((n >>> 16) & 0xff) << 8) |\n  ((n >>> 24) & 0xff) |\n  0;\n\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k: Uint8Array): Uint8Array {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = (t >>> 1) | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\n\ntype Value = { s0: number; s1: number; s2: number; s3: number };\n\nconst estimateWindow = (bytes: number) => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\n\nclass GHASH implements Hash<GHASH> {\n  readonly blockLen = BLOCK_SIZE;\n  readonly outputLen = BLOCK_SIZE;\n  protected s0 = 0;\n  protected s1 = 0;\n  protected s2 = 0;\n  protected s3 = 0;\n  protected finished = false;\n  protected t: Value[];\n  private W: number;\n  private windowSize: number;\n  // We select bits per window adaptively based on expectedLength\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles: Value[] = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W))\n      throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = (this.windowSize = 2 ** W);\n    const items: Value[] = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = (byte >>> (W - j - 1)) & 1;\n          if (!bit) continue;\n          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n          (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n        }\n        items.push({ s0, s1, s2, s3 });\n      }\n    }\n    this.t = items;\n  }\n  protected _updateBlock(s0: number, s1: number, s2: number, s3: number) {\n    (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n    const { W, t, windowSize } = this;\n    // prettier-ignore\n    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = (num >>> (8 * bytePos)) & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = (byte >>> (W * bitPos)) & mask;\n          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n          (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      clean(ZEROS32); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const { t } = this;\n    // clean precompute table\n    for (const elm of t) {\n      (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n    }\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest(): Uint8Array {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\n\nclass Polyval extends GHASH {\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key);\n    const ghKey = _toGHASHKey(copyBytes(key));\n    super(ghKey, expectedLength);\n    clean(ghKey);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(\n        swapLE(b32[i * 4 + 3]),\n        swapLE(b32[i * 4 + 2]),\n        swapLE(b32[i * 4 + 1]),\n        swapLE(b32[i * 4 + 0])\n      );\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(\n        swapLE(ZEROS32[3]),\n        swapLE(ZEROS32[2]),\n        swapLE(ZEROS32[1]),\n        swapLE(ZEROS32[0])\n      );\n      clean(ZEROS32);\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\n\nexport type CHashPV = ReturnType<typeof wrapConstructorWithKey>;\nfunction wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input, expectedLength?: number) => Hash<H>\n): {\n  (msg: Input, key: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Input, expectedLength?: number): Hash<H>;\n} {\n  const hashC = (msg: Input, key: Input): Uint8Array =>\n    hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input, expectedLength?: number) => hashCons(key, expectedLength);\n  return hashC;\n}\n\n/** GHash MAC for AES-GCM. */\nexport const ghash: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new GHASH(key, expectedLength)\n);\n\n/** Polyval MAC for AES-SIV. */\nexport const polyval: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new Polyval(key, expectedLength)\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}