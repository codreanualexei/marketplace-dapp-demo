{"ast":null,"code":"import { p256 } from '@noble/curves/p256';\nimport * as Bytes from './Bytes.js';\nimport * as Hex from './Hex.js';\nimport * as PublicKey from './PublicKey.js';\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(options = {}) {\n  const {\n    extractable = false\n  } = options;\n  const keypair = await globalThis.crypto.subtle.generateKey({\n    name: 'ECDSA',\n    namedCurve: 'P-256'\n  }, extractable, ['sign', 'verify']);\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey('raw', keypair.publicKey);\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw));\n  return {\n    privateKey: keypair.privateKey,\n    publicKey\n  };\n}\n/**\n * Generates an ECDH P256 key pair for key agreement that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * - a `publicKey` of type {@link ox#PublicKey.PublicKey}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPairECDH()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPairECDH(options = {}) {\n  const {\n    extractable = false\n  } = options;\n  const keypair = await globalThis.crypto.subtle.generateKey({\n    name: 'ECDH',\n    namedCurve: 'P-256'\n  }, extractable, ['deriveKey', 'deriveBits']);\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey('raw', keypair.publicKey);\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw));\n  return {\n    privateKey: keypair.privateKey,\n    publicKey\n  };\n}\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key using Web Crypto APIs.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = await WebCryptoP256.createKeyPairECDH()\n * const { publicKey: publicKeyB } = await WebCryptoP256.createKeyPairECDH()\n *\n * const sharedSecret = await WebCryptoP256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport async function getSharedSecret(options) {\n  const {\n    as = 'Hex',\n    privateKey,\n    publicKey\n  } = options;\n  if (privateKey.algorithm.name === 'ECDSA') {\n    throw new Error('privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.');\n  }\n  const publicKeyCrypto = await globalThis.crypto.subtle.importKey('raw', PublicKey.toBytes(publicKey), {\n    name: 'ECDH',\n    namedCurve: 'P-256'\n  }, false, []);\n  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits({\n    name: 'ECDH',\n    public: publicKeyCrypto\n  }, privateKey, 256);\n  const sharedSecret = new Uint8Array(sharedSecretBuffer);\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret);\n  return sharedSecret;\n}\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(options) {\n  const {\n    payload,\n    privateKey\n  } = options;\n  const signature = await globalThis.crypto.subtle.sign({\n    name: 'ECDSA',\n    hash: 'SHA-256'\n  }, privateKey, Bytes.from(payload));\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature));\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32));\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64));\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s;\n  return {\n    r,\n    s\n  };\n}\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options) {\n  const {\n    payload,\n    signature\n  } = options;\n  const publicKey = await globalThis.crypto.subtle.importKey('raw', PublicKey.toBytes(options.publicKey), {\n    name: 'ECDSA',\n    namedCurve: 'P-256'\n  }, true, ['verify']);\n  return await globalThis.crypto.subtle.verify({\n    name: 'ECDSA',\n    hash: 'SHA-256'\n  }, publicKey, Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)), Bytes.from(payload));\n}","map":{"version":3,"names":["p256","Bytes","Hex","PublicKey","createKeyPair","options","extractable","keypair","globalThis","crypto","subtle","generateKey","name","namedCurve","publicKey_raw","exportKey","publicKey","from","Uint8Array","privateKey","createKeyPairECDH","getSharedSecret","as","algorithm","Error","publicKeyCrypto","importKey","toBytes","sharedSecretBuffer","deriveBits","public","sharedSecret","fromBytes","sign","payload","signature","hash","signature_bytes","fromArray","r","toBigInt","slice","s","CURVE","n","verify","concat","fromNumber"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/WebCryptoP256.ts"],"sourcesContent":["import { p256 } from '@noble/curves/p256'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as PublicKey from './PublicKey.js'\nimport type * as Signature from './Signature.js'\n\n/**\n * Generates an ECDSA P256 key pair that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n *\n * - a `publicKey` of type {@link ox#Hex.Hex} or {@link ox#Bytes.Bytes}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPair()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPair(\n  options: createKeyPair.Options = {},\n): Promise<createKeyPair.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDSA',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['sign', 'verify'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPair {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Generates an ECDH P256 key pair for key agreement that includes:\n *\n * - a `privateKey` of type [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * - a `publicKey` of type {@link ox#PublicKey.PublicKey}\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { publicKey, privateKey } = await WebCryptoP256.createKeyPairECDH()\n * // @log: {\n * // @log:   privateKey: CryptoKey {},\n * // @log:   publicKey: {\n * // @log:     x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:     y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log:     prefix: 4,\n * // @log:   },\n * // @log: }\n * ```\n *\n * @param options - Options for creating the key pair.\n * @returns The key pair.\n */\nexport async function createKeyPairECDH(\n  options: createKeyPairECDH.Options = {},\n): Promise<createKeyPairECDH.ReturnType> {\n  const { extractable = false } = options\n  const keypair = await globalThis.crypto.subtle.generateKey(\n    {\n      name: 'ECDH',\n      namedCurve: 'P-256',\n    },\n    extractable,\n    ['deriveKey', 'deriveBits'],\n  )\n  const publicKey_raw = await globalThis.crypto.subtle.exportKey(\n    'raw',\n    keypair.publicKey,\n  )\n  const publicKey = PublicKey.from(new Uint8Array(publicKey_raw))\n  return {\n    privateKey: keypair.privateKey,\n    publicKey,\n  }\n}\n\nexport declare namespace createKeyPairECDH {\n  type Options = {\n    /** A boolean value indicating whether it will be possible to export the private key using `globalThis.crypto.subtle.exportKey()`. */\n    extractable?: boolean | undefined\n  }\n\n  type ReturnType = Compute<{\n    privateKey: CryptoKey\n    publicKey: PublicKey.PublicKey\n  }>\n\n  type ErrorType = PublicKey.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes a shared secret using ECDH (Elliptic Curve Diffie-Hellman) between a private key and a public key using Web Crypto APIs.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey: privateKeyA } = await WebCryptoP256.createKeyPairECDH()\n * const { publicKey: publicKeyB } = await WebCryptoP256.createKeyPairECDH()\n *\n * const sharedSecret = await WebCryptoP256.getSharedSecret({\n *   privateKey: privateKeyA,\n *   publicKey: publicKeyB\n * })\n * ```\n *\n * @param options - The options to compute the shared secret.\n * @returns The computed shared secret.\n */\nexport async function getSharedSecret<as extends 'Hex' | 'Bytes' = 'Hex'>(\n  options: getSharedSecret.Options<as>,\n): Promise<getSharedSecret.ReturnType<as>> {\n  const { as = 'Hex', privateKey, publicKey } = options\n\n  if (privateKey.algorithm.name === 'ECDSA') {\n    throw new Error(\n      'privateKey is not compatible with ECDH. please use `createKeyPairECDH` to create an ECDH key.',\n    )\n  }\n\n  const publicKeyCrypto = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(publicKey),\n    { name: 'ECDH', namedCurve: 'P-256' },\n    false,\n    [],\n  )\n\n  const sharedSecretBuffer = await globalThis.crypto.subtle.deriveBits(\n    {\n      name: 'ECDH',\n      public: publicKeyCrypto,\n    },\n    privateKey,\n    256, // 32 bytes * 8 bits/byte\n  )\n\n  const sharedSecret = new Uint8Array(sharedSecretBuffer)\n  if (as === 'Hex') return Hex.fromBytes(sharedSecret) as never\n  return sharedSecret as never\n}\n\nexport declare namespace getSharedSecret {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /**\n     * Format of the returned shared secret.\n     * @default 'Hex'\n     */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /**\n     * Private key to use for the shared secret computation (must be a CryptoKey for ECDH).\n     */\n    privateKey: CryptoKey\n    /**\n     * Public key to use for the shared secret computation.\n     */\n    publicKey: PublicKey.PublicKey<boolean>\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | PublicKey.toBytes.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Signs a payload with the provided `CryptoKey` private key and returns a P256 signature.\n *\n * @example\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey } = await WebCryptoP256.createKeyPair()\n *\n * const signature = await WebCryptoP256.sign({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   privateKey, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   r: 151231...4423n,\n * // @log:   s: 516123...5512n,\n * // @log: }\n * ```\n *\n * @param options - Options for signing the payload.\n * @returns The P256 ECDSA {@link ox#Signature.Signature}.\n */\nexport async function sign(\n  options: sign.Options,\n): Promise<Signature.Signature<false>> {\n  const { payload, privateKey } = options\n  const signature = await globalThis.crypto.subtle.sign(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    privateKey,\n    Bytes.from(payload),\n  )\n  const signature_bytes = Bytes.fromArray(new Uint8Array(signature))\n  const r = Bytes.toBigInt(Bytes.slice(signature_bytes, 0, 32))\n  let s = Bytes.toBigInt(Bytes.slice(signature_bytes, 32, 64))\n  if (s > p256.CURVE.n / 2n) s = p256.CURVE.n - s\n  return { r, s }\n}\n\nexport declare namespace sign {\n  type Options = {\n    /** Payload to sign. */\n    payload: Hex.Hex | Bytes.Bytes\n    /** ECDSA private key. */\n    privateKey: CryptoKey\n  }\n\n  type ErrorType = Bytes.fromArray.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Verifies a payload was signed by the provided public key.\n *\n * @example\n *\n * ```ts twoslash\n * import { WebCryptoP256 } from 'ox'\n *\n * const { privateKey, publicKey } = await WebCryptoP256.createKeyPair()\n * const signature = await WebCryptoP256.sign({ payload: '0xdeadbeef', privateKey })\n *\n * const verified = await WebCryptoP256.verify({ // [!code focus]\n *   payload: '0xdeadbeef', // [!code focus]\n *   publicKey, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: true\n * ```\n *\n * @param options - The verification options.\n * @returns Whether the payload was signed by the provided public key.\n */\nexport async function verify(options: verify.Options): Promise<boolean> {\n  const { payload, signature } = options\n\n  const publicKey = await globalThis.crypto.subtle.importKey(\n    'raw',\n    PublicKey.toBytes(options.publicKey),\n    { name: 'ECDSA', namedCurve: 'P-256' },\n    true,\n    ['verify'],\n  )\n\n  return await globalThis.crypto.subtle.verify(\n    {\n      name: 'ECDSA',\n      hash: 'SHA-256',\n    },\n    publicKey,\n    Bytes.concat(Bytes.fromNumber(signature.r), Bytes.fromNumber(signature.s)),\n    Bytes.from(payload),\n  )\n}\n\nexport declare namespace verify {\n  type Options = {\n    /** Public key that signed the payload. */\n    publicKey: PublicKey.PublicKey<boolean>\n    /** Signature of the payload. */\n    signature: Signature.Signature<false>\n    /** Payload that was signed. */\n    payload: Hex.Hex | Bytes.Bytes\n  }\n\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}