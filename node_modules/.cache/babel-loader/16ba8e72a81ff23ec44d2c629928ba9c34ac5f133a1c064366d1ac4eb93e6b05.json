{"ast":null,"code":"var _jsxFileName = \"/Users/alex.codreanu/Desktop/marketplace-dapp/src/contexts/WalletContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { EthereumProvider } from '@walletconnect/ethereum-provider';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WalletContext = /*#__PURE__*/createContext(undefined);\nexport const useWallet = () => {\n  _s();\n  const context = useContext(WalletContext);\n  if (!context) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n_s(useWallet, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const WalletProvider = ({\n  children\n}) => {\n  _s2();\n  const [account, setAccount] = useState(null);\n  const [balance, setBalance] = useState(null);\n  const [chainId, setChainId] = useState(null);\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [error, setError] = useState(null);\n  const [walletType, setWalletType] = useState(null);\n  const [walletConnectProvider, setWalletConnectProvider] = useState(null);\n  const [isNetworkSwitching, setIsNetworkSwitching] = useState(false);\n  const [isConnecting, setIsConnecting] = useState(false);\n  // Store WalletConnect provider globally to prevent multiple initializations\n  const [wcProviderInstance, setWcProviderInstance] = useState(null);\n\n  // Comprehensive WalletConnect cleanup function\n  const cleanupWalletConnect = async () => {\n    console.log('Starting comprehensive WalletConnect cleanup...');\n    try {\n      // Disconnect existing provider if it exists\n      if (wcProviderInstance) {\n        console.log('Disconnecting existing WalletConnect provider...');\n        try {\n          await wcProviderInstance.disconnect();\n        } catch (disconnectError) {\n          console.log('Error during disconnect (this is usually fine):', disconnectError);\n        }\n      }\n\n      // Clear all WalletConnect related state\n      setWcProviderInstance(null);\n      setWalletConnectProvider(null);\n\n      // Clear WalletConnect from localStorage\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && (key.startsWith('walletconnect') || key.startsWith('wc@'))) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach(key => {\n        console.log('Removing WalletConnect localStorage key:', key);\n        localStorage.removeItem(key);\n      });\n\n      // Clear WalletConnect from sessionStorage as well\n      const sessionKeysToRemove = [];\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && (key.startsWith('walletconnect') || key.startsWith('wc@'))) {\n          sessionKeysToRemove.push(key);\n        }\n      }\n      sessionKeysToRemove.forEach(key => {\n        console.log('Removing WalletConnect sessionStorage key:', key);\n        sessionStorage.removeItem(key);\n      });\n\n      // Reset initialization state\n      isWalletConnectInitializing = false;\n\n      // Force garbage collection of WalletConnect Core by clearing global references\n      // This is a workaround since WalletConnect doesn't provide a proper cleanup method\n      if (typeof window !== 'undefined') {\n        // Clear any global WalletConnect references\n        const globalKeys = Object.keys(window);\n        globalKeys.forEach(key => {\n          if (key.includes('walletconnect') || key.includes('wc')) {\n            try {\n              delete window[key];\n            } catch (e) {\n              // Ignore errors when trying to delete global properties\n            }\n          }\n        });\n      }\n\n      // Add a delay to ensure cleanup completes before next connection\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      console.log('WalletConnect cleanup completed');\n    } catch (error) {\n      console.error('Error during WalletConnect cleanup:', error);\n      // Even if cleanup fails, we should clear the state\n      setWcProviderInstance(null);\n      setWalletConnectProvider(null);\n      isWalletConnectInitializing = false;\n    }\n  };\n  const updateBalance = async (address, provider) => {\n    // Skip balance update if we're in the middle of a network switch\n    if (isNetworkSwitching) {\n      console.log('Skipping balance update during network switch');\n      return;\n    }\n    try {\n      const balanceWei = await provider.getBalance(address);\n      const balanceEth = ethers.formatEther(balanceWei);\n      setBalance(parseFloat(balanceEth).toFixed(4));\n    } catch (err) {\n      var _err$message;\n      console.error('Error fetching balance:', err);\n      // Check if it's a network change error and handle gracefully\n      if ((_err$message = err.message) !== null && _err$message !== void 0 && _err$message.includes('network changed')) {\n        console.log('Network change detected during balance update, skipping...');\n        return;\n      }\n      // Don't set balance to null on error, keep previous value\n    }\n  };\n  const connectWallet = async (walletType = 'metamask') => {\n    setIsConnecting(true);\n    setError(null);\n    try {\n      // Always clean up WalletConnect before connecting any wallet\n      await cleanupWalletConnect();\n      if (walletType === 'metamask') {\n        await connectMetaMask();\n      } else if (walletType === 'walletconnect') {\n        // For WalletConnect, force a page reload to ensure completely clean state\n        // This is necessary because WalletConnect Core maintains global state that can't be easily reset\n        console.log('Connecting to WalletConnect - forcing page reload for clean state');\n        localStorage.setItem('pendingWalletConnect', 'true');\n        window.location.reload();\n        return;\n      }\n    } catch (err) {\n      console.error('Error connecting wallet:', err);\n      setError(err.message || 'Failed to connect wallet');\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n  const connectMetaMask = async () => {\n    // Prevent multiple simultaneous connection attempts\n    if (isConnecting) {\n      console.log('Wallet connection already in progress, skipping...');\n      return;\n    }\n    try {\n      setIsConnecting(true);\n      if (typeof window.ethereum === 'undefined') {\n        throw new Error('Please install MetaMask to use this dApp');\n      }\n\n      // Check if MetaMask is locked\n      try {\n        const accounts = await window.ethereum.request({\n          method: 'eth_accounts'\n        });\n        if (accounts.length === 0) {\n          // MetaMask is locked or no accounts connected\n          console.log('MetaMask is locked or no accounts connected, requesting access...');\n        }\n      } catch (error) {\n        console.log('MetaMask is locked, requesting access...');\n      }\n      const browserProvider = new ethers.BrowserProvider(window.ethereum);\n      const accounts = await browserProvider.send('eth_requestAccounts', []);\n      if (accounts.length === 0) {\n        throw new Error('No accounts found. Please unlock MetaMask and try again.');\n      }\n      const userSigner = await browserProvider.getSigner();\n      const network = await browserProvider.getNetwork();\n      setProvider(browserProvider);\n      setSigner(userSigner);\n      setAccount(accounts[0]);\n      setChainId(Number(network.chainId));\n      setWalletType('metamask');\n      await updateBalance(accounts[0], browserProvider);\n\n      // Store preferred wallet type\n      localStorage.setItem('preferredWallet', 'metamask');\n      localStorage.removeItem('walletDisconnected');\n      console.log('MetaMask connected successfully:', {\n        account: accounts[0],\n        chainId: Number(network.chainId)\n      });\n    } catch (error) {\n      var _error$message, _error$message2;\n      console.error('MetaMask connection error:', error);\n      if (error.code === 4001) {\n        throw new Error('MetaMask connection was rejected by user');\n      } else if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('User rejected')) {\n        throw new Error('MetaMask connection was rejected by user');\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('locked')) {\n        throw new Error('MetaMask is locked. Please unlock MetaMask and try again.');\n      } else {\n        throw new Error(`MetaMask connection failed: ${error.message || 'Unknown error'}`);\n      }\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n  const connectWalletConnect = async () => {\n    // Prevent multiple simultaneous connection attempts\n    if (isConnecting) {\n      throw new Error('Connection already in progress. Please wait for the current connection to complete.');\n    }\n\n    // Prevent rapid successive connection attempts (minimum 2 seconds between attempts)\n    const now = Date.now();\n    if (now - lastConnectionAttempt < 2000) {\n      throw new Error('Please wait a moment before trying to connect again.');\n    }\n    setLastConnectionAttempt(now);\n    try {\n      setIsConnecting(true);\n      console.log('Starting WalletConnect connection...');\n\n      // Create WalletConnect provider\n      const projectId = process.env.REACT_APP_WALLETCONNECT_PROJECT_ID;\n      if (!projectId) {\n        throw new Error('WalletConnect Project ID not configured. Please set REACT_APP_WALLETCONNECT_PROJECT_ID in your environment variables.');\n      }\n\n      // Always create a fresh WalletConnect provider instance\n      console.log('Creating fresh WalletConnect provider instance...');\n      let wcProvider;\n      try {\n        wcProvider = await EthereumProvider.init({\n          projectId: projectId,\n          chains: [1, 137, 56, 43114, 80002],\n          // Ethereum, Polygon, BSC, Avalanche, Polygon Amoy\n          showQrModal: true,\n          metadata: {\n            name: 'STR Domains Marketplace',\n            description: 'Decentralized marketplace for STR domains',\n            url: window.location.origin,\n            icons: [`${window.location.origin}/logo192.png`]\n          },\n          relayUrl: 'wss://relay.walletconnect.com',\n          qrModalOptions: {\n            themeMode: 'light',\n            themeVariables: {\n              '--wcm-z-index': '1000'\n            }\n          },\n          disableProviderPing: true,\n          optionalChains: [80002],\n          events: ['session_request', 'session_update', 'session_delete'],\n          methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData']\n        });\n        setWcProviderInstance(wcProvider);\n        console.log('Fresh WalletConnect provider created successfully');\n      } catch (initError) {\n        var _initError$message;\n        console.error('Error creating fresh WalletConnect provider:', initError);\n        // If we get \"already initialized\" error, this is expected and we should continue\n        if ((_initError$message = initError.message) !== null && _initError$message !== void 0 && _initError$message.includes('already initialized')) {\n          console.log('WalletConnect already initialized - this is expected after cleanup, continuing...');\n          // The global Core is already initialized, we can continue\n          // We'll create a new provider instance using the existing Core\n          wcProvider = await EthereumProvider.init({\n            projectId: projectId,\n            chains: [1, 137, 56, 43114, 80002],\n            showQrModal: true,\n            metadata: {\n              name: 'STR Domains Marketplace',\n              description: 'Decentralized marketplace for STR domains',\n              url: window.location.origin,\n              icons: [`${window.location.origin}/logo192.png`]\n            },\n            relayUrl: 'wss://relay.walletconnect.com',\n            qrModalOptions: {\n              themeMode: 'light',\n              themeVariables: {\n                '--wcm-z-index': '1000'\n              }\n            },\n            disableProviderPing: true,\n            optionalChains: [80002],\n            events: ['session_request', 'session_update', 'session_delete'],\n            methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData']\n          });\n          setWcProviderInstance(wcProvider);\n          console.log('WalletConnect provider created using existing Core');\n        } else {\n          throw initError;\n        }\n      }\n      console.log('WalletConnect provider initialized, enabling session...');\n      // Enable session (triggers QR Code modal) with comprehensive error handling\n      try {\n        await wcProvider.enable();\n      } catch (enableError) {\n        console.error('Error enabling WalletConnect session:', enableError);\n        // If session enable fails, try to clean up and throw the error\n        setWcProviderInstance(null);\n        throw enableError;\n      }\n      console.log('WalletConnect session enabled, setting up ethers provider...');\n      // Create ethers provider from WalletConnect provider\n      const browserProvider = new ethers.BrowserProvider(wcProvider);\n      const accounts = await browserProvider.listAccounts();\n      if (accounts.length === 0) {\n        throw new Error('No accounts found');\n      }\n      const userSigner = await browserProvider.getSigner();\n      const network = await browserProvider.getNetwork();\n      console.log('WalletConnect connected:', {\n        account: accounts[0].address,\n        chainId: Number(network.chainId)\n      });\n      setProvider(browserProvider);\n      setSigner(userSigner);\n      setAccount(accounts[0].address);\n      setChainId(Number(network.chainId));\n      setWalletType('walletconnect');\n      setWalletConnectProvider(wcProvider);\n      await updateBalance(accounts[0].address, browserProvider);\n\n      // Store preferred wallet type\n      localStorage.setItem('preferredWallet', 'walletconnect');\n      localStorage.removeItem('walletDisconnected');\n      console.log('WalletConnect connection completed successfully');\n    } catch (error) {\n      var _error$message3, _error$message4, _error$message5, _error$message6, _error$message7, _error$message8, _error$message9;\n      console.error('WalletConnect connection error:', error);\n      if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('User rejected')) {\n        throw new Error('Connection cancelled by user');\n      } else if ((_error$message4 = error.message) !== null && _error$message4 !== void 0 && _error$message4.includes('Connection request reset') || (_error$message5 = error.message) !== null && _error$message5 !== void 0 && _error$message5.includes('Please try again') || (_error$message6 = error.message) !== null && _error$message6 !== void 0 && _error$message6.includes('connection was reset') || (_error$message7 = error.message) !== null && _error$message7 !== void 0 && _error$message7.includes('request was reset')) {\n        throw new Error('Connection request was reset. Please try connecting again.');\n      } else if ((_error$message8 = error.message) !== null && _error$message8 !== void 0 && _error$message8.includes('No matching key. session topic doesn\\'t exist')) {\n        throw new Error('WalletConnect session expired. Please try connecting again.');\n      } else if ((_error$message9 = error.message) !== null && _error$message9 !== void 0 && _error$message9.includes('already initialized')) {\n        throw new Error('WalletConnect is already initializing. Please wait and try again.');\n      }\n      throw error;\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n  const switchNetwork = async targetChainId => {\n    console.log('switchNetwork called:', {\n      targetChainId,\n      walletType,\n      account\n    });\n    if (!walletType) {\n      throw new Error('No wallet connected');\n    }\n\n    // Set network switching flag to prevent balance updates during transition\n    setIsNetworkSwitching(true);\n    try {\n      if (walletType === 'metamask') {\n        console.log('Switching MetaMask network to:', targetChainId);\n        await switchMetaMaskNetwork(targetChainId);\n      } else if (walletType === 'walletconnect') {\n        console.log('Switching WalletConnect network to:', targetChainId);\n        await switchWalletConnectNetwork(targetChainId);\n      } else {\n        throw new Error(`Unsupported wallet type: ${walletType}`);\n      }\n      console.log('Network switch completed successfully');\n    } finally {\n      // Clear network switching flag after a delay to allow provider to stabilize\n      setTimeout(() => {\n        setIsNetworkSwitching(false);\n        // Update balance after network switch is complete\n        if (account && provider) {\n          updateBalance(account, provider);\n        }\n      }, 2000);\n    }\n  };\n  const switchMetaMaskNetwork = async targetChainId => {\n    if (typeof window.ethereum === 'undefined') {\n      throw new Error('MetaMask not detected');\n    }\n    const chainIdHex = `0x${targetChainId.toString(16)}`;\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n    } catch (switchError) {\n      // Chain not added to MetaMask, try to add it\n      if (switchError.code === 4902) {\n        await addMetaMaskNetwork(targetChainId);\n      } else {\n        throw switchError;\n      }\n    }\n  };\n  const addMetaMaskNetwork = async chainId => {\n    if (typeof window.ethereum === 'undefined') {\n      throw new Error('MetaMask not detected');\n    }\n    const chainIdHex = `0x${chainId.toString(16)}`;\n    const networkConfig = getNetworkConfig(chainId);\n    await window.ethereum.request({\n      method: 'wallet_addEthereumChain',\n      params: [networkConfig]\n    });\n  };\n  const switchWalletConnectNetwork = async targetChainId => {\n    if (!walletConnectProvider) {\n      throw new Error('WalletConnect not connected');\n    }\n    const chainIdHex = `0x${targetChainId.toString(16)}`;\n    try {\n      // Try wallet_switchEthereumChain first\n      await walletConnectProvider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n\n      // Wait a moment for the network change to propagate\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Update the chainId state after successful switch\n      setChainId(targetChainId);\n    } catch (switchError) {\n      console.log('wallet_switchEthereumChain failed:', switchError);\n\n      // If chain doesn't exist, try to add it\n      if (switchError.code === 4902) {\n        try {\n          const networkConfig = getNetworkConfig(targetChainId);\n          await walletConnectProvider.request({\n            method: 'wallet_addEthereumChain',\n            params: [networkConfig]\n          });\n\n          // Wait for network to be added and switched\n          await new Promise(resolve => setTimeout(resolve, 1000));\n\n          // Update the chainId state after successful add and switch\n          setChainId(targetChainId);\n        } catch (addError) {\n          console.log('wallet_addEthereumChain failed:', addError);\n          throw new Error(`Network switching not supported by your wallet. Please manually switch to Polygon Amoy (Chain ID: ${targetChainId}) in your wallet app.`);\n        }\n      } else {\n        var _switchError$message, _switchError$message2, _switchError$message3;\n        // Other errors - provide helpful message\n        console.log('Network switch error:', switchError);\n        if ((_switchError$message = switchError.message) !== null && _switchError$message !== void 0 && _switchError$message.includes('User rejected') || switchError.code === 4001) {\n          throw new Error('Network switch was cancelled by user.');\n        } else if ((_switchError$message2 = switchError.message) !== null && _switchError$message2 !== void 0 && _switchError$message2.includes('not supported') || (_switchError$message3 = switchError.message) !== null && _switchError$message3 !== void 0 && _switchError$message3.includes('unsupported')) {\n          throw new Error(`Your wallet doesn't support automatic network switching. Please manually switch to Polygon Amoy (Chain ID: ${targetChainId}) in your wallet app.`);\n        } else {\n          throw new Error(`Failed to switch network: ${switchError.message || 'Unknown error'}. Please manually switch to Polygon Amoy (Chain ID: ${targetChainId}) in your wallet app.`);\n        }\n      }\n    }\n  };\n  const getNetworkConfig = chainId => {\n    const chainIdHex = `0x${chainId.toString(16)}`;\n    switch (chainId) {\n      case 80002:\n        // Polygon Amoy\n        return {\n          chainId: chainIdHex,\n          chainName: 'Polygon Amoy Testnet',\n          nativeCurrency: {\n            name: 'MATIC',\n            symbol: 'MATIC',\n            decimals: 18\n          },\n          rpcUrls: ['https://rpc-amoy.polygon.technology'],\n          blockExplorerUrls: ['https://amoy.polygonscan.com/']\n        };\n      case 137:\n        // Polygon Mainnet\n        return {\n          chainId: chainIdHex,\n          chainName: 'Polygon Mainnet',\n          nativeCurrency: {\n            name: 'MATIC',\n            symbol: 'MATIC',\n            decimals: 18\n          },\n          rpcUrls: ['https://polygon-rpc.com'],\n          blockExplorerUrls: ['https://polygonscan.com/']\n        };\n      case 1:\n        // Ethereum Mainnet\n        return {\n          chainId: chainIdHex,\n          chainName: 'Ethereum Mainnet',\n          nativeCurrency: {\n            name: 'Ethereum',\n            symbol: 'ETH',\n            decimals: 18\n          },\n          rpcUrls: ['https://mainnet.infura.io/v3/'],\n          blockExplorerUrls: ['https://etherscan.io/']\n        };\n      default:\n        throw new Error(`Unsupported network: ${chainId}`);\n    }\n  };\n  const disconnectWallet = useCallback(async () => {\n    console.log('Disconnecting wallet:', walletType);\n\n    // Use comprehensive cleanup for WalletConnect\n    await cleanupWalletConnect();\n\n    // Clear all wallet state\n    setAccount(null);\n    setBalance(null);\n    setChainId(null);\n    setProvider(null);\n    setSigner(null);\n    setError(null);\n    setWalletType(null);\n    setWalletConnectProvider(null);\n    setIsNetworkSwitching(false); // Reset network switching state\n\n    // Store disconnect state with wallet type to prevent auto-connect\n    localStorage.setItem('walletDisconnected', 'true');\n    localStorage.removeItem('preferredWallet');\n    console.log('Wallet disconnected successfully');\n  }, [walletType]);\n\n  // Listen for account changes\n  useEffect(() => {\n    const cleanupFunctions = [];\n\n    // MetaMask event listeners\n    if (typeof window.ethereum !== 'undefined' && walletType === 'metamask') {\n      var _window$ethereum$on, _window$ethereum, _window$ethereum$on2, _window$ethereum2;\n      const handleAccountsChanged = accounts => {\n        console.log('MetaMask accounts changed:', accounts);\n        if (accounts.length === 0 && !isNetworkSwitching) {\n          // Only disconnect if we're not in the middle of a network switch\n          disconnectWallet();\n        } else if (accounts[0] !== account) {\n          setAccount(accounts[0]);\n          if (provider && !isNetworkSwitching) {\n            updateBalance(accounts[0], provider);\n          }\n        }\n      };\n      const handleChainChanged = chainIdHex => {\n        console.log('MetaMask chain changed:', chainIdHex);\n        const newChainId = parseInt(chainIdHex, 16);\n        setChainId(newChainId);\n\n        // Don't update balance immediately - let the network switch process handle it\n        console.log('MetaMask network changed to:', newChainId);\n      };\n      (_window$ethereum$on = (_window$ethereum = window.ethereum).on) === null || _window$ethereum$on === void 0 ? void 0 : _window$ethereum$on.call(_window$ethereum, 'accountsChanged', handleAccountsChanged);\n      (_window$ethereum$on2 = (_window$ethereum2 = window.ethereum).on) === null || _window$ethereum$on2 === void 0 ? void 0 : _window$ethereum$on2.call(_window$ethereum2, 'chainChanged', handleChainChanged);\n      cleanupFunctions.push(() => {\n        if (typeof window.ethereum !== 'undefined') {\n          var _removeListener, _ref, _removeListener2, _ref2;\n          (_removeListener = (_ref = window.ethereum).removeListener) === null || _removeListener === void 0 ? void 0 : _removeListener.call(_ref, 'accountsChanged', handleAccountsChanged);\n          (_removeListener2 = (_ref2 = window.ethereum).removeListener) === null || _removeListener2 === void 0 ? void 0 : _removeListener2.call(_ref2, 'chainChanged', handleChainChanged);\n        }\n      });\n    }\n\n    // WalletConnect event listeners\n    if (walletConnectProvider && walletType === 'walletconnect') {\n      const handleAccountsChanged = accounts => {\n        console.log('WalletConnect accounts changed:', accounts);\n        if (accounts.length === 0 && !isNetworkSwitching) {\n          // Only disconnect if we're not in the middle of a network switch\n          disconnectWallet();\n        } else if (accounts[0] !== account) {\n          setAccount(accounts[0]);\n          if (provider && !isNetworkSwitching) {\n            updateBalance(accounts[0], provider);\n          }\n        }\n      };\n      const handleChainChanged = chainId => {\n        console.log('WalletConnect chain changed:', chainId);\n        // Ensure chainId is always a number\n        const numericChainId = typeof chainId === 'string' ? parseInt(chainId, 16) : chainId;\n        setChainId(numericChainId);\n\n        // Don't update balance immediately - let the network switch process handle it\n        console.log('WalletConnect network changed to:', numericChainId);\n      };\n      const handleDisconnect = () => {\n        console.log('WalletConnect disconnected');\n        disconnectWallet();\n      };\n      const handleSessionUpdate = session => {\n        console.log('WalletConnect session updated:', session);\n        // Don't disconnect on session updates, just log them\n        // Session updates are normal and shouldn't cause disconnection\n      };\n      const handleSessionExpire = () => {\n        console.log('WalletConnect session expired');\n        // Only disconnect if not in the middle of a network switch\n        if (!isNetworkSwitching) {\n          disconnectWallet();\n        }\n      };\n      walletConnectProvider.on('accountsChanged', handleAccountsChanged);\n      walletConnectProvider.on('chainChanged', handleChainChanged);\n      walletConnectProvider.on('disconnect', handleDisconnect);\n      walletConnectProvider.on('session_update', handleSessionUpdate);\n      walletConnectProvider.on('session_expire', handleSessionExpire);\n      cleanupFunctions.push(() => {\n        walletConnectProvider.off('accountsChanged', handleAccountsChanged);\n        walletConnectProvider.off('chainChanged', handleChainChanged);\n        walletConnectProvider.off('disconnect', handleDisconnect);\n        walletConnectProvider.off('session_update', handleSessionUpdate);\n        walletConnectProvider.off('session_expire', handleSessionExpire);\n      });\n    }\n    return () => {\n      cleanupFunctions.forEach(cleanup => cleanup());\n    };\n  }, [account, provider, walletType, walletConnectProvider, disconnectWallet]);\n\n  // Auto-connect if previously connected\n  useEffect(() => {\n    const checkConnection = async () => {\n      // Check if there's a pending WalletConnect connection after page reload\n      const pendingWalletConnect = localStorage.getItem('pendingWalletConnect');\n      if (pendingWalletConnect === 'true') {\n        console.log('Pending WalletConnect connection detected, connecting...');\n        localStorage.removeItem('pendingWalletConnect');\n        try {\n          await connectWalletConnect();\n          return;\n        } catch (error) {\n          console.log('Pending WalletConnect connection failed:', error);\n          setError('Failed to connect to WalletConnect. Please try again.');\n        }\n      }\n\n      // Only auto-connect if not explicitly disconnected and no account is connected\n      if (localStorage.getItem('walletDisconnected') === 'true' || account) {\n        return;\n      }\n      console.log('Attempting auto-connect...');\n      const preferredWallet = localStorage.getItem('preferredWallet');\n\n      // Try preferred wallet first, then fallback to both\n      const walletsToTry = preferredWallet ? [preferredWallet, 'metamask', 'walletconnect'] : ['metamask', 'walletconnect'];\n      for (const walletType of walletsToTry) {\n        if (walletType === 'metamask' && typeof window.ethereum !== 'undefined') {\n          try {\n            console.log('Checking MetaMask connection...');\n\n            // First check if MetaMask is unlocked and has accounts\n            const accounts = await window.ethereum.request({\n              method: 'eth_accounts'\n            });\n            if (accounts.length > 0) {\n              console.log('MetaMask has accounts, attempting auto-connect...');\n              const browserProvider = new ethers.BrowserProvider(window.ethereum);\n              try {\n                const userSigner = await browserProvider.getSigner();\n                const network = await browserProvider.getNetwork();\n                setProvider(browserProvider);\n                setSigner(userSigner);\n                setAccount(accounts[0]);\n                setChainId(Number(network.chainId));\n                setWalletType('metamask');\n                await updateBalance(accounts[0], browserProvider);\n                console.log('MetaMask auto-connected successfully:', {\n                  account: accounts[0],\n                  chainId: Number(network.chainId)\n                });\n                return; // Exit early if MetaMask connected\n              } catch (signerError) {\n                console.log('MetaMask signer error (likely locked):', signerError.message);\n                // MetaMask is likely locked, skip auto-connect\n              }\n            } else {\n              console.log('MetaMask has no accounts or is locked');\n            }\n          } catch (err) {\n            console.error('Error checking MetaMask connection:', err);\n          }\n        }\n        if (walletType === 'walletconnect') {\n          try {\n            console.log('Checking WalletConnect session...');\n            const projectId = process.env.REACT_APP_WALLETCONNECT_PROJECT_ID;\n            if (projectId) {\n              let wcProvider = wcProviderInstance;\n\n              // Only initialize if not already initialized\n              if (!wcProvider) {\n                wcProvider = await EthereumProvider.init({\n                  projectId: projectId,\n                  chains: [1, 137, 56, 43114, 80002],\n                  showQrModal: false,\n                  metadata: {\n                    name: 'STR Domains Marketplace',\n                    description: 'Decentralized marketplace for STR domains',\n                    url: window.location.origin,\n                    icons: [`${window.location.origin}/logo192.png`]\n                  },\n                  optionalChains: [80002],\n                  // Make Amoy optional for better compatibility\n                  // Additional configuration to prevent session errors\n                  events: ['session_request', 'session_update', 'session_delete'],\n                  methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData']\n                });\n                setWcProviderInstance(wcProvider);\n              }\n              if (wcProvider.session) {\n                console.log('Auto-connecting WalletConnect...');\n                const browserProvider = new ethers.BrowserProvider(wcProvider);\n                const accounts = await browserProvider.listAccounts();\n                if (accounts.length > 0) {\n                  const userSigner = await browserProvider.getSigner();\n                  const network = await browserProvider.getNetwork();\n                  setProvider(browserProvider);\n                  setSigner(userSigner);\n                  setAccount(accounts[0].address);\n                  setChainId(Number(network.chainId));\n                  setWalletType('walletconnect');\n                  setWalletConnectProvider(wcProvider);\n                  await updateBalance(accounts[0].address, browserProvider);\n                  return; // Exit early if WalletConnect connected\n                }\n              }\n            }\n          } catch (err) {\n            console.error('Error checking WalletConnect connection:', err);\n          }\n        }\n      }\n      console.log('No previous wallet connections found');\n    };\n\n    // Add a small delay to prevent race conditions\n    const timeoutId = setTimeout(checkConnection, 100);\n    return () => clearTimeout(timeoutId);\n  }, []); // No dependencies to prevent re-runs\n\n  const value = {\n    account,\n    balance,\n    chainId,\n    provider,\n    signer,\n    connectWallet,\n    disconnectWallet,\n    switchNetwork,\n    isConnecting,\n    isNetworkSwitching,\n    error,\n    setError,\n    walletType\n  };\n  return /*#__PURE__*/_jsxDEV(WalletContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 842,\n    columnNumber: 10\n  }, this);\n};\n_s2(WalletProvider, \"NWvvZuHBGQkEoZJJiqa/Wjw6lSo=\");\n_c = WalletProvider;\nvar _c;\n$RefreshReg$(_c, \"WalletProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","ethers","EthereumProvider","jsxDEV","_jsxDEV","WalletContext","undefined","useWallet","_s","context","Error","WalletProvider","children","_s2","account","setAccount","balance","setBalance","chainId","setChainId","provider","setProvider","signer","setSigner","error","setError","walletType","setWalletType","walletConnectProvider","setWalletConnectProvider","isNetworkSwitching","setIsNetworkSwitching","isConnecting","setIsConnecting","wcProviderInstance","setWcProviderInstance","cleanupWalletConnect","console","log","disconnect","disconnectError","keysToRemove","i","localStorage","length","key","startsWith","push","forEach","removeItem","sessionKeysToRemove","sessionStorage","isWalletConnectInitializing","window","globalKeys","Object","keys","includes","e","Promise","resolve","setTimeout","updateBalance","address","balanceWei","getBalance","balanceEth","formatEther","parseFloat","toFixed","err","_err$message","message","connectWallet","connectMetaMask","setItem","location","reload","ethereum","accounts","request","method","browserProvider","BrowserProvider","send","userSigner","getSigner","network","getNetwork","Number","_error$message","_error$message2","code","connectWalletConnect","now","Date","lastConnectionAttempt","setLastConnectionAttempt","projectId","process","env","REACT_APP_WALLETCONNECT_PROJECT_ID","wcProvider","init","chains","showQrModal","metadata","name","description","url","origin","icons","relayUrl","qrModalOptions","themeMode","themeVariables","disableProviderPing","optionalChains","events","methods","initError","_initError$message","enable","enableError","listAccounts","_error$message3","_error$message4","_error$message5","_error$message6","_error$message7","_error$message8","_error$message9","switchNetwork","targetChainId","switchMetaMaskNetwork","switchWalletConnectNetwork","chainIdHex","toString","params","switchError","addMetaMaskNetwork","networkConfig","getNetworkConfig","addError","_switchError$message","_switchError$message2","_switchError$message3","chainName","nativeCurrency","symbol","decimals","rpcUrls","blockExplorerUrls","disconnectWallet","cleanupFunctions","_window$ethereum$on","_window$ethereum","_window$ethereum$on2","_window$ethereum2","handleAccountsChanged","handleChainChanged","newChainId","parseInt","on","call","_removeListener","_ref","_removeListener2","_ref2","removeListener","numericChainId","handleDisconnect","handleSessionUpdate","session","handleSessionExpire","off","cleanup","checkConnection","pendingWalletConnect","getItem","preferredWallet","walletsToTry","signerError","timeoutId","clearTimeout","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/src/contexts/WalletContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';\nimport { ethers } from 'ethers';\nimport { EthereumProvider } from '@walletconnect/ethereum-provider';\n\nexport type WalletType = 'metamask' | 'walletconnect';\n\ninterface WalletContextType {\n  account: string | null;\n  balance: string | null;\n  chainId: number | null;\n  provider: ethers.BrowserProvider | null;\n  signer: ethers.JsonRpcSigner | null;\n  connectWallet: (walletType?: WalletType) => Promise<void>;\n  disconnectWallet: () => void;\n  switchNetwork: (chainId: number) => Promise<void>;\n  isConnecting: boolean;\n  isNetworkSwitching: boolean;\n  error: string | null;\n  setError: (error: string | null) => void;\n  walletType: WalletType | null;\n}\n\nconst WalletContext = createContext<WalletContextType | undefined>(undefined);\n\nexport const useWallet = () => {\n  const context = useContext(WalletContext);\n  if (!context) {\n    throw new Error('useWallet must be used within a WalletProvider');\n  }\n  return context;\n};\n\ninterface WalletProviderProps {\n  children: ReactNode;\n}\n\nexport const WalletProvider: React.FC<WalletProviderProps> = ({ children }) => {\n  const [account, setAccount] = useState<string | null>(null);\n  const [balance, setBalance] = useState<string | null>(null);\n  const [chainId, setChainId] = useState<number | null>(null);\n  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);\n  const [signer, setSigner] = useState<ethers.JsonRpcSigner | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [walletType, setWalletType] = useState<WalletType | null>(null);\n  const [walletConnectProvider, setWalletConnectProvider] = useState<any>(null);\n  const [isNetworkSwitching, setIsNetworkSwitching] = useState(false);\n  const [isConnecting, setIsConnecting] = useState(false);\n  // Store WalletConnect provider globally to prevent multiple initializations\n  const [wcProviderInstance, setWcProviderInstance] = useState<any>(null);\n\n  // Comprehensive WalletConnect cleanup function\n  const cleanupWalletConnect = async () => {\n    console.log('Starting comprehensive WalletConnect cleanup...');\n    \n    try {\n      // Disconnect existing provider if it exists\n      if (wcProviderInstance) {\n        console.log('Disconnecting existing WalletConnect provider...');\n        try {\n          await wcProviderInstance.disconnect();\n        } catch (disconnectError) {\n          console.log('Error during disconnect (this is usually fine):', disconnectError);\n        }\n      }\n\n      // Clear all WalletConnect related state\n      setWcProviderInstance(null);\n      setWalletConnectProvider(null);\n      \n      // Clear WalletConnect from localStorage\n      const keysToRemove = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && (key.startsWith('walletconnect') || key.startsWith('wc@'))) {\n          keysToRemove.push(key);\n        }\n      }\n      keysToRemove.forEach(key => {\n        console.log('Removing WalletConnect localStorage key:', key);\n        localStorage.removeItem(key);\n      });\n\n      // Clear WalletConnect from sessionStorage as well\n      const sessionKeysToRemove = [];\n      for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key && (key.startsWith('walletconnect') || key.startsWith('wc@'))) {\n          sessionKeysToRemove.push(key);\n        }\n      }\n      sessionKeysToRemove.forEach(key => {\n        console.log('Removing WalletConnect sessionStorage key:', key);\n        sessionStorage.removeItem(key);\n      });\n\n      // Reset initialization state\n      isWalletConnectInitializing = false;\n      \n      // Force garbage collection of WalletConnect Core by clearing global references\n      // This is a workaround since WalletConnect doesn't provide a proper cleanup method\n      if (typeof window !== 'undefined') {\n        // Clear any global WalletConnect references\n        const globalKeys = Object.keys(window);\n        globalKeys.forEach(key => {\n          if (key.includes('walletconnect') || key.includes('wc')) {\n            try {\n              delete (window as any)[key];\n            } catch (e) {\n              // Ignore errors when trying to delete global properties\n            }\n          }\n        });\n      }\n      \n      // Add a delay to ensure cleanup completes before next connection\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      console.log('WalletConnect cleanup completed');\n    } catch (error) {\n      console.error('Error during WalletConnect cleanup:', error);\n      // Even if cleanup fails, we should clear the state\n      setWcProviderInstance(null);\n      setWalletConnectProvider(null);\n      isWalletConnectInitializing = false;\n    }\n  };\n\n  const updateBalance = async (address: string, provider: ethers.BrowserProvider) => {\n    // Skip balance update if we're in the middle of a network switch\n    if (isNetworkSwitching) {\n      console.log('Skipping balance update during network switch');\n      return;\n    }\n    \n    try {\n      const balanceWei = await provider.getBalance(address);\n      const balanceEth = ethers.formatEther(balanceWei);\n      setBalance(parseFloat(balanceEth).toFixed(4));\n    } catch (err: any) {\n      console.error('Error fetching balance:', err);\n      // Check if it's a network change error and handle gracefully\n      if (err.message?.includes('network changed')) {\n        console.log('Network change detected during balance update, skipping...');\n        return;\n      }\n      // Don't set balance to null on error, keep previous value\n    }\n  };\n\n  const connectWallet = async (walletType: WalletType = 'metamask') => {\n    setIsConnecting(true);\n    setError(null);\n\n    try {\n      // Always clean up WalletConnect before connecting any wallet\n      await cleanupWalletConnect();\n      \n      if (walletType === 'metamask') {\n        await connectMetaMask();\n      } else if (walletType === 'walletconnect') {\n        // For WalletConnect, force a page reload to ensure completely clean state\n        // This is necessary because WalletConnect Core maintains global state that can't be easily reset\n        console.log('Connecting to WalletConnect - forcing page reload for clean state');\n        localStorage.setItem('pendingWalletConnect', 'true');\n        window.location.reload();\n        return;\n      }\n    } catch (err: any) {\n      console.error('Error connecting wallet:', err);\n      setError(err.message || 'Failed to connect wallet');\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n\n  const connectMetaMask = async () => {\n    // Prevent multiple simultaneous connection attempts\n    if (isConnecting) {\n      console.log('Wallet connection already in progress, skipping...');\n      return;\n    }\n\n    try {\n      setIsConnecting(true);\n      \n      if (typeof window.ethereum === 'undefined') {\n        throw new Error('Please install MetaMask to use this dApp');\n      }\n\n      // Check if MetaMask is locked\n      try {\n        const accounts = await window.ethereum.request({ method: 'eth_accounts' });\n        if (accounts.length === 0) {\n          // MetaMask is locked or no accounts connected\n          console.log('MetaMask is locked or no accounts connected, requesting access...');\n        }\n      } catch (error) {\n        console.log('MetaMask is locked, requesting access...');\n      }\n\n      const browserProvider = new ethers.BrowserProvider(window.ethereum);\n      \n      const accounts = await browserProvider.send('eth_requestAccounts', []);\n      \n      if (accounts.length === 0) {\n        throw new Error('No accounts found. Please unlock MetaMask and try again.');\n      }\n\n      const userSigner = await browserProvider.getSigner();\n      const network = await browserProvider.getNetwork();\n      \n      setProvider(browserProvider);\n      setSigner(userSigner);\n      setAccount(accounts[0]);\n      setChainId(Number(network.chainId));\n      setWalletType('metamask');\n      \n      await updateBalance(accounts[0], browserProvider);\n      \n      // Store preferred wallet type\n      localStorage.setItem('preferredWallet', 'metamask');\n      localStorage.removeItem('walletDisconnected');\n      \n      console.log('MetaMask connected successfully:', {\n        account: accounts[0],\n        chainId: Number(network.chainId)\n      });\n    } catch (error: any) {\n      console.error('MetaMask connection error:', error);\n      if (error.code === 4001) {\n        throw new Error('MetaMask connection was rejected by user');\n      } else if (error.message?.includes('User rejected')) {\n        throw new Error('MetaMask connection was rejected by user');\n      } else if (error.message?.includes('locked')) {\n        throw new Error('MetaMask is locked. Please unlock MetaMask and try again.');\n      } else {\n        throw new Error(`MetaMask connection failed: ${error.message || 'Unknown error'}`);\n      }\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n\n  const connectWalletConnect = async (): Promise<void> => {\n    // Prevent multiple simultaneous connection attempts\n    if (isConnecting) {\n      throw new Error('Connection already in progress. Please wait for the current connection to complete.');\n    }\n\n    // Prevent rapid successive connection attempts (minimum 2 seconds between attempts)\n    const now = Date.now();\n    if (now - lastConnectionAttempt < 2000) {\n      throw new Error('Please wait a moment before trying to connect again.');\n    }\n    setLastConnectionAttempt(now);\n\n    try {\n      setIsConnecting(true);\n      console.log('Starting WalletConnect connection...');\n      \n      // Create WalletConnect provider\n      const projectId = process.env.REACT_APP_WALLETCONNECT_PROJECT_ID;\n      if (!projectId) {\n        throw new Error('WalletConnect Project ID not configured. Please set REACT_APP_WALLETCONNECT_PROJECT_ID in your environment variables.');\n      }\n\n      // Always create a fresh WalletConnect provider instance\n      console.log('Creating fresh WalletConnect provider instance...');\n      \n      let wcProvider;\n      try {\n        wcProvider = await EthereumProvider.init({\n          projectId: projectId,\n          chains: [1, 137, 56, 43114, 80002], // Ethereum, Polygon, BSC, Avalanche, Polygon Amoy\n          showQrModal: true,\n          metadata: {\n            name: 'STR Domains Marketplace',\n            description: 'Decentralized marketplace for STR domains',\n            url: window.location.origin,\n            icons: [`${window.location.origin}/logo192.png`]\n          },\n          relayUrl: 'wss://relay.walletconnect.com',\n          qrModalOptions: {\n            themeMode: 'light',\n            themeVariables: {\n              '--wcm-z-index': '1000'\n            }\n          },\n          disableProviderPing: true,\n          optionalChains: [80002],\n          events: ['session_request', 'session_update', 'session_delete'],\n          methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData'],\n        });\n        setWcProviderInstance(wcProvider);\n        console.log('Fresh WalletConnect provider created successfully');\n      } catch (initError: any) {\n        console.error('Error creating fresh WalletConnect provider:', initError);\n        // If we get \"already initialized\" error, this is expected and we should continue\n        if (initError.message?.includes('already initialized')) {\n          console.log('WalletConnect already initialized - this is expected after cleanup, continuing...');\n          // The global Core is already initialized, we can continue\n          // We'll create a new provider instance using the existing Core\n          wcProvider = await EthereumProvider.init({\n            projectId: projectId,\n            chains: [1, 137, 56, 43114, 80002],\n            showQrModal: true,\n            metadata: {\n              name: 'STR Domains Marketplace',\n              description: 'Decentralized marketplace for STR domains',\n              url: window.location.origin,\n              icons: [`${window.location.origin}/logo192.png`]\n            },\n            relayUrl: 'wss://relay.walletconnect.com',\n            qrModalOptions: {\n              themeMode: 'light',\n              themeVariables: {\n                '--wcm-z-index': '1000'\n              }\n            },\n            disableProviderPing: true,\n            optionalChains: [80002],\n            events: ['session_request', 'session_update', 'session_delete'],\n            methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData'],\n          });\n          setWcProviderInstance(wcProvider);\n          console.log('WalletConnect provider created using existing Core');\n        } else {\n          throw initError;\n        }\n      }\n\n      console.log('WalletConnect provider initialized, enabling session...');\n      // Enable session (triggers QR Code modal) with comprehensive error handling\n      try {\n        await wcProvider.enable();\n      } catch (enableError: any) {\n        console.error('Error enabling WalletConnect session:', enableError);\n        // If session enable fails, try to clean up and throw the error\n        setWcProviderInstance(null);\n        throw enableError;\n      }\n\n      console.log('WalletConnect session enabled, setting up ethers provider...');\n      // Create ethers provider from WalletConnect provider\n      const browserProvider = new ethers.BrowserProvider(wcProvider);\n      const accounts = await browserProvider.listAccounts();\n      \n      if (accounts.length === 0) {\n        throw new Error('No accounts found');\n      }\n\n      const userSigner = await browserProvider.getSigner();\n      const network = await browserProvider.getNetwork();\n      \n      console.log('WalletConnect connected:', {\n        account: accounts[0].address,\n        chainId: Number(network.chainId)\n      });\n      \n      setProvider(browserProvider);\n      setSigner(userSigner);\n      setAccount(accounts[0].address);\n      setChainId(Number(network.chainId));\n      setWalletType('walletconnect');\n      setWalletConnectProvider(wcProvider);\n      \n      await updateBalance(accounts[0].address, browserProvider);\n      \n      // Store preferred wallet type\n      localStorage.setItem('preferredWallet', 'walletconnect');\n      localStorage.removeItem('walletDisconnected');\n      \n        console.log('WalletConnect connection completed successfully');\n        } catch (error: any) {\n          console.error('WalletConnect connection error:', error);\n          if (error.message?.includes('User rejected')) {\n            throw new Error('Connection cancelled by user');\n          } else if (error.message?.includes('Connection request reset') || \n                     error.message?.includes('Please try again') ||\n                     error.message?.includes('connection was reset') ||\n                     error.message?.includes('request was reset')) {\n            throw new Error('Connection request was reset. Please try connecting again.');\n          } else if (error.message?.includes('No matching key. session topic doesn\\'t exist')) {\n            throw new Error('WalletConnect session expired. Please try connecting again.');\n          } else if (error.message?.includes('already initialized')) {\n            throw new Error('WalletConnect is already initializing. Please wait and try again.');\n          }\n          throw error;\n    } finally {\n      setIsConnecting(false);\n    }\n  };\n\n  const switchNetwork = async (targetChainId: number) => {\n    console.log('switchNetwork called:', { targetChainId, walletType, account });\n    \n    if (!walletType) {\n      throw new Error('No wallet connected');\n    }\n    \n    // Set network switching flag to prevent balance updates during transition\n    setIsNetworkSwitching(true);\n    \n    try {\n      if (walletType === 'metamask') {\n        console.log('Switching MetaMask network to:', targetChainId);\n        await switchMetaMaskNetwork(targetChainId);\n      } else if (walletType === 'walletconnect') {\n        console.log('Switching WalletConnect network to:', targetChainId);\n        await switchWalletConnectNetwork(targetChainId);\n      } else {\n        throw new Error(`Unsupported wallet type: ${walletType}`);\n      }\n      \n      console.log('Network switch completed successfully');\n    } finally {\n      // Clear network switching flag after a delay to allow provider to stabilize\n      setTimeout(() => {\n        setIsNetworkSwitching(false);\n        // Update balance after network switch is complete\n        if (account && provider) {\n          updateBalance(account, provider);\n        }\n      }, 2000);\n    }\n  };\n\n  const switchMetaMaskNetwork = async (targetChainId: number) => {\n    if (typeof window.ethereum === 'undefined') {\n      throw new Error('MetaMask not detected');\n    }\n\n    const chainIdHex = `0x${targetChainId.toString(16)}`;\n\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: chainIdHex }],\n      });\n    } catch (switchError: any) {\n      // Chain not added to MetaMask, try to add it\n      if (switchError.code === 4902) {\n        await addMetaMaskNetwork(targetChainId);\n      } else {\n        throw switchError;\n      }\n    }\n  };\n\n  const addMetaMaskNetwork = async (chainId: number) => {\n    if (typeof window.ethereum === 'undefined') {\n      throw new Error('MetaMask not detected');\n    }\n\n    const chainIdHex = `0x${chainId.toString(16)}`;\n    const networkConfig = getNetworkConfig(chainId);\n\n    await window.ethereum.request({\n      method: 'wallet_addEthereumChain',\n      params: [networkConfig],\n    });\n  };\n\n  const switchWalletConnectNetwork = async (targetChainId: number) => {\n    if (!walletConnectProvider) {\n      throw new Error('WalletConnect not connected');\n    }\n\n    const chainIdHex = `0x${targetChainId.toString(16)}`;\n\n    try {\n      // Try wallet_switchEthereumChain first\n      await walletConnectProvider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: chainIdHex }],\n      });\n      \n      // Wait a moment for the network change to propagate\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Update the chainId state after successful switch\n      setChainId(targetChainId);\n      \n    } catch (switchError: any) {\n      console.log('wallet_switchEthereumChain failed:', switchError);\n      \n      // If chain doesn't exist, try to add it\n      if (switchError.code === 4902) {\n        try {\n          const networkConfig = getNetworkConfig(targetChainId);\n          await walletConnectProvider.request({\n            method: 'wallet_addEthereumChain',\n            params: [networkConfig],\n          });\n          \n          // Wait for network to be added and switched\n          await new Promise(resolve => setTimeout(resolve, 1000));\n          \n          // Update the chainId state after successful add and switch\n          setChainId(targetChainId);\n          \n        } catch (addError: any) {\n          console.log('wallet_addEthereumChain failed:', addError);\n          throw new Error(`Network switching not supported by your wallet. Please manually switch to Polygon Amoy (Chain ID: ${targetChainId}) in your wallet app.`);\n        }\n      } else {\n        // Other errors - provide helpful message\n        console.log('Network switch error:', switchError);\n        \n        if (switchError.message?.includes('User rejected') || switchError.code === 4001) {\n          throw new Error('Network switch was cancelled by user.');\n        } else if (switchError.message?.includes('not supported') || switchError.message?.includes('unsupported')) {\n          throw new Error(`Your wallet doesn't support automatic network switching. Please manually switch to Polygon Amoy (Chain ID: ${targetChainId}) in your wallet app.`);\n        } else {\n          throw new Error(`Failed to switch network: ${switchError.message || 'Unknown error'}. Please manually switch to Polygon Amoy (Chain ID: ${targetChainId}) in your wallet app.`);\n        }\n      }\n    }\n  };\n\n  const getNetworkConfig = (chainId: number) => {\n    const chainIdHex = `0x${chainId.toString(16)}`;\n\n    switch (chainId) {\n      case 80002: // Polygon Amoy\n        return {\n          chainId: chainIdHex,\n          chainName: 'Polygon Amoy Testnet',\n          nativeCurrency: {\n            name: 'MATIC',\n            symbol: 'MATIC',\n            decimals: 18,\n          },\n          rpcUrls: ['https://rpc-amoy.polygon.technology'],\n          blockExplorerUrls: ['https://amoy.polygonscan.com/'],\n        };\n      case 137: // Polygon Mainnet\n        return {\n          chainId: chainIdHex,\n          chainName: 'Polygon Mainnet',\n          nativeCurrency: {\n            name: 'MATIC',\n            symbol: 'MATIC',\n            decimals: 18,\n          },\n          rpcUrls: ['https://polygon-rpc.com'],\n          blockExplorerUrls: ['https://polygonscan.com/'],\n        };\n      case 1: // Ethereum Mainnet\n        return {\n          chainId: chainIdHex,\n          chainName: 'Ethereum Mainnet',\n          nativeCurrency: {\n            name: 'Ethereum',\n            symbol: 'ETH',\n            decimals: 18,\n          },\n          rpcUrls: ['https://mainnet.infura.io/v3/'],\n          blockExplorerUrls: ['https://etherscan.io/'],\n        };\n      default:\n        throw new Error(`Unsupported network: ${chainId}`);\n    }\n  };\n\n  const disconnectWallet = useCallback(async () => {\n    console.log('Disconnecting wallet:', walletType);\n    \n    // Use comprehensive cleanup for WalletConnect\n    await cleanupWalletConnect();\n\n    // Clear all wallet state\n    setAccount(null);\n    setBalance(null);\n    setChainId(null);\n    setProvider(null);\n    setSigner(null);\n    setError(null);\n    setWalletType(null);\n    setWalletConnectProvider(null);\n    setIsNetworkSwitching(false); // Reset network switching state\n    \n    // Store disconnect state with wallet type to prevent auto-connect\n    localStorage.setItem('walletDisconnected', 'true');\n    localStorage.removeItem('preferredWallet');\n    \n    console.log('Wallet disconnected successfully');\n  }, [walletType]);\n\n  // Listen for account changes\n  useEffect(() => {\n    const cleanupFunctions: (() => void)[] = [];\n\n    // MetaMask event listeners\n    if (typeof window.ethereum !== 'undefined' && walletType === 'metamask') {\n      const handleAccountsChanged = (accounts: string[]) => {\n        console.log('MetaMask accounts changed:', accounts);\n        if (accounts.length === 0 && !isNetworkSwitching) {\n          // Only disconnect if we're not in the middle of a network switch\n          disconnectWallet();\n        } else if (accounts[0] !== account) {\n          setAccount(accounts[0]);\n          if (provider && !isNetworkSwitching) {\n            updateBalance(accounts[0], provider);\n          }\n        }\n      };\n\n      const handleChainChanged = (chainIdHex: string) => {\n        console.log('MetaMask chain changed:', chainIdHex);\n        const newChainId = parseInt(chainIdHex, 16);\n        setChainId(newChainId);\n        \n        // Don't update balance immediately - let the network switch process handle it\n        console.log('MetaMask network changed to:', newChainId);\n      };\n\n      window.ethereum.on?.('accountsChanged', handleAccountsChanged);\n      window.ethereum.on?.('chainChanged', handleChainChanged);\n\n      cleanupFunctions.push(() => {\n        if (typeof window.ethereum !== 'undefined') {\n          (window.ethereum as any).removeListener?.('accountsChanged', handleAccountsChanged);\n          (window.ethereum as any).removeListener?.('chainChanged', handleChainChanged);\n        }\n      });\n    }\n\n    // WalletConnect event listeners\n    if (walletConnectProvider && walletType === 'walletconnect') {\n      const handleAccountsChanged = (accounts: string[]) => {\n        console.log('WalletConnect accounts changed:', accounts);\n        if (accounts.length === 0 && !isNetworkSwitching) {\n          // Only disconnect if we're not in the middle of a network switch\n          disconnectWallet();\n        } else if (accounts[0] !== account) {\n          setAccount(accounts[0]);\n          if (provider && !isNetworkSwitching) {\n            updateBalance(accounts[0], provider);\n          }\n        }\n      };\n\n      const handleChainChanged = (chainId: number | string) => {\n        console.log('WalletConnect chain changed:', chainId);\n        // Ensure chainId is always a number\n        const numericChainId = typeof chainId === 'string' ? parseInt(chainId, 16) : chainId;\n        setChainId(numericChainId);\n        \n        // Don't update balance immediately - let the network switch process handle it\n        console.log('WalletConnect network changed to:', numericChainId);\n      };\n\n      const handleDisconnect = () => {\n        console.log('WalletConnect disconnected');\n        disconnectWallet();\n      };\n\n      const handleSessionUpdate = (session: any) => {\n        console.log('WalletConnect session updated:', session);\n        // Don't disconnect on session updates, just log them\n        // Session updates are normal and shouldn't cause disconnection\n      };\n      \n      const handleSessionExpire = () => {\n        console.log('WalletConnect session expired');\n        // Only disconnect if not in the middle of a network switch\n        if (!isNetworkSwitching) {\n          disconnectWallet();\n        }\n      };\n\n      walletConnectProvider.on('accountsChanged', handleAccountsChanged);\n      walletConnectProvider.on('chainChanged', handleChainChanged);\n      walletConnectProvider.on('disconnect', handleDisconnect);\n      walletConnectProvider.on('session_update', handleSessionUpdate);\n      walletConnectProvider.on('session_expire', handleSessionExpire);\n\n      cleanupFunctions.push(() => {\n        walletConnectProvider.off('accountsChanged', handleAccountsChanged);\n        walletConnectProvider.off('chainChanged', handleChainChanged);\n        walletConnectProvider.off('disconnect', handleDisconnect);\n        walletConnectProvider.off('session_update', handleSessionUpdate);\n        walletConnectProvider.off('session_expire', handleSessionExpire);\n      });\n    }\n\n    return () => {\n      cleanupFunctions.forEach(cleanup => cleanup());\n    };\n  }, [account, provider, walletType, walletConnectProvider, disconnectWallet]);\n\n  // Auto-connect if previously connected\n  useEffect(() => {\n    const checkConnection = async () => {\n      // Check if there's a pending WalletConnect connection after page reload\n      const pendingWalletConnect = localStorage.getItem('pendingWalletConnect');\n      if (pendingWalletConnect === 'true') {\n        console.log('Pending WalletConnect connection detected, connecting...');\n        localStorage.removeItem('pendingWalletConnect');\n        try {\n          await connectWalletConnect();\n          return;\n        } catch (error) {\n          console.log('Pending WalletConnect connection failed:', error);\n          setError('Failed to connect to WalletConnect. Please try again.');\n        }\n      }\n\n      // Only auto-connect if not explicitly disconnected and no account is connected\n      if (localStorage.getItem('walletDisconnected') === 'true' || account) {\n        return;\n      }\n\n      console.log('Attempting auto-connect...');\n      const preferredWallet = localStorage.getItem('preferredWallet');\n      \n      // Try preferred wallet first, then fallback to both\n      const walletsToTry = preferredWallet ? [preferredWallet, 'metamask', 'walletconnect'] : ['metamask', 'walletconnect'];\n      \n      for (const walletType of walletsToTry) {\n        if (walletType === 'metamask' && typeof window.ethereum !== 'undefined') {\n          try {\n            console.log('Checking MetaMask connection...');\n            \n            // First check if MetaMask is unlocked and has accounts\n            const accounts = await window.ethereum.request({ method: 'eth_accounts' });\n            \n            if (accounts.length > 0) {\n              console.log('MetaMask has accounts, attempting auto-connect...');\n              const browserProvider = new ethers.BrowserProvider(window.ethereum);\n              \n              try {\n                const userSigner = await browserProvider.getSigner();\n                const network = await browserProvider.getNetwork();\n                \n                setProvider(browserProvider);\n                setSigner(userSigner);\n                setAccount(accounts[0]);\n                setChainId(Number(network.chainId));\n                setWalletType('metamask');\n                \n                await updateBalance(accounts[0], browserProvider);\n                \n                console.log('MetaMask auto-connected successfully:', {\n                  account: accounts[0],\n                  chainId: Number(network.chainId)\n                });\n                return; // Exit early if MetaMask connected\n              } catch (signerError: any) {\n                console.log('MetaMask signer error (likely locked):', signerError.message);\n                // MetaMask is likely locked, skip auto-connect\n              }\n            } else {\n              console.log('MetaMask has no accounts or is locked');\n            }\n          } catch (err) {\n            console.error('Error checking MetaMask connection:', err);\n          }\n        }\n        \n        if (walletType === 'walletconnect') {\n          try {\n            console.log('Checking WalletConnect session...');\n            const projectId = process.env.REACT_APP_WALLETCONNECT_PROJECT_ID;\n            if (projectId) {\n              \n              let wcProvider = wcProviderInstance;\n              \n              // Only initialize if not already initialized\n              if (!wcProvider) {\n                wcProvider = await EthereumProvider.init({\n                  projectId: projectId,\n                  chains: [1, 137, 56, 43114, 80002],\n                  showQrModal: false,\n                  metadata: {\n                    name: 'STR Domains Marketplace',\n                    description: 'Decentralized marketplace for STR domains',\n                    url: window.location.origin,\n                    icons: [`${window.location.origin}/logo192.png`]\n                  },\n                  optionalChains: [80002], // Make Amoy optional for better compatibility\n                  // Additional configuration to prevent session errors\n                  events: ['session_request', 'session_update', 'session_delete'],\n                  methods: ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData'],\n                });\n                setWcProviderInstance(wcProvider);\n              }\n\n              if (wcProvider.session) {\n                console.log('Auto-connecting WalletConnect...');\n                const browserProvider = new ethers.BrowserProvider(wcProvider);\n                const accounts = await browserProvider.listAccounts();\n                \n                if (accounts.length > 0) {\n                  const userSigner = await browserProvider.getSigner();\n                  const network = await browserProvider.getNetwork();\n                  \n                  setProvider(browserProvider);\n                  setSigner(userSigner);\n                  setAccount(accounts[0].address);\n                  setChainId(Number(network.chainId));\n                  setWalletType('walletconnect');\n                  setWalletConnectProvider(wcProvider);\n                  \n                  await updateBalance(accounts[0].address, browserProvider);\n                  return; // Exit early if WalletConnect connected\n                }\n              }\n            }\n          } catch (err) {\n            console.error('Error checking WalletConnect connection:', err);\n          }\n        }\n      }\n      \n      console.log('No previous wallet connections found');\n    };\n\n    // Add a small delay to prevent race conditions\n    const timeoutId = setTimeout(checkConnection, 100);\n    \n    return () => clearTimeout(timeoutId);\n  }, []); // No dependencies to prevent re-runs\n\n  const value: WalletContextType = {\n    account,\n    balance,\n    chainId,\n    provider,\n    signer,\n    connectWallet,\n    disconnectWallet,\n    switchNetwork,\n    isConnecting,\n    isNetworkSwitching,\n    error,\n    setError,\n    walletType,\n  };\n\n  return <WalletContext.Provider value={value}>{children}</WalletContext.Provider>;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}