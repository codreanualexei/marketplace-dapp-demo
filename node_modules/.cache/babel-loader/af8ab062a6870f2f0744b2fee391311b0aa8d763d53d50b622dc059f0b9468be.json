{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"account\", \"chain\", \"accessList\", \"authorizationList\", \"blobs\", \"data\", \"gas\", \"gasPrice\", \"maxFeePerBlobGas\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"pollingInterval\", \"throwOnReceiptRevert\", \"type\", \"value\"];\nimport { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { AccountNotFoundError, AccountTypeNotSupportedError } from '../../errors/account.js';\nimport { BaseError } from '../../errors/base.js';\nimport { TransactionReceiptRevertedError } from '../../errors/transaction.js';\nimport { recoverAuthorizationAddress } from '../../utils/authorization/recoverAuthorizationAddress.js';\nimport { assertCurrentChain } from '../../utils/chain/assertCurrentChain.js';\nimport { getTransactionError } from '../../utils/errors/getTransactionError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { getAction } from '../../utils/getAction.js';\nimport { LruMap } from '../../utils/lru.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\nimport { getChainId } from '../public/getChainId.js';\nimport { waitForTransactionReceipt } from '../public/waitForTransactionReceipt.js';\nimport { defaultParameters, prepareTransactionRequest } from './prepareTransactionRequest.js';\nimport { sendRawTransactionSync } from './sendRawTransactionSync.js';\nconst supportsWalletNamespace = new LruMap(128);\n/**\n * Creates, signs, and sends a new transaction to the network synchronously.\n * Returns the transaction receipt.\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionSyncParameters}\n * @returns The transaction receipt. {@link SendTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransactionSync(client, parameters) {\n  var _parameters$timeout, _chain$blockTime;\n  const {\n      account: account_ = client.account,\n      chain = client.chain,\n      accessList,\n      authorizationList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      pollingInterval,\n      throwOnReceiptRevert,\n      type,\n      value\n    } = parameters,\n    rest = _objectWithoutProperties(parameters, _excluded);\n  const timeout = (_parameters$timeout = parameters.timeout) !== null && _parameters$timeout !== void 0 ? _parameters$timeout : Math.max(((_chain$blockTime = chain === null || chain === void 0 ? void 0 : chain.blockTime) !== null && _chain$blockTime !== void 0 ? _chain$blockTime : 0) * 3, 5000);\n  if (typeof account_ === 'undefined') throw new AccountNotFoundError({\n    docsPath: '/docs/actions/wallet/sendTransactionSync'\n  });\n  const account = account_ ? parseAccount(account_) : null;\n  try {\n    assertRequest(parameters);\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to;\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined;\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0) return await recoverAuthorizationAddress({\n        authorization: authorizationList[0]\n      }).catch(() => {\n        throw new BaseError('`to` is required. Could not infer from `authorizationList`.');\n      });\n      // Otherwise, we are sending a deployment transaction.\n      return undefined;\n    })();\n    if ((account === null || account === void 0 ? void 0 : account.type) === 'json-rpc' || account === null) {\n      var _client$chain;\n      let chainId;\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({});\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain\n        });\n      }\n      const chainFormat = (_client$chain = client.chain) === null || _client$chain === void 0 || (_client$chain = _client$chain.formatters) === null || _client$chain === void 0 || (_client$chain = _client$chain.transactionRequest) === null || _client$chain === void 0 ? void 0 : _client$chain.format;\n      const format = chainFormat || formatTransactionRequest;\n      const request = format(_objectSpread(_objectSpread({}, extract(rest, {\n        format: chainFormat\n      })), {}, {\n        accessList,\n        authorizationList,\n        blobs,\n        chainId,\n        data,\n        from: account === null || account === void 0 ? void 0 : account.address,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        to,\n        type,\n        value\n      }), 'sendTransaction');\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);\n      const method = isWalletNamespaceSupported ? 'wallet_sendTransaction' : 'eth_sendTransaction';\n      const hash = await (async () => {\n        try {\n          return await client.request({\n            method,\n            params: [request]\n          }, {\n            retryCount: 0\n          });\n        } catch (e) {\n          if (isWalletNamespaceSupported === false) throw e;\n          const error = e;\n          // If the transport does not support the method or input, attempt to use the\n          // `wallet_sendTransaction` method.\n          if (error.name === 'InvalidInputRpcError' || error.name === 'InvalidParamsRpcError' || error.name === 'MethodNotFoundRpcError' || error.name === 'MethodNotSupportedRpcError') {\n            return await client.request({\n              method: 'wallet_sendTransaction',\n              params: [request]\n            }, {\n              retryCount: 0\n            }).then(hash => {\n              supportsWalletNamespace.set(client.uid, true);\n              return hash;\n            }).catch(e => {\n              const walletNamespaceError = e;\n              if (walletNamespaceError.name === 'MethodNotFoundRpcError' || walletNamespaceError.name === 'MethodNotSupportedRpcError') {\n                supportsWalletNamespace.set(client.uid, false);\n                throw error;\n              }\n              throw walletNamespaceError;\n            });\n          }\n          throw error;\n        }\n      })();\n      const receipt = await getAction(client, waitForTransactionReceipt, 'waitForTransactionReceipt')({\n        checkReplacement: false,\n        hash,\n        pollingInterval,\n        timeout\n      });\n      if (throwOnReceiptRevert && receipt.status === 'reverted') throw new TransactionReceiptRevertedError({\n        receipt\n      });\n      return receipt;\n    }\n    if ((account === null || account === void 0 ? void 0 : account.type) === 'local') {\n      var _chain$serializers;\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(client, prepareTransactionRequest, 'prepareTransactionRequest')(_objectSpread(_objectSpread({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value\n      }, rest), {}, {\n        to\n      }));\n      const serializer = chain === null || chain === void 0 || (_chain$serializers = chain.serializers) === null || _chain$serializers === void 0 ? void 0 : _chain$serializers.transaction;\n      const serializedTransaction = await account.signTransaction(request, {\n        serializer\n      });\n      return await getAction(client, sendRawTransactionSync, 'sendRawTransactionSync')({\n        serializedTransaction,\n        throwOnReceiptRevert\n      });\n    }\n    if ((account === null || account === void 0 ? void 0 : account.type) === 'smart') throw new AccountTypeNotSupportedError({\n      metaMessages: ['Consider using the `sendUserOperation` Action instead.'],\n      docsPath: '/docs/actions/bundler/sendUserOperation',\n      type: 'smart'\n    });\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n      type: account === null || account === void 0 ? void 0 : account.type\n    });\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err;\n    throw getTransactionError(err, _objectSpread(_objectSpread({}, parameters), {}, {\n      account,\n      chain: parameters.chain || undefined\n    }));\n  }\n}","map":{"version":3,"names":["parseAccount","AccountNotFoundError","AccountTypeNotSupportedError","BaseError","TransactionReceiptRevertedError","recoverAuthorizationAddress","assertCurrentChain","getTransactionError","extract","formatTransactionRequest","getAction","LruMap","assertRequest","getChainId","waitForTransactionReceipt","defaultParameters","prepareTransactionRequest","sendRawTransactionSync","supportsWalletNamespace","sendTransactionSync","client","parameters","_parameters$timeout","_chain$blockTime","account","account_","chain","accessList","authorizationList","blobs","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","pollingInterval","throwOnReceiptRevert","type","value","rest","_objectWithoutProperties","_excluded","timeout","Math","max","blockTime","docsPath","to","undefined","length","authorization","catch","_client$chain","chainId","currentChainId","chainFormat","formatters","transactionRequest","format","request","_objectSpread","from","address","isWalletNamespaceSupported","get","uid","method","hash","params","retryCount","e","error","name","then","set","walletNamespaceError","receipt","checkReplacement","status","_chain$serializers","nonceManager","serializer","serializers","transaction","serializedTransaction","signTransaction","metaMessages","err"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/viem/actions/wallet/sendTransactionSync.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { SignTransactionErrorType } from '../../accounts/utils/signTransaction.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  AccountNotFoundError,\n  type AccountNotFoundErrorType,\n  AccountTypeNotSupportedError,\n  type AccountTypeNotSupportedErrorType,\n} from '../../errors/account.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  TransactionReceiptRevertedError,\n  type TransactionReceiptRevertedErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { GetAccountParameter } from '../../types/account.js'\nimport type {\n  Chain,\n  DeriveChain,\n  GetChainParameter,\n} from '../../types/chain.js'\nimport type { GetTransactionRequestKzgParameter } from '../../types/kzg.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { UnionOmit } from '../../types/utils.js'\nimport {\n  type RecoverAuthorizationAddressErrorType,\n  recoverAuthorizationAddress,\n} from '../../utils/authorization/recoverAuthorizationAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type AssertCurrentChainErrorType,\n  assertCurrentChain,\n} from '../../utils/chain/assertCurrentChain.js'\nimport {\n  type GetTransactionErrorReturnType,\n  getTransactionError,\n} from '../../utils/errors/getTransactionError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { LruMap } from '../../utils/lru.js'\nimport {\n  type AssertRequestErrorType,\n  type AssertRequestParameters,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\nimport { type GetChainIdErrorType, getChainId } from '../public/getChainId.js'\nimport {\n  type WaitForTransactionReceiptErrorType,\n  waitForTransactionReceipt,\n} from '../public/waitForTransactionReceipt.js'\nimport {\n  defaultParameters,\n  type PrepareTransactionRequestErrorType,\n  prepareTransactionRequest,\n} from './prepareTransactionRequest.js'\nimport {\n  type SendRawTransactionSyncErrorType,\n  type SendRawTransactionSyncReturnType,\n  sendRawTransactionSync,\n} from './sendRawTransactionSync.js'\n\nconst supportsWalletNamespace = new LruMap<boolean>(128)\n\nexport type SendTransactionSyncRequest<\n  chain extends Chain | undefined = Chain | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  ///\n  _derivedChain extends Chain | undefined = DeriveChain<chain, chainOverride>,\n> = UnionOmit<FormattedTransactionRequest<_derivedChain>, 'from'> &\n  GetTransactionRequestKzgParameter\n\nexport type SendTransactionSyncParameters<\n  chain extends Chain | undefined = Chain | undefined,\n  account extends Account | undefined = Account | undefined,\n  chainOverride extends Chain | undefined = Chain | undefined,\n  request extends SendTransactionSyncRequest<\n    chain,\n    chainOverride\n  > = SendTransactionSyncRequest<chain, chainOverride>,\n> = request &\n  GetAccountParameter<account, Account | Address, true, true> &\n  GetChainParameter<chain, chainOverride> &\n  GetTransactionRequestKzgParameter<request> & {\n    /** Polling interval (ms) to poll for the transaction receipt. @default client.pollingInterval */\n    pollingInterval?: number | undefined\n    /** Whether to throw an error if the transaction was detected as reverted. @default true */\n    throwOnReceiptRevert?: boolean | undefined\n    /** Timeout (ms) to wait for a response. @default Math.max(chain.blockTime * 3, 5_000) */\n    timeout?: number | undefined\n  }\n\nexport type SendTransactionSyncReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = SendRawTransactionSyncReturnType<chain>\n\nexport type SendTransactionSyncErrorType =\n  | ParseAccountErrorType\n  | GetTransactionErrorReturnType<\n      | AccountNotFoundErrorType\n      | AccountTypeNotSupportedErrorType\n      | AssertCurrentChainErrorType\n      | AssertRequestErrorType\n      | GetChainIdErrorType\n      | PrepareTransactionRequestErrorType\n      | SendRawTransactionSyncErrorType\n      | RecoverAuthorizationAddressErrorType\n      | SignTransactionErrorType\n      | TransactionReceiptRevertedErrorType\n      | RequestErrorType\n    >\n  | WaitForTransactionReceiptErrorType\n  | ErrorType\n\n/**\n * Creates, signs, and sends a new transaction to the network synchronously.\n * Returns the transaction receipt.\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionSyncParameters}\n * @returns The transaction receipt. {@link SendTransactionSyncReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransactionSync } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const receipt = await sendTransactionSync(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransactionSync<\n  chain extends Chain | undefined,\n  account extends Account | undefined,\n  const request extends SendTransactionSyncRequest<chain, chainOverride>,\n  chainOverride extends Chain | undefined = undefined,\n>(\n  client: Client<Transport, chain, account>,\n  parameters: SendTransactionSyncParameters<\n    chain,\n    account,\n    chainOverride,\n    request\n  >,\n): Promise<SendTransactionSyncReturnType<chain>> {\n  const {\n    account: account_ = client.account,\n    chain = client.chain,\n    accessList,\n    authorizationList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    pollingInterval,\n    throwOnReceiptRevert,\n    type,\n    value,\n    ...rest\n  } = parameters\n  const timeout =\n    parameters.timeout ?? Math.max((chain?.blockTime ?? 0) * 3, 5_000)\n\n  if (typeof account_ === 'undefined')\n    throw new AccountNotFoundError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n    })\n  const account = account_ ? parseAccount(account_) : null\n\n  try {\n    assertRequest(parameters as AssertRequestParameters)\n\n    const to = await (async () => {\n      // If `to` exists on the parameters, use that.\n      if (parameters.to) return parameters.to\n\n      // If `to` is null, we are sending a deployment transaction.\n      if (parameters.to === null) return undefined\n\n      // If no `to` exists, and we are sending a EIP-7702 transaction, use the\n      // address of the first authorization in the list.\n      if (authorizationList && authorizationList.length > 0)\n        return await recoverAuthorizationAddress({\n          authorization: authorizationList[0],\n        }).catch(() => {\n          throw new BaseError(\n            '`to` is required. Could not infer from `authorizationList`.',\n          )\n        })\n\n      // Otherwise, we are sending a deployment transaction.\n      return undefined\n    })()\n\n    if (account?.type === 'json-rpc' || account === null) {\n      let chainId: number | undefined\n      if (chain !== null) {\n        chainId = await getAction(client, getChainId, 'getChainId')({})\n        assertCurrentChain({\n          currentChainId: chainId,\n          chain,\n        })\n      }\n\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format\n      const format = chainFormat || formatTransactionRequest\n\n      const request = format(\n        {\n          // Pick out extra data that might exist on the chain's transaction request type.\n          ...extract(rest, { format: chainFormat }),\n          accessList,\n          authorizationList,\n          blobs,\n          chainId,\n          data,\n          from: account?.address,\n          gas,\n          gasPrice,\n          maxFeePerBlobGas,\n          maxFeePerGas,\n          maxPriorityFeePerGas,\n          nonce,\n          to,\n          type,\n          value,\n        } as TransactionRequest,\n        'sendTransaction',\n      )\n\n      const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid)\n      const method = isWalletNamespaceSupported\n        ? 'wallet_sendTransaction'\n        : 'eth_sendTransaction'\n\n      const hash = await (async () => {\n        try {\n          return await client.request(\n            {\n              method,\n              params: [request],\n            },\n            { retryCount: 0 },\n          )\n        } catch (e) {\n          if (isWalletNamespaceSupported === false) throw e\n\n          const error = e as BaseError\n          // If the transport does not support the method or input, attempt to use the\n          // `wallet_sendTransaction` method.\n          if (\n            error.name === 'InvalidInputRpcError' ||\n            error.name === 'InvalidParamsRpcError' ||\n            error.name === 'MethodNotFoundRpcError' ||\n            error.name === 'MethodNotSupportedRpcError'\n          ) {\n            return (await client\n              .request(\n                {\n                  method: 'wallet_sendTransaction',\n                  params: [request],\n                },\n                { retryCount: 0 },\n              )\n              .then((hash) => {\n                supportsWalletNamespace.set(client.uid, true)\n                return hash\n              })\n              .catch((e) => {\n                const walletNamespaceError = e as BaseError\n                if (\n                  walletNamespaceError.name === 'MethodNotFoundRpcError' ||\n                  walletNamespaceError.name === 'MethodNotSupportedRpcError'\n                ) {\n                  supportsWalletNamespace.set(client.uid, false)\n                  throw error\n                }\n\n                throw walletNamespaceError\n              })) as never\n          }\n\n          throw error\n        }\n      })()\n\n      const receipt = await getAction(\n        client,\n        waitForTransactionReceipt,\n        'waitForTransactionReceipt',\n      )({\n        checkReplacement: false,\n        hash,\n        pollingInterval,\n        timeout,\n      })\n      if (throwOnReceiptRevert && receipt.status === 'reverted')\n        throw new TransactionReceiptRevertedError({ receipt })\n      return receipt\n    }\n\n    if (account?.type === 'local') {\n      // Prepare the request for signing (assign appropriate fees, etc.)\n      const request = await getAction(\n        client,\n        prepareTransactionRequest,\n        'prepareTransactionRequest',\n      )({\n        account,\n        accessList,\n        authorizationList,\n        blobs,\n        chain,\n        data,\n        gas,\n        gasPrice,\n        maxFeePerBlobGas,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce,\n        nonceManager: account.nonceManager,\n        parameters: [...defaultParameters, 'sidecars'],\n        type,\n        value,\n        ...rest,\n        to,\n      } as any)\n\n      const serializer = chain?.serializers?.transaction\n      const serializedTransaction = (await account.signTransaction(request, {\n        serializer,\n      })) as Hash\n      return (await getAction(\n        client,\n        sendRawTransactionSync,\n        'sendRawTransactionSync',\n      )({\n        serializedTransaction,\n        throwOnReceiptRevert,\n      })) as never\n    }\n\n    if (account?.type === 'smart')\n      throw new AccountTypeNotSupportedError({\n        metaMessages: [\n          'Consider using the `sendUserOperation` Action instead.',\n        ],\n        docsPath: '/docs/actions/bundler/sendUserOperation',\n        type: 'smart',\n      })\n\n    throw new AccountTypeNotSupportedError({\n      docsPath: '/docs/actions/wallet/sendTransactionSync',\n      type: (account as any)?.type,\n    })\n  } catch (err) {\n    if (err instanceof AccountTypeNotSupportedError) throw err\n    throw getTransactionError(err as BaseError, {\n      ...parameters,\n      account,\n      chain: parameters.chain || undefined,\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}