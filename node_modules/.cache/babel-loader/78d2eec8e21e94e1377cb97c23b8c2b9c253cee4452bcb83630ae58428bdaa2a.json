{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as AbiParameters from './AbiParameters.js';\nimport * as Address from './Address.js';\nimport * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Json from './Json.js';\nimport * as Solidity from './Solidity.js';\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert(value) {\n  const {\n    domain,\n    message,\n    primaryType,\n    types\n  } = value;\n  const validateData = (struct, data) => {\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      const value = data[name];\n      const integerMatch = type.match(Solidity.integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [, base, size_] = integerMatch;\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ !== null && size_ !== void 0 ? size_ : '', 10) / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !Address.validate(value)) throw new Address.InvalidAddressError({\n        address: value,\n        cause: new Address.InvalidInputError()\n      });\n      const bytesMatch = type.match(Solidity.bytesRegex);\n      if (bytesMatch) {\n        const [, size] = bytesMatch;\n        if (size && Hex.size(value) !== Number.parseInt(size, 10)) throw new BytesSizeMismatchError({\n          expectedSize: Number.parseInt(size, 10),\n          givenSize: Hex.size(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) {\n        validateReference(type);\n        validateData(struct, value);\n      }\n    }\n  };\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({\n      domain\n    });\n    validateData(types.EIP712Domain, domain);\n  }\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message);else throw new InvalidPrimaryTypeError({\n      primaryType,\n      types\n    });\n  }\n}\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain) {\n  return hashDomain({\n    domain\n  });\n}\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode(value) {\n  const {\n    domain = {},\n    message,\n    primaryType\n  } = value;\n  const types = _objectSpread({\n    EIP712Domain: extractEip712DomainTypes(domain)\n  }, value.types);\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types\n  });\n  // Typed Data Format: `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`\n  const parts = ['0x19', '0x01'];\n  if (domain) parts.push(hashDomain({\n    domain,\n    types\n  }));\n  if (primaryType !== 'EIP712Domain') parts.push(hashStruct({\n    data: message,\n    primaryType,\n    types\n  }));\n  return Hex.concat(...parts);\n}\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value) {\n  const {\n    primaryType,\n    types\n  } = value;\n  let result = '';\n  const unsortedDeps = findTypeDependencies({\n    primaryType,\n    types\n  });\n  unsortedDeps.delete(primaryType);\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\n  for (const type of deps) {\n    var _types$type;\n    result += \"\".concat(type, \"(\").concat(((_types$type = types[type]) !== null && _types$type !== void 0 ? _types$type : []).map(_ref => {\n      let {\n        name,\n        type: t\n      } = _ref;\n      return \"\".concat(t, \" \").concat(name);\n    }).join(','), \")\");\n  }\n  return result;\n}\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(domain) {\n  return [typeof (domain === null || domain === void 0 ? void 0 : domain.name) === 'string' && {\n    name: 'name',\n    type: 'string'\n  }, (domain === null || domain === void 0 ? void 0 : domain.version) && {\n    name: 'version',\n    type: 'string'\n  }, (typeof (domain === null || domain === void 0 ? void 0 : domain.chainId) === 'number' || typeof (domain === null || domain === void 0 ? void 0 : domain.chainId) === 'bigint') && {\n    name: 'chainId',\n    type: 'uint256'\n  }, (domain === null || domain === void 0 ? void 0 : domain.verifyingContract) && {\n    name: 'verifyingContract',\n    type: 'address'\n  }, (domain === null || domain === void 0 ? void 0 : domain.salt) && {\n    name: 'salt',\n    type: 'bytes32'\n  }].filter(Boolean);\n}\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(value) {\n  return Hash.keccak256(encode(value));\n}\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value) {\n  const {\n    domain,\n    types\n  } = value;\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: _objectSpread(_objectSpread({}, types), {}, {\n      EIP712Domain: (types === null || types === void 0 ? void 0 : types.EIP712Domain) || extractEip712DomainTypes(domain)\n    })\n  });\n}\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value) {\n  const {\n    data,\n    primaryType,\n    types\n  } = value;\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types\n  });\n  return Hash.keccak256(encoded);\n}\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize(value) {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types\n  } = value;\n  const normalizeData = (struct, value) => {\n    const data = _objectSpread({}, value);\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      if (type === 'address') data[name] = data[name].toLowerCase();\n    }\n    return data;\n  };\n  const domain = (_types$EIP712Domain => {\n    if (!domain_) return {};\n    const type = (_types$EIP712Domain = types.EIP712Domain) !== null && _types$EIP712Domain !== void 0 ? _types$EIP712Domain : extractEip712DomainTypes(domain_);\n    return normalizeData(type, domain_);\n  })();\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined;\n    if (!types[primaryType]) return {};\n    return normalizeData(types[primaryType], message_);\n  })();\n  return Json.stringify({\n    domain,\n    message,\n    primaryType,\n    types\n  }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString();\n    return value;\n  });\n}\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate(value) {\n  try {\n    assert(value);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      expectedSize,\n      givenSize\n    } = _ref2;\n    super(\"Expected bytes\".concat(expectedSize, \", got bytes\").concat(givenSize, \".\"));\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.BytesSizeMismatchError'\n    });\n  }\n}\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      domain\n    } = _ref3;\n    super(\"Invalid domain \\\"\".concat(Json.stringify(domain), \"\\\".\"), {\n      metaMessages: ['Must be a valid EIP-712 domain.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.InvalidDomainError'\n    });\n  }\n}\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  constructor(_ref4) {\n    let {\n      primaryType,\n      types\n    } = _ref4;\n    super(\"Invalid primary type `\".concat(primaryType, \"` must be one of `\").concat(JSON.stringify(Object.keys(types)), \"`.\"), {\n      metaMessages: ['Check that the primary type is a key in `types`.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.InvalidPrimaryTypeError'\n    });\n  }\n}\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  constructor(_ref5) {\n    let {\n      type\n    } = _ref5;\n    super(\"Struct type \\\"\".concat(type, \"\\\" is invalid.\"), {\n      metaMessages: ['Struct type must not be a Solidity type.']\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'TypedData.InvalidStructTypeError'\n    });\n  }\n}\n/** @internal */\nexport function encodeData(value) {\n  const {\n    data,\n    primaryType,\n    types\n  } = value;\n  const encodedTypes = [{\n    type: 'bytes32'\n  }];\n  const encodedValues = [hashType({\n    primaryType,\n    types\n  })];\n  for (const field of (_types$primaryType = types[primaryType]) !== null && _types$primaryType !== void 0 ? _types$primaryType : []) {\n    var _types$primaryType;\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name]\n    });\n    encodedTypes.push(type);\n    encodedValues.push(value);\n  }\n  return AbiParameters.encode(encodedTypes, encodedValues);\n}\n/** @internal */\nexport function hashType(value) {\n  const {\n    primaryType,\n    types\n  } = value;\n  const encodedHashType = Hex.fromString(encodeType({\n    primaryType,\n    types\n  }));\n  return Hash.keccak256(encodedHashType);\n}\n/** @internal */\nexport function encodeField(properties) {\n  let {\n    types,\n    name,\n    type,\n    value\n  } = properties;\n  if (types[type] !== undefined) return [{\n    type: 'bytes32'\n  }, Hash.keccak256(encodeData({\n    data: value,\n    primaryType: type,\n    types\n  }))];\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : '';\n    value = \"0x\".concat(prepend + value.slice(2));\n    return [{\n      type: 'bytes32'\n    }, Hash.keccak256(value, {\n      as: 'Hex'\n    })];\n  }\n  if (type === 'string') return [{\n    type: 'bytes32'\n  }, Hash.keccak256(Bytes.fromString(value), {\n    as: 'Hex'\n  })];\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['));\n    const typeValuePairs = value.map(item => encodeField({\n      name,\n      type: parsedType,\n      types,\n      value: item\n    }));\n    return [{\n      type: 'bytes32'\n    }, Hash.keccak256(AbiParameters.encode(typeValuePairs.map(_ref6 => {\n      let [t] = _ref6;\n      return t;\n    }), typeValuePairs.map(_ref7 => {\n      let [, v] = _ref7;\n      return v;\n    })))];\n  }\n  return [{\n    type\n  }, value];\n}\n/** @internal */\nexport function findTypeDependencies(value) {\n  let results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n  const {\n    primaryType: primaryType_,\n    types\n  } = value;\n  const match = primaryType_.match(/^[0-9A-Z_a-z]*/);\n  const primaryType = match === null || match === void 0 ? void 0 : match[0];\n  if (results.has(primaryType) || types[primaryType] === undefined) return results;\n  results.add(primaryType);\n  for (const field of types[primaryType]) findTypeDependencies({\n    primaryType: field.type,\n    types\n  }, results);\n  return results;\n}\n/** @internal */\nfunction validateReference(type) {\n  // Struct type must not be a Solidity type.\n  if (type === 'address' || type === 'bool' || type === 'string' || type.startsWith('bytes') || type.startsWith('uint') || type.startsWith('int')) throw new InvalidStructTypeError({\n    type\n  });\n}","map":{"version":3,"names":["AbiParameters","Address","Bytes","Errors","Hash","Hex","Json","Solidity","assert","value","domain","message","primaryType","types","validateData","struct","data","param","name","type","integerMatch","match","integerRegex","base","size_","fromNumber","signed","size","Number","parseInt","validate","InvalidAddressError","address","cause","InvalidInputError","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","givenSize","validateReference","EIP712Domain","InvalidDomainError","InvalidPrimaryTypeError","domainSeparator","hashDomain","encode","_objectSpread","extractEip712DomainTypes","parts","push","hashStruct","concat","encodeType","result","unsortedDeps","findTypeDependencies","delete","deps","Array","from","sort","_types$type","map","_ref","t","join","version","chainId","verifyingContract","salt","filter","Boolean","getSignPayload","keccak256","encoded","encodeData","serialize","domain_","message_","normalizeData","toLowerCase","_types$EIP712Domain","undefined","stringify","_","toString","_unused","BaseError","constructor","_ref2","Object","defineProperty","_ref3","metaMessages","_ref4","JSON","keys","InvalidStructTypeError","_ref5","encodedTypes","encodedValues","hashType","field","_types$primaryType","encodeField","encodedHashType","fromString","properties","prepend","length","slice","as","lastIndexOf","parsedType","typeValuePairs","item","_ref6","_ref7","v","results","arguments","Set","primaryType_","has","add","startsWith"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/TypedData.ts"],"sourcesContent":["import type * as abitype from 'abitype'\nimport * as AbiParameters from './AbiParameters.js'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\n\nexport type TypedData = abitype.TypedData\nexport type Domain = abitype.TypedDataDomain\nexport type Parameter = abitype.TypedDataParameter\n\n// TODO: Make reusable for Viem?\nexport type Definition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = primaryType extends 'EIP712Domain'\n  ? EIP712DomainDefinition<typedData, primaryType>\n  : MessageDefinition<typedData, primaryType, primaryTypes>\n\nexport type EIP712DomainDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends 'EIP712Domain' = 'EIP712Domain',\n  ///\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n> = {\n  types?: typedData | undefined\n} & {\n  primaryType:\n    | 'EIP712Domain'\n    | (primaryType extends 'EIP712Domain' ? primaryType : never)\n  domain: schema extends { EIP712Domain: infer domain }\n    ? domain\n    : Compute<Domain>\n  message?: undefined\n}\n\nexport type MessageDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n  message = schema[primaryType extends keyof schema\n    ? primaryType\n    : keyof schema],\n> = {\n  types: typedData\n} & {\n  primaryType:\n    | primaryTypes // show all values\n    | (primaryType extends primaryTypes ? primaryType : never) // infer value\n  domain?:\n    | (schema extends { EIP712Domain: infer domain } ? domain : Compute<Domain>)\n    | undefined\n  message: { [_: string]: any } extends message // Check if message was inferred\n    ? Record<string, unknown>\n    : message\n}\n\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): void {\n  const { domain, message, primaryType, types } =\n    value as unknown as assert.Value\n\n  const validateData = (\n    struct: readonly Parameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(Solidity.integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ ?? '', 10) / 8,\n        })\n      }\n\n      if (\n        type === 'address' &&\n        typeof value === 'string' &&\n        !Address.validate(value)\n      )\n        throw new Address.InvalidAddressError({\n          address: value,\n          cause: new Address.InvalidInputError(),\n        })\n\n      const bytesMatch = type.match(Solidity.bytesRegex)\n      if (bytesMatch) {\n        const [, size] = bytesMatch\n        if (size && Hex.size(value as Hex.Hex) !== Number.parseInt(size, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size, 10),\n            givenSize: Hex.size(value as Hex.Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport declare namespace assert {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | Address.InvalidAddressError\n    | BytesSizeMismatchError\n    | InvalidPrimaryTypeError\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain: Domain): Hex.Hex {\n  return hashDomain({\n    domain,\n  })\n}\n\nexport declare namespace domainSeparator {\n  type ErrorType = hashDomain.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  const { domain = {}, message, primaryType } = value as encode.Value\n\n  const types = {\n    EIP712Domain: extractEip712DomainTypes(domain),\n    ...value.types,\n  } as TypedData\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  // Typed Data Format: `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`\n  const parts: Hex.Hex[] = ['0x19', '0x01']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types,\n      }),\n    )\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types,\n      }),\n    )\n\n  return Hex.concat(...parts)\n}\n\nexport declare namespace encode {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | extractEip712DomainTypes.ErrorType\n    | hashDomain.ErrorType\n    | hashStruct.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value: encodeType.Value): string {\n  const { primaryType, types } = value\n\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${(types[type] ?? [])\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nexport declare namespace encodeType {\n  type Value = {\n    primaryType: string\n    types: TypedData\n  }\n\n  type ErrorType = findTypeDependencies.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(\n  domain: Domain | undefined,\n): Parameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as Parameter[]\n}\n\nexport declare namespace extractEip712DomainTypes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value: hashDomain.Value): Hex.Hex {\n  const { domain, types } = value\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: {\n      ...types,\n      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain),\n    },\n  })\n}\n\nexport declare namespace hashDomain {\n  type Value = {\n    /** The Typed Data domain. */\n    domain: Domain\n    /** The Typed Data types. */\n    types?:\n      | {\n          EIP712Domain?: readonly Parameter[] | undefined\n          [key: string]: readonly Parameter[] | undefined\n        }\n      | undefined\n  }\n\n  type ErrorType = hashStruct.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value: hashStruct.Value): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return Hash.keccak256(encoded)\n}\n\nexport declare namespace hashStruct {\n  type Value = {\n    /** The Typed Data struct to hash. */\n    data: Record<string, unknown>\n    /** The primary type of the Typed Data struct. */\n    primaryType: string\n    /** The types of the Typed Data struct. */\n    types: TypedData\n  }\n\n  type ErrorType =\n    | encodeData.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: serialize.Value<typedData, primaryType>): string {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = value as unknown as serialize.Value\n\n  const normalizeData = (\n    struct: readonly Parameter[],\n    value: Record<string, unknown>,\n  ) => {\n    const data = { ...value }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!domain_) return {}\n    const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_)\n    return normalizeData(type, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    if (!types[primaryType]) return {}\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return Json.stringify({ domain, message, primaryType, types }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\nexport declare namespace serialize {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType = Json.stringify.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'TypedData.BytesSizeMismatchError'\n\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidDomainError'\n\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${Json.stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidPrimaryTypeError'\n\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidStructTypeError'\n\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n    })\n  }\n}\n\n/** @internal */\nexport function encodeData(value: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encodedTypes: AbiParameters.Parameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType] ?? []) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return AbiParameters.encode(encodedTypes, encodedValues)\n}\n\n/** @internal */\nexport declare namespace encodeData {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | encodeField.ErrorType\n    | hashType.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function hashType(value: {\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { primaryType, types } = value\n  const encodedHashType = Hex.fromString(encodeType({ primaryType, types }))\n  return Hash.keccak256(encodedHashType)\n}\n\n/** @internal */\nexport declare namespace hashType {\n  type ErrorType =\n    | Hex.fromString.ErrorType\n    | encodeType.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeField(properties: {\n  types: TypedData\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameters.Parameter, value: Hex.Hex] {\n  let { types, name, type, value } = properties\n\n  if (types[type] !== undefined)\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, Hash.keccak256(value, { as: 'Hex' })]\n  }\n\n  if (type === 'string')\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(Bytes.fromString(value), { as: 'Hex' }),\n    ]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameters.Parameter, any][]).map(\n      (item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n    )\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(\n        AbiParameters.encode(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n\n/** @internal */\nexport declare namespace encodeField {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function findTypeDependencies(\n  value: {\n    primaryType: string\n    types: TypedData\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const { primaryType: primaryType_, types } = value\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined)\n    return results\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType])\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  return results\n}\n\n/** @internal */\nexport declare namespace findTypeDependencies {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}