{"ast":null,"code":"/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { ghash, polyval } from \"./_polyval.js\";\n// prettier-ignore\nimport { abytes, clean, complexOverlapBytes, concatBytes, copyBytes, createView, equalBytes, getOutput, isAligned32, overlapBytes, setBigUint64, u32, u64Lengths, u8, wrapCipher } from \"./utils.js\";\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n  return n << 1 ^ POLY & -(n >> 7);\n}\nfunction mul(a, b) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */(() => {\n  const t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 0x63) & 0xff;\n  }\n  clean(t);\n  return box;\n})();\n// Inverted S-box\nconst invSbox = /* @__PURE__ */sbox.map((_, j) => sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = n => n << 24 | n >>> 8;\nconst rotl32_8 = n => n << 8 | n >>> 24;\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = word => word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = sbox[i] << 8 | sbox[j];\n    }\n  }\n  return {\n    sbox,\n    sbox2,\n    T0,\n    T1,\n    T2,\n    T3,\n    T01,\n    T23\n  };\n}\nconst tableEncoding = /* @__PURE__ */genTtable(sbox, s => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));\nconst tableDecoding = /* @__PURE__ */genTtable(invSbox, s => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));\nconst xPowers = /* @__PURE__ */(() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key) {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len)) throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n  const {\n    sbox2\n  } = tableEncoding;\n  const toClean = [];\n  if (!isAligned32(key)) toClean.push(key = copyBytes(key));\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = n => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  clean(...toClean);\n  return xk;\n}\nfunction expandKeyDecLE(key) {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const {\n    sbox2\n  } = tableEncoding;\n  const {\n    T0,\n    T1,\n    T2,\n    T3\n  } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  clean(encKey);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[w >>> 8 & 0xff] ^ T2[w >>> 16 & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n  return T01[s0 << 8 & 0xff00 | s1 >>> 8 & 0xff] ^ T23[s2 >>> 8 & 0xff00 | s3 >>> 24 & 0xff];\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n  return sbox2[s0 & 0xff | s1 & 0xff00] | sbox2[s2 >>> 16 & 0xff | s3 >>> 16 & 0xff00] << 16;\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n  const {\n    sbox2,\n    T01,\n    T23\n  } = tableEncoding;\n  let k = 0;\n  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return {\n    s0: t0,\n    s1: t1,\n    s2: t2,\n    s3: t3\n  };\n}\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(xk, s0, s1, s2, s3) {\n  const {\n    sbox2,\n    T01,\n    T23\n  } = tableDecoding;\n  let k = 0;\n  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    s0 = t0, s1 = t1, s2 = t2, s3 = t3;\n  }\n  // Last round\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return {\n    s0: t0,\n    s1: t1,\n    s2: t2,\n    s3: t3\n  };\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getOutput(srcLen, dst);\n  complexOverlapBytes(src, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let {\n    s0,\n    s1,\n    s2,\n    s3\n  } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = carry + (ctr[i] & 0xff) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({\n      s0,\n      s1,\n      s2,\n      s3\n    } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getOutput(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let {\n    s0,\n    s1,\n    s2,\n    s3\n  } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = ctrNum + 1 >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({\n      s0,\n      s1,\n      s2,\n      s3\n    } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr = /* @__PURE__ */wrapCipher({\n  blockSize: 16,\n  nonceLength: 16\n}, function aesctr(key, nonce) {\n  function processCtr(buf, dst) {\n    abytes(buf);\n    if (dst !== undefined) {\n      abytes(dst);\n      if (!isAligned32(dst)) throw new Error('unaligned destination');\n    }\n    const xk = expandKeyLE(key);\n    const n = copyBytes(nonce); // align + avoid changing\n    const toClean = [xk, n];\n    if (!isAligned32(buf)) toClean.push(buf = copyBytes(buf));\n    const out = ctrCounter(xk, n, buf, dst);\n    clean(...toClean);\n    return out;\n  }\n  return {\n    encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)\n  };\n});\nfunction validateBlockDecrypt(data) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error('aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE);\n  }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n  abytes(plaintext);\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0) throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  if (!isAligned32(plaintext)) plaintext = copyBytes(plaintext);\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  dst = getOutput(outLen, dst);\n  complexOverlapBytes(plaintext, dst);\n  const o = u32(dst);\n  return {\n    b,\n    o,\n    out: dst\n  };\n}\nfunction validatePCKS(data, pcks5) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error('aes/pcks5: empty ciphertext not allowed');\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error('aes/pcks5: wrong padding');\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++) if (data[len - i - 1] !== lastByte) throw new Error('aes/pcks5: wrong padding');\n  return out;\n}\nfunction padPCKS(left) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb = /* @__PURE__ */wrapCipher({\n  blockSize: 16\n}, function aesecb(key, opts = {}) {\n  const pcks5 = !opts.disablePadding;\n  return {\n    encrypt(plaintext, dst) {\n      const {\n        b,\n        o,\n        out: _out\n      } = validateBlockEncrypt(plaintext, pcks5, dst);\n      const xk = expandKeyLE(key);\n      let i = 0;\n      for (; i + 4 <= b.length;) {\n        const {\n          s0,\n          s1,\n          s2,\n          s3\n        } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n      }\n      if (pcks5) {\n        const tmp32 = padPCKS(plaintext.subarray(i * 4));\n        const {\n          s0,\n          s1,\n          s2,\n          s3\n        } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n      }\n      clean(xk);\n      return _out;\n    },\n    decrypt(ciphertext, dst) {\n      validateBlockDecrypt(ciphertext);\n      const xk = expandKeyDecLE(key);\n      dst = getOutput(ciphertext.length, dst);\n      const toClean = [xk];\n      if (!isAligned32(ciphertext)) toClean.push(ciphertext = copyBytes(ciphertext));\n      complexOverlapBytes(ciphertext, dst);\n      const b = u32(ciphertext);\n      const o = u32(dst);\n      for (let i = 0; i + 4 <= b.length;) {\n        const {\n          s0,\n          s1,\n          s2,\n          s3\n        } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n      }\n      clean(...toClean);\n      return validatePCKS(dst, pcks5);\n    }\n  };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous roundâ€™s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc = /* @__PURE__ */wrapCipher({\n  blockSize: 16,\n  nonceLength: 16\n}, function aescbc(key, iv, opts = {}) {\n  const pcks5 = !opts.disablePadding;\n  return {\n    encrypt(plaintext, dst) {\n      const xk = expandKeyLE(key);\n      const {\n        b,\n        o,\n        out: _out\n      } = validateBlockEncrypt(plaintext, pcks5, dst);\n      let _iv = iv;\n      const toClean = [xk];\n      if (!isAligned32(_iv)) toClean.push(_iv = copyBytes(_iv));\n      const n32 = u32(_iv);\n      // prettier-ignore\n      let s0 = n32[0],\n        s1 = n32[1],\n        s2 = n32[2],\n        s3 = n32[3];\n      let i = 0;\n      for (; i + 4 <= b.length;) {\n        s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];\n        ({\n          s0,\n          s1,\n          s2,\n          s3\n        } = encrypt(xk, s0, s1, s2, s3));\n        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n      }\n      if (pcks5) {\n        const tmp32 = padPCKS(plaintext.subarray(i * 4));\n        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];\n        ({\n          s0,\n          s1,\n          s2,\n          s3\n        } = encrypt(xk, s0, s1, s2, s3));\n        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;\n      }\n      clean(...toClean);\n      return _out;\n    },\n    decrypt(ciphertext, dst) {\n      validateBlockDecrypt(ciphertext);\n      const xk = expandKeyDecLE(key);\n      let _iv = iv;\n      const toClean = [xk];\n      if (!isAligned32(_iv)) toClean.push(_iv = copyBytes(_iv));\n      const n32 = u32(_iv);\n      dst = getOutput(ciphertext.length, dst);\n      if (!isAligned32(ciphertext)) toClean.push(ciphertext = copyBytes(ciphertext));\n      complexOverlapBytes(ciphertext, dst);\n      const b = u32(ciphertext);\n      const o = u32(dst);\n      // prettier-ignore\n      let s0 = n32[0],\n        s1 = n32[1],\n        s2 = n32[2],\n        s3 = n32[3];\n      for (let i = 0; i + 4 <= b.length;) {\n        // prettier-ignore\n        const ps0 = s0,\n          ps1 = s1,\n          ps2 = s2,\n          ps3 = s3;\n        s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];\n        const {\n          s0: o0,\n          s1: o1,\n          s2: o2,\n          s3: o3\n        } = decrypt(xk, s0, s1, s2, s3);\n        o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;\n      }\n      clean(...toClean);\n      return validatePCKS(dst, pcks5);\n    }\n  };\n});\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb = /* @__PURE__ */wrapCipher({\n  blockSize: 16,\n  nonceLength: 16\n}, function aescfb(key, iv) {\n  function processCfb(src, isEncrypt, dst) {\n    abytes(src);\n    const srcLen = src.length;\n    dst = getOutput(srcLen, dst);\n    if (overlapBytes(src, dst)) throw new Error('overlapping src and dst not supported.');\n    const xk = expandKeyLE(key);\n    let _iv = iv;\n    const toClean = [xk];\n    if (!isAligned32(_iv)) toClean.push(_iv = copyBytes(_iv));\n    if (!isAligned32(src)) toClean.push(src = copyBytes(src));\n    const src32 = u32(src);\n    const dst32 = u32(dst);\n    const next32 = isEncrypt ? dst32 : src32;\n    const n32 = u32(_iv);\n    // prettier-ignore\n    let s0 = n32[0],\n      s1 = n32[1],\n      s2 = n32[2],\n      s3 = n32[3];\n    for (let i = 0; i + 4 <= src32.length;) {\n      const {\n        s0: e0,\n        s1: e1,\n        s2: e2,\n        s3: e3\n      } = encrypt(xk, s0, s1, s2, s3);\n      dst32[i + 0] = src32[i + 0] ^ e0;\n      dst32[i + 1] = src32[i + 1] ^ e1;\n      dst32[i + 2] = src32[i + 2] ^ e2;\n      dst32[i + 3] = src32[i + 3] ^ e3;\n      s0 = next32[i++], s1 = next32[i++], s2 = next32[i++], s3 = next32[i++];\n    }\n    // leftovers (less than block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n      ({\n        s0,\n        s1,\n        s2,\n        s3\n      } = encrypt(xk, s0, s1, s2, s3));\n      const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n      for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n      clean(buf);\n    }\n    clean(...toClean);\n    return dst;\n  }\n  return {\n    encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),\n    decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst)\n  };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n  const aadLength = AAD ? AAD.length : 0;\n  const h = fn.create(key, data.length + aadLength);\n  if (AAD) h.update(AAD);\n  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE);\n  h.update(data);\n  h.update(num);\n  const res = h.digest();\n  clean(num);\n  return res;\n}\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm = /* @__PURE__ */wrapCipher({\n  blockSize: 16,\n  nonceLength: 12,\n  tagLength: 16,\n  varSizeNonce: true\n}, function aesgcm(key, nonce, AAD) {\n  // NIST 800-38d doesn't enforce minimum nonce length.\n  // We enforce 8 bytes for compat with openssl.\n  // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n  if (nonce.length < 8) throw new Error('aes/gcm: invalid nonce length');\n  const tagLength = 16;\n  function _computeTag(authKey, tagMask, data) {\n    const tag = computeTag(ghash, false, authKey, data, AAD);\n    for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n    return tag;\n  }\n  function deriveKeys() {\n    const xk = expandKeyLE(key);\n    const authKey = EMPTY_BLOCK.slice();\n    const counter = EMPTY_BLOCK.slice();\n    ctr32(xk, false, counter, counter, authKey);\n    // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n    if (nonce.length === 12) {\n      counter.set(nonce);\n    } else {\n      const nonceLen = EMPTY_BLOCK.slice();\n      const view = createView(nonceLen);\n      setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n      // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n      const g = ghash.create(authKey).update(nonce).update(nonceLen);\n      g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n      g.destroy();\n    }\n    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n    return {\n      xk,\n      authKey,\n      counter,\n      tagMask\n    };\n  }\n  return {\n    encrypt(plaintext) {\n      const {\n        xk,\n        authKey,\n        counter,\n        tagMask\n      } = deriveKeys();\n      const out = new Uint8Array(plaintext.length + tagLength);\n      const toClean = [xk, authKey, counter, tagMask];\n      if (!isAligned32(plaintext)) toClean.push(plaintext = copyBytes(plaintext));\n      ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n      toClean.push(tag);\n      out.set(tag, plaintext.length);\n      clean(...toClean);\n      return out;\n    },\n    decrypt(ciphertext) {\n      const {\n        xk,\n        authKey,\n        counter,\n        tagMask\n      } = deriveKeys();\n      const toClean = [xk, authKey, tagMask, counter];\n      if (!isAligned32(ciphertext)) toClean.push(ciphertext = copyBytes(ciphertext));\n      const data = ciphertext.subarray(0, -tagLength);\n      const passedTag = ciphertext.subarray(-tagLength);\n      const tag = _computeTag(authKey, tagMask, data);\n      toClean.push(tag);\n      if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n      const out = ctr32(xk, false, counter, data);\n      clean(...toClean);\n      return out;\n    }\n  };\n});\nconst limit = (name, min, max) => value => {\n  if (!Number.isSafeInteger(value) || min > value || value > max) {\n    const minmax = '[' + min + '..' + max + ']';\n    throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n  }\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const gcmsiv = /* @__PURE__ */wrapCipher({\n  blockSize: 16,\n  nonceLength: 12,\n  tagLength: 16,\n  varSizeNonce: true\n}, function aessiv(key, nonce, AAD) {\n  const tagLength = 16;\n  // From RFC 8452: Section 6\n  const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n  const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n  const NONCE_LIMIT = limit('nonce', 12, 12);\n  const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n  abytes(key, 16, 24, 32);\n  NONCE_LIMIT(nonce.length);\n  if (AAD !== undefined) AAD_LIMIT(AAD.length);\n  function deriveKeys() {\n    const xk = expandKeyLE(key);\n    const encKey = new Uint8Array(key.length);\n    const authKey = new Uint8Array(16);\n    const toClean = [xk, encKey];\n    let _nonce = nonce;\n    if (!isAligned32(_nonce)) toClean.push(_nonce = copyBytes(_nonce));\n    const n32 = u32(_nonce);\n    // prettier-ignore\n    let s0 = 0,\n      s1 = n32[0],\n      s2 = n32[1],\n      s3 = n32[2];\n    let counter = 0;\n    for (const derivedKey of [authKey, encKey].map(u32)) {\n      const d32 = u32(derivedKey);\n      for (let i = 0; i < d32.length; i += 2) {\n        // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n        const {\n          s0: o0,\n          s1: o1\n        } = encrypt(xk, s0, s1, s2, s3);\n        d32[i + 0] = o0;\n        d32[i + 1] = o1;\n        s0 = ++counter; // increment counter inside state\n      }\n    }\n    const res = {\n      authKey,\n      encKey: expandKeyLE(encKey)\n    };\n    // Cleanup\n    clean(...toClean);\n    return res;\n  }\n  function _computeTag(encKey, authKey, data) {\n    const tag = computeTag(polyval, true, authKey, data, AAD);\n    // Compute the expected tag by XORing S_s and the nonce, clearing the\n    // most significant bit of the last byte and encrypting with the\n    // message-encryption key.\n    for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n    tag[15] &= 0x7f; // Clear the highest bit\n    // encrypt tag as block\n    const t32 = u32(tag);\n    // prettier-ignore\n    let s0 = t32[0],\n      s1 = t32[1],\n      s2 = t32[2],\n      s3 = t32[3];\n    ({\n      s0,\n      s1,\n      s2,\n      s3\n    } = encrypt(encKey, s0, s1, s2, s3));\n    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;\n    return tag;\n  }\n  // actual decrypt/encrypt of message.\n  function processSiv(encKey, tag, input) {\n    let block = copyBytes(tag);\n    block[15] |= 0x80; // Force highest bit\n    const res = ctr32(encKey, true, block, input);\n    // Cleanup\n    clean(block);\n    return res;\n  }\n  return {\n    encrypt(plaintext) {\n      PLAIN_LIMIT(plaintext.length);\n      const {\n        encKey,\n        authKey\n      } = deriveKeys();\n      const tag = _computeTag(encKey, authKey, plaintext);\n      const toClean = [encKey, authKey, tag];\n      if (!isAligned32(plaintext)) toClean.push(plaintext = copyBytes(plaintext));\n      const out = new Uint8Array(plaintext.length + tagLength);\n      out.set(tag, plaintext.length);\n      out.set(processSiv(encKey, tag, plaintext));\n      // Cleanup\n      clean(...toClean);\n      return out;\n    },\n    decrypt(ciphertext) {\n      CIPHER_LIMIT(ciphertext.length);\n      const tag = ciphertext.subarray(-tagLength);\n      const {\n        encKey,\n        authKey\n      } = deriveKeys();\n      const toClean = [encKey, authKey];\n      if (!isAligned32(ciphertext)) toClean.push(ciphertext = copyBytes(ciphertext));\n      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n      const expectedTag = _computeTag(encKey, authKey, plaintext);\n      toClean.push(expectedTag);\n      if (!equalBytes(tag, expectedTag)) {\n        clean(...toClean);\n        throw new Error('invalid polyval tag');\n      }\n      // Cleanup\n      clean(...toClean);\n      return plaintext;\n    }\n  };\n});\n/**\n * AES-GCM-SIV, not AES-SIV.\n * This is legace name, use `gcmsiv` export instead.\n * @deprecated\n */\nexport const siv = gcmsiv;\nfunction isBytes32(a) {\n  return a instanceof Uint32Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array';\n}\nfunction encryptBlock(xk, block) {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let {\n    s0,\n    s1,\n    s2,\n    s3\n  } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;\n  return block;\n}\nfunction decryptBlock(xk, block) {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let {\n    s0,\n    s1,\n    s2,\n    s3\n  } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;\n  return block;\n}\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n  /*\n  High-level pseudocode:\n  ```\n  A: u64 = IV\n  out = []\n  for (let i=0, ctr = 0; i<6; i++) {\n    for (const chunk of chunks(plaintext, 8)) {\n      A ^= swapEndianess(ctr++)\n      [A, res] = chunks(encrypt(A || chunk), 8);\n      out ||= res\n    }\n  }\n  out = A || out\n  ```\n  Decrypt is the same, but reversed.\n  */\n  encrypt(kek, out) {\n    // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n    // If you need it larger, open an issue.\n    if (out.length >= 2 ** 32) throw new Error('plaintext should be less than 4gb');\n    const xk = expandKeyLE(kek);\n    if (out.length === 16) encryptBlock(xk, out);else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0],\n        a1 = o32[1]; // A\n      for (let j = 0, ctr = 1; j < 6; j++) {\n        for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n          const {\n            s0,\n            s1,\n            s2,\n            s3\n          } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          // A = MSB(64, B) ^ t where t = (n*j)+i\n          a0 = s0, a1 = s1 ^ byteSwap(ctr), o32[pos] = s2, o32[pos + 1] = s3;\n        }\n      }\n      o32[0] = a0, o32[1] = a1; // out = A || out\n    }\n    xk.fill(0);\n  },\n  decrypt(kek, out) {\n    if (out.length - 8 >= 2 ** 32) throw new Error('ciphertext should be less than 4gb');\n    const xk = expandKeyDecLE(kek);\n    const chunks = out.length / 8 - 1; // first chunk is IV\n    if (chunks === 1) decryptBlock(xk, out);else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0],\n        a1 = o32[1]; // A\n      for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n          a1 ^= byteSwap(ctr);\n          const {\n            s0,\n            s1,\n            s2,\n            s3\n          } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          a0 = s0, a1 = s1, o32[pos] = s2, o32[pos + 1] = s3;\n        }\n      }\n      o32[0] = a0, o32[1] = a1;\n    }\n    xk.fill(0);\n  }\n};\nconst AESKW_IV = /* @__PURE__ */new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw = /* @__PURE__ */wrapCipher({\n  blockSize: 8\n}, kek => ({\n  encrypt(plaintext) {\n    if (!plaintext.length || plaintext.length % 8 !== 0) throw new Error('invalid plaintext length');\n    if (plaintext.length === 8) throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n    const out = concatBytes(AESKW_IV, plaintext);\n    AESW.encrypt(kek, out);\n    return out;\n  },\n  decrypt(ciphertext) {\n    // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n    // 24 because should have at least two block (1 iv + 2).\n    // Replace with 16 to enable '8-byte keys'\n    if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8) throw new Error('invalid ciphertext length');\n    const out = copyBytes(ciphertext);\n    AESW.decrypt(kek, out);\n    if (!equalBytes(out.subarray(0, 8), AESKW_IV)) throw new Error('integrity check failed');\n    out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n    return out.subarray(8);\n  }\n}));\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp = /* @__PURE__ */wrapCipher({\n  blockSize: 8\n}, kek => ({\n  encrypt(plaintext) {\n    if (!plaintext.length) throw new Error('invalid plaintext length');\n    const padded = Math.ceil(plaintext.length / 8) * 8;\n    const out = new Uint8Array(8 + padded);\n    out.set(plaintext, 8);\n    const out32 = u32(out);\n    out32[0] = AESKWP_IV;\n    out32[1] = byteSwap(plaintext.length);\n    AESW.encrypt(kek, out);\n    return out;\n  },\n  decrypt(ciphertext) {\n    // 16 because should have at least one block\n    if (ciphertext.length < 16) throw new Error('invalid ciphertext length');\n    const out = copyBytes(ciphertext);\n    const o32 = u32(out);\n    AESW.decrypt(kek, out);\n    const len = byteSwap(o32[1]) >>> 0;\n    const padded = Math.ceil(len / 8) * 8;\n    if (o32[0] !== AESKWP_IV || out.length - 8 !== padded) throw new Error('integrity check failed');\n    for (let i = len; i < padded; i++) if (out[8 + i] !== 0) throw new Error('integrity check failed');\n    out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n    return out.subarray(8, 8 + len);\n  }\n}));\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32\n};","map":{"version":3,"names":["ghash","polyval","abytes","clean","complexOverlapBytes","concatBytes","copyBytes","createView","equalBytes","getOutput","isAligned32","overlapBytes","setBigUint64","u32","u64Lengths","u8","wrapCipher","BLOCK_SIZE","BLOCK_SIZE32","EMPTY_BLOCK","Uint8Array","POLY","mul2","n","mul","a","b","res","sbox","t","i","x","box","invSbox","map","_","j","indexOf","rotr32_8","rotl32_8","byteSwap","word","genTtable","fn","length","Error","T0","Uint32Array","T1","T2","T3","T01","T23","sbox2","Uint16Array","idx","tableEncoding","s","tableDecoding","xPowers","p","expandKeyLE","key","len","includes","toClean","push","k32","Nk","subByte","applySbox","xk","set","expandKeyDecLE","encKey","slice","w","apply0123","s0","s1","s2","s3","encrypt","k","rounds","t0","t1","t2","t3","decrypt","ctrCounter","nonce","src","dst","srcLen","ctr","c32","src32","dst32","carry","start","Math","floor","b32","buf","pos","ctr32","isLE","view","ctrPos","ctrNum","getUint32","setUint32","blockSize","nonceLength","aesctr","processCtr","undefined","out","plaintext","ciphertext","validateBlockDecrypt","data","validateBlockEncrypt","pcks5","outLen","remaining","left","o","validatePCKS","lastByte","subarray","padPCKS","tmp","tmp32","paddingByte","ecb","aesecb","opts","disablePadding","_out","cbc","aescbc","iv","_iv","n32","ps0","ps1","ps2","ps3","o0","o1","o2","o3","cfb","aescfb","processCfb","isEncrypt","next32","e0","e1","e2","e3","computeTag","AAD","aadLength","h","create","update","num","digest","gcm","tagLength","varSizeNonce","aesgcm","_computeTag","authKey","tagMask","tag","deriveKeys","counter","nonceLen","BigInt","g","digestInto","destroy","passedTag","limit","name","min","max","value","Number","isSafeInteger","minmax","gcmsiv","aessiv","AAD_LIMIT","PLAIN_LIMIT","NONCE_LIMIT","CIPHER_LIMIT","_nonce","derivedKey","d32","t32","processSiv","input","block","expectedTag","siv","isBytes32","ArrayBuffer","isView","constructor","encryptBlock","decryptBlock","AESW","kek","o32","a0","a1","fill","chunks","AESKW_IV","aeskw","AESKWP_IV","aeskwp","padded","ceil","out32","unsafe"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@noble/ciphers/src/aes.ts"],"sourcesContent":["/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { ghash, polyval } from './_polyval.ts';\n// prettier-ignore\nimport {\n  abytes, clean, complexOverlapBytes, concatBytes,\n  copyBytes, createView, equalBytes, getOutput, isAligned32, overlapBytes,\n  setBigUint64, u32, u64Lengths, u8, wrapCipher,\n  type Cipher, type CipherWithOutput,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\n// TODO: remove multiplication, binary ops only\nfunction mul2(n: number) {\n  return (n << 1) ^ (POLY & -(n >> 7));\n}\n\nfunction mul(a: number, b: number) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n  const t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n  }\n  clean(t);\n  return box;\n})();\n\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\n// Rotate u32 by 8\nconst rotr32_8 = (n: number) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n: number) => (n << 8) | (n >>> 24);\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox: Uint8Array, fn: (n: number) => number) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = (sbox[i] << 8) | sbox[j];\n    }\n  }\n  return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\n\nconst tableEncoding = /* @__PURE__ */ genTtable(\n  sbox,\n  (s: number) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2)\n);\nconst tableDecoding = /* @__PURE__ */ genTtable(\n  invSbox,\n  (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14)\n);\n\nconst xPowers = /* @__PURE__ */ (() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key: Uint8Array): Uint32Array {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len))\n    throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n  const { sbox2 } = tableEncoding;\n  const toClean = [];\n  if (!isAligned32(key)) toClean.push((key = copyBytes(key)));\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = (n: number) => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n    else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  clean(...toClean);\n  return xk;\n}\n\nfunction expandKeyDecLE(key: Uint8Array): Uint32Array {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const { sbox2 } = tableEncoding;\n  const { T0, T1, T2, T3 } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  clean(encKey);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n\n// Apply tables\nfunction apply0123(\n  T01: Uint32Array,\n  T23: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n) {\n  return (\n    T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n    T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]\n  );\n}\n\nfunction applySbox(sbox2: Uint16Array, s0: number, s1: number, s2: number, s3: number) {\n  return (\n    sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n    (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16)\n  );\n}\n\nfunction encrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): { s0: number; s1: number; s2: number; s3: number } {\n  const { sbox2, T01, T23 } = tableEncoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): {\n  s0: number;\n  s1: number;\n  s2: number;\n  s3: number;\n} {\n  const { sbox2, T01, T23 } = tableDecoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // Last round\n  const t0: number = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1: number = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2: number = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3: number = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// TODO: investigate merging with ctr32\nfunction ctrCounter(\n  xk: Uint32Array,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getOutput(srcLen, dst);\n  complexOverlapBytes(src, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = (carry + (ctr[i] & 0xff)) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(\n  xk: Uint32Array,\n  isLE: boolean,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getOutput(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr: ((key: Uint8Array, nonce: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aesctr(key: Uint8Array, nonce: Uint8Array): CipherWithOutput {\n    function processCtr(buf: Uint8Array, dst?: Uint8Array) {\n      abytes(buf);\n      if (dst !== undefined) {\n        abytes(dst);\n        if (!isAligned32(dst)) throw new Error('unaligned destination');\n      }\n      const xk = expandKeyLE(key);\n      const n = copyBytes(nonce); // align + avoid changing\n      const toClean = [xk, n];\n      if (!isAligned32(buf)) toClean.push((buf = copyBytes(buf)));\n      const out = ctrCounter(xk, n, buf, dst);\n      clean(...toClean);\n      return out;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCtr(plaintext, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCtr(ciphertext, dst),\n    };\n  }\n);\n\nfunction validateBlockDecrypt(data: Uint8Array) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error(\n      'aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE\n    );\n  }\n}\n\nfunction validateBlockEncrypt(plaintext: Uint8Array, pcks5: boolean, dst?: Uint8Array) {\n  abytes(plaintext);\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0)\n    throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  if (!isAligned32(plaintext)) plaintext = copyBytes(plaintext);\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  dst = getOutput(outLen, dst);\n  complexOverlapBytes(plaintext, dst);\n  const o = u32(dst);\n  return { b, o, out: dst };\n}\n\nfunction validatePCKS(data: Uint8Array, pcks5: boolean) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error('aes/pcks5: empty ciphertext not allowed');\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error('aes/pcks5: wrong padding');\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++)\n    if (data[len - i - 1] !== lastByte) throw new Error('aes/pcks5: wrong padding');\n  return out;\n}\n\nfunction padPCKS(left: Uint8Array) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n\n/** Options for ECB and CBC. */\nexport type BlockOpts = { disablePadding?: boolean };\n\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb: ((key: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16 },\n  function aesecb(key: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const xk = expandKeyLE(key);\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(xk);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        dst = getOutput(ciphertext.length, dst);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        for (let i = 0; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CBC: Cipher-Block-Chaining. Key is previous roundâ€™s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc: ((key: Uint8Array, iv: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescbc(key: Uint8Array, iv: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const xk = expandKeyLE(key);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        dst = getOutput(ciphertext.length, dst);\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= b.length; ) {\n          // prettier-ignore\n          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n          (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n          (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb: ((key: Uint8Array, iv: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescfb(key: Uint8Array, iv: Uint8Array): CipherWithOutput {\n    function processCfb(src: Uint8Array, isEncrypt: boolean, dst?: Uint8Array) {\n      abytes(src);\n      const srcLen = src.length;\n      dst = getOutput(srcLen, dst);\n      if (overlapBytes(src, dst)) throw new Error('overlapping src and dst not supported.');\n      const xk = expandKeyLE(key);\n      let _iv = iv;\n      const toClean: (Uint8Array | Uint32Array)[] = [xk];\n      if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n      if (!isAligned32(src)) toClean.push((src = copyBytes(src)));\n      const src32 = u32(src);\n      const dst32 = u32(dst);\n      const next32 = isEncrypt ? dst32 : src32;\n      const n32 = u32(_iv);\n      // prettier-ignore\n      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n      for (let i = 0; i + 4 <= src32.length; ) {\n        const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n        dst32[i + 0] = src32[i + 0] ^ e0;\n        dst32[i + 1] = src32[i + 1] ^ e1;\n        dst32[i + 2] = src32[i + 2] ^ e2;\n        dst32[i + 3] = src32[i + 3] ^ e3;\n        (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n      }\n      // leftovers (less than block)\n      const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n      if (start < srcLen) {\n        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n        const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n        for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n        clean(buf);\n      }\n      clean(...toClean);\n      return dst;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCfb(plaintext, true, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCfb(ciphertext, false, dst),\n    };\n  }\n);\n\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(\n  fn: typeof ghash,\n  isLE: boolean,\n  key: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) {\n  const aadLength = AAD ? AAD.length : 0;\n  const h = fn.create(key, data.length + aadLength);\n  if (AAD) h.update(AAD);\n  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE);\n  h.update(data);\n  h.update(num);\n  const res = h.digest();\n  clean(num);\n  return res;\n}\n\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aesgcm(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    // NIST 800-38d doesn't enforce minimum nonce length.\n    // We enforce 8 bytes for compat with openssl.\n    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n    if (nonce.length < 8) throw new Error('aes/gcm: invalid nonce length');\n    const tagLength = 16;\n    function _computeTag(authKey: Uint8Array, tagMask: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(ghash, false, authKey, data, AAD);\n      for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n      return tag;\n    }\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const authKey = EMPTY_BLOCK.slice();\n      const counter = EMPTY_BLOCK.slice();\n      ctr32(xk, false, counter, counter, authKey);\n      // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n      if (nonce.length === 12) {\n        counter.set(nonce);\n      } else {\n        const nonceLen = EMPTY_BLOCK.slice();\n        const view = createView(nonceLen);\n        setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n        // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n        const g = ghash.create(authKey).update(nonce).update(nonceLen);\n        g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n        g.destroy();\n      }\n      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n      return { xk, authKey, counter, tagMask };\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const out = new Uint8Array(plaintext.length + tagLength);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, counter, tagMask];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n        toClean.push(tag);\n        out.set(tag, plaintext.length);\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, tagMask, counter];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = _computeTag(authKey, tagMask, data);\n        toClean.push(tag);\n        if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n        const out = ctr32(xk, false, counter, data);\n        clean(...toClean);\n        return out;\n      },\n    };\n  }\n);\n\nconst limit = (name: string, min: number, max: number) => (value: number) => {\n  if (!Number.isSafeInteger(value) || min > value || value > max) {\n    const minmax = '[' + min + '..' + max + ']';\n    throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n  }\n};\n\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const gcmsiv: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aessiv(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(key, 16, 24, 32);\n    NONCE_LIMIT(nonce.length);\n    if (AAD !== undefined) AAD_LIMIT(AAD.length);\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const encKey = new Uint8Array(key.length);\n      const authKey = new Uint8Array(16);\n      const toClean: (Uint8Array | Uint32Array)[] = [xk, encKey];\n      let _nonce = nonce;\n      if (!isAligned32(_nonce)) toClean.push((_nonce = copyBytes(_nonce)));\n      const n32 = u32(_nonce);\n      // prettier-ignore\n      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n      let counter = 0;\n      for (const derivedKey of [authKey, encKey].map(u32)) {\n        const d32 = u32(derivedKey);\n        for (let i = 0; i < d32.length; i += 2) {\n          // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n          d32[i + 0] = o0;\n          d32[i + 1] = o1;\n          s0 = ++counter; // increment counter inside state\n        }\n      }\n      const res = { authKey, encKey: expandKeyLE(encKey) };\n      // Cleanup\n      clean(...toClean);\n      return res;\n    }\n    function _computeTag(encKey: Uint32Array, authKey: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(polyval, true, authKey, data, AAD);\n      // Compute the expected tag by XORing S_s and the nonce, clearing the\n      // most significant bit of the last byte and encrypting with the\n      // message-encryption key.\n      for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n      tag[15] &= 0x7f; // Clear the highest bit\n      // encrypt tag as block\n      const t32 = u32(tag);\n      // prettier-ignore\n      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n      (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n      return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey: Uint32Array, tag: Uint8Array, input: Uint8Array) {\n      let block = copyBytes(tag);\n      block[15] |= 0x80; // Force highest bit\n      const res = ctr32(encKey, true, block, input);\n      // Cleanup\n      clean(block);\n      return res;\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        PLAIN_LIMIT(plaintext.length);\n        const { encKey, authKey } = deriveKeys();\n        const tag = _computeTag(encKey, authKey, plaintext);\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey, tag];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        const out = new Uint8Array(plaintext.length + tagLength);\n        out.set(tag, plaintext.length);\n        out.set(processSiv(encKey, tag, plaintext));\n        // Cleanup\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        CIPHER_LIMIT(ciphertext.length);\n        const tag = ciphertext.subarray(-tagLength);\n        const { encKey, authKey } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n        const expectedTag = _computeTag(encKey, authKey, plaintext);\n        toClean.push(expectedTag);\n        if (!equalBytes(tag, expectedTag)) {\n          clean(...toClean);\n          throw new Error('invalid polyval tag');\n        }\n        // Cleanup\n        clean(...toClean);\n        return plaintext;\n      },\n    };\n  }\n);\n\n/**\n * AES-GCM-SIV, not AES-SIV.\n * This is legace name, use `gcmsiv` export instead.\n * @deprecated\n */\nexport const siv: typeof gcmsiv = gcmsiv;\n\nfunction isBytes32(a: unknown): a is Uint32Array {\n  return (\n    a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array')\n  );\n}\n\nfunction encryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\nfunction decryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n  /*\n  High-level pseudocode:\n  ```\n  A: u64 = IV\n  out = []\n  for (let i=0, ctr = 0; i<6; i++) {\n    for (const chunk of chunks(plaintext, 8)) {\n      A ^= swapEndianess(ctr++)\n      [A, res] = chunks(encrypt(A || chunk), 8);\n      out ||= res\n    }\n  }\n  out = A || out\n  ```\n  Decrypt is the same, but reversed.\n  */\n  encrypt(kek: Uint8Array, out: Uint8Array) {\n    // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n    // If you need it larger, open an issue.\n    if (out.length >= 2 ** 32) throw new Error('plaintext should be less than 4gb');\n    const xk = expandKeyLE(kek);\n    if (out.length === 16) encryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = 1; j < 6; j++) {\n        for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n          const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          // A = MSB(64, B) ^ t where t = (n*j)+i\n          (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1); // out = A || out\n    }\n    xk.fill(0);\n  },\n  decrypt(kek: Uint8Array, out: Uint8Array) {\n    if (out.length - 8 >= 2 ** 32) throw new Error('ciphertext should be less than 4gb');\n    const xk = expandKeyDecLE(kek);\n    const chunks = out.length / 8 - 1; // first chunk is IV\n    if (chunks === 1) decryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n          a1 ^= byteSwap(ctr);\n          const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1);\n    }\n    xk.fill(0);\n  },\n};\n\nconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length || plaintext.length % 8 !== 0)\n        throw new Error('invalid plaintext length');\n      if (plaintext.length === 8)\n        throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n      const out = concatBytes(AESKW_IV, plaintext);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n      // 24 because should have at least two block (1 iv + 2).\n      // Replace with 16 to enable '8-byte keys'\n      if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n        throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      AESW.decrypt(kek, out);\n      if (!equalBytes(out.subarray(0, 8), AESKW_IV)) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8);\n    },\n  })\n);\n\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\n\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length) throw new Error('invalid plaintext length');\n      const padded = Math.ceil(plaintext.length / 8) * 8;\n      const out = new Uint8Array(8 + padded);\n      out.set(plaintext, 8);\n      const out32 = u32(out);\n      out32[0] = AESKWP_IV;\n      out32[1] = byteSwap(plaintext.length);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // 16 because should have at least one block\n      if (ciphertext.length < 16) throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      const o32 = u32(out);\n      AESW.decrypt(kek, out);\n      const len = byteSwap(o32[1]) >>> 0;\n      const padded = Math.ceil(len / 8) * 8;\n      if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n        throw new Error('integrity check failed');\n      for (let i = len; i < padded; i++)\n        if (out[8 + i] !== 0) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8, 8 + len);\n    },\n  })\n);\n\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe: {\n  expandKeyLE: typeof expandKeyLE;\n  expandKeyDecLE: typeof expandKeyDecLE;\n  encrypt: typeof encrypt;\n  decrypt: typeof decrypt;\n  encryptBlock: typeof encryptBlock;\n  decryptBlock: typeof decryptBlock;\n  ctrCounter: typeof ctrCounter;\n  ctr32: typeof ctr32;\n} = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}