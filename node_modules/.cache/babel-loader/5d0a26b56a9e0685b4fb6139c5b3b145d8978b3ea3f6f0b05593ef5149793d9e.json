{"ast":null,"code":"import { erc20Abi, formatUnits } from 'viem';\nimport { ConstantsUtil, ParseUtil } from '@reown/appkit-common';\nimport { BlockchainApiController } from '../controllers/BlockchainApiController.js';\nimport { ChainController } from '../controllers/ChainController.js';\nimport { ConnectionController } from '../controllers/ConnectionController.js';\nimport { ConnectorController } from '../controllers/ConnectorController.js';\nimport { ERC7811Utils } from './ERC7811Util.js';\nimport { StorageUtil } from './StorageUtil.js';\nimport { ViemUtil } from './ViemUtil.js';\n// -- Controller ---------------------------------------- //\nexport const BalanceUtil = {\n  /**\n   * Get the balances of the user's tokens. If user connected with Auth provider or and on the EIP155 network,\n   * it'll use the `wallet_getAssets` and `wallet_getCapabilities` calls to fetch the balance rather than Blockchain API\n   * @param forceUpdate - If true, the balances will be fetched from the server\n   * @returns The balances of the user's tokens\n   */\n  async getMyTokensWithBalance(forceUpdate) {\n    var _ChainController$getA;\n    const address = (_ChainController$getA = ChainController.getAccountData()) === null || _ChainController$getA === void 0 ? void 0 : _ChainController$getA.address;\n    const caipNetwork = ChainController.state.activeCaipNetwork;\n    const isAuthConnector = ConnectorController.getConnectorId('eip155') === ConstantsUtil.CONNECTOR_ID.AUTH;\n    if (!address || !caipNetwork) {\n      return [];\n    }\n    const caipAddress = \"\".concat(caipNetwork.caipNetworkId, \":\").concat(address);\n    const cachedBalance = StorageUtil.getBalanceCacheForCaipAddress(caipAddress);\n    if (cachedBalance) {\n      return cachedBalance.balances;\n    }\n    // Extract EIP-155 specific logic\n    if (caipNetwork.chainNamespace === ConstantsUtil.CHAIN.EVM && isAuthConnector) {\n      const eip155Balances = await this.getEIP155Balances(address, caipNetwork);\n      if (eip155Balances) {\n        return this.filterLowQualityTokens(eip155Balances);\n      }\n    }\n    // Fallback to 1Inch API\n    const response = await BlockchainApiController.getBalance(address, caipNetwork.caipNetworkId, forceUpdate);\n    return this.filterLowQualityTokens(response.balances);\n  },\n  /**\n   * Get the balances of the user's tokens on the EIP155 network using native `wallet_getAssets` and `wallet_getCapabilities` calls\n   * @param address - The address of the user\n   * @param caipNetwork - The CAIP network\n   * @returns The balances of the user's tokens on the EIP155 network\n   */\n  async getEIP155Balances(address, caipNetwork) {\n    try {\n      var _walletCapabilities$c;\n      const chainIdHex = ERC7811Utils.getChainIdHexFromCAIP2ChainId(caipNetwork.caipNetworkId);\n      const walletCapabilities = await ConnectionController.getCapabilities(address);\n      if (!(walletCapabilities !== null && walletCapabilities !== void 0 && (_walletCapabilities$c = walletCapabilities[chainIdHex]) !== null && _walletCapabilities$c !== void 0 && (_walletCapabilities$c = _walletCapabilities$c['assetDiscovery']) !== null && _walletCapabilities$c !== void 0 && _walletCapabilities$c.supported)) {\n        return null;\n      }\n      const walletGetAssetsResponse = await ConnectionController.walletGetAssets({\n        account: address,\n        chainFilter: [chainIdHex]\n      });\n      if (!ERC7811Utils.isWalletGetAssetsResponse(walletGetAssetsResponse)) {\n        return null;\n      }\n      const assets = walletGetAssetsResponse[chainIdHex] || [];\n      const filteredAssets = assets.map(asset => ERC7811Utils.createBalance(asset, caipNetwork.caipNetworkId));\n      StorageUtil.updateBalanceCache({\n        caipAddress: \"\".concat(caipNetwork.caipNetworkId, \":\").concat(address),\n        balance: {\n          balances: filteredAssets\n        },\n        timestamp: Date.now()\n      });\n      return filteredAssets;\n    } catch (error) {\n      return null;\n    }\n  },\n  /**\n   * The 1Inch API includes many low-quality tokens in the balance response,\n   * which appear inconsistently. This filter prevents them from being displayed.\n   */\n  filterLowQualityTokens(balances) {\n    return balances.filter(balance => balance.quantity.decimals !== '0');\n  },\n  async fetchERC20Balance(_ref) {\n    let {\n      caipAddress,\n      assetAddress,\n      caipNetwork\n    } = _ref;\n    const publicClient = await ViemUtil.createViemPublicClient(caipNetwork);\n    const {\n      address\n    } = ParseUtil.parseCaipAddress(caipAddress);\n    const [{\n      result: name\n    }, {\n      result: symbol\n    }, {\n      result: balance\n    }, {\n      result: decimals\n    }] = await publicClient.multicall({\n      contracts: [{\n        address: assetAddress,\n        functionName: 'name',\n        args: [],\n        abi: erc20Abi\n      }, {\n        address: assetAddress,\n        functionName: 'symbol',\n        args: [],\n        abi: erc20Abi\n      }, {\n        address: assetAddress,\n        functionName: 'balanceOf',\n        args: [address],\n        abi: erc20Abi\n      }, {\n        address: assetAddress,\n        functionName: 'decimals',\n        args: [],\n        abi: erc20Abi\n      }]\n    });\n    return {\n      name,\n      symbol,\n      decimals,\n      balance: balance && decimals ? formatUnits(balance, decimals) : '0'\n    };\n  }\n};","map":{"version":3,"names":["erc20Abi","formatUnits","ConstantsUtil","ParseUtil","BlockchainApiController","ChainController","ConnectionController","ConnectorController","ERC7811Utils","StorageUtil","ViemUtil","BalanceUtil","getMyTokensWithBalance","forceUpdate","_ChainController$getA","address","getAccountData","caipNetwork","state","activeCaipNetwork","isAuthConnector","getConnectorId","CONNECTOR_ID","AUTH","caipAddress","concat","caipNetworkId","cachedBalance","getBalanceCacheForCaipAddress","balances","chainNamespace","CHAIN","EVM","eip155Balances","getEIP155Balances","filterLowQualityTokens","response","getBalance","_walletCapabilities$c","chainIdHex","getChainIdHexFromCAIP2ChainId","walletCapabilities","getCapabilities","supported","walletGetAssetsResponse","walletGetAssets","account","chainFilter","isWalletGetAssetsResponse","assets","filteredAssets","map","asset","createBalance","updateBalanceCache","balance","timestamp","Date","now","error","filter","quantity","decimals","fetchERC20Balance","_ref","assetAddress","publicClient","createViemPublicClient","parseCaipAddress","result","name","symbol","multicall","contracts","functionName","args","abi"],"sources":["../../../../src/utils/BalanceUtil.ts"],"sourcesContent":[null],"mappings":"AAAA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,MAAM;AAE5C,SAIEC,aAAa,EACbC,SAAS,QACJ,sBAAsB;AAE7B,SAASC,uBAAuB,QAAQ,2CAA2C;AACnF,SAASC,eAAe,QAAQ,mCAAmC;AACnE,SAASC,oBAAoB,QAAQ,wCAAwC;AAC7E,SAASC,mBAAmB,QAAQ,uCAAuC;AAC3E,SAASC,YAAY,QAAQ,kBAAkB;AAC/C,SAASC,WAAW,QAAQ,kBAAkB;AAE9C,SAASC,QAAQ,QAAQ,eAAe;AASxC;AACA,OAAO,MAAMC,WAAW,GAAG;EACzB;;;;;;EAMA,MAAMC,sBAAsBA,CAC1BC,WAAoB;IAAA,IAAAC,qBAAA;IAEpB,MAAMC,OAAO,IAAAD,qBAAA,GAAGT,eAAe,CAACW,cAAc,EAAE,cAAAF,qBAAA,uBAAhCA,qBAAA,CAAkCC,OAAO;IACzD,MAAME,WAAW,GAAGZ,eAAe,CAACa,KAAK,CAACC,iBAAiB;IAC3D,MAAMC,eAAe,GACnBb,mBAAmB,CAACc,cAAc,CAAC,QAAQ,CAAC,KAAKnB,aAAa,CAACoB,YAAY,CAACC,IAAI;IAElF,IAAI,CAACR,OAAO,IAAI,CAACE,WAAW,EAAE;MAC5B,OAAO,EAAE;IACX;IAEA,MAAMO,WAAW,MAAAC,MAAA,CAAMR,WAAW,CAACS,aAAa,OAAAD,MAAA,CAAIV,OAAO,CAAE;IAC7D,MAAMY,aAAa,GAAGlB,WAAW,CAACmB,6BAA6B,CAACJ,WAAW,CAAC;IAE5E,IAAIG,aAAa,EAAE;MACjB,OAAOA,aAAa,CAACE,QAAQ;IAC/B;IAEA;IACA,IAAIZ,WAAW,CAACa,cAAc,KAAK5B,aAAa,CAAC6B,KAAK,CAACC,GAAG,IAAIZ,eAAe,EAAE;MAC7E,MAAMa,cAAc,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACnB,OAAO,EAAEE,WAAW,CAAC;MAEzE,IAAIgB,cAAc,EAAE;QAClB,OAAO,IAAI,CAACE,sBAAsB,CAACF,cAAc,CAAC;MACpD;IACF;IAEA;IACA,MAAMG,QAAQ,GAAG,MAAMhC,uBAAuB,CAACiC,UAAU,CACvDtB,OAAO,EACPE,WAAW,CAACS,aAAa,EACzBb,WAAW,CACZ;IAED,OAAO,IAAI,CAACsB,sBAAsB,CAACC,QAAQ,CAACP,QAAQ,CAAC;EACvD,CAAC;EAED;;;;;;EAMA,MAAMK,iBAAiBA,CAACnB,OAAe,EAAEE,WAAwB;IAC/D,IAAI;MAAA,IAAAqB,qBAAA;MACF,MAAMC,UAAU,GAAG/B,YAAY,CAACgC,6BAA6B,CAACvB,WAAW,CAACS,aAAa,CAAC;MACxF,MAAMe,kBAAkB,GAAI,MAAMnC,oBAAoB,CAACoC,eAAe,CAAC3B,OAAO,CAG7E;MAED,IAAI,EAAC0B,kBAAkB,aAAlBA,kBAAkB,gBAAAH,qBAAA,GAAlBG,kBAAkB,CAAGF,UAAU,CAAC,cAAAD,qBAAA,gBAAAA,qBAAA,GAAhCA,qBAAA,CAAmC,gBAAgB,CAAC,cAAAA,qBAAA,eAApDA,qBAAA,CAAsDK,SAAS,GAAE;QACpE,OAAO,IAAI;MACb;MAEA,MAAMC,uBAAuB,GAAG,MAAMtC,oBAAoB,CAACuC,eAAe,CAAC;QACzEC,OAAO,EAAE/B,OAAkB;QAC3BgC,WAAW,EAAE,CAACR,UAAU;OACzB,CAAC;MAEF,IAAI,CAAC/B,YAAY,CAACwC,yBAAyB,CAACJ,uBAAuB,CAAC,EAAE;QACpE,OAAO,IAAI;MACb;MAEA,MAAMK,MAAM,GAAGL,uBAAuB,CAACL,UAAU,CAAC,IAAI,EAAE;MACxD,MAAMW,cAAc,GAAGD,MAAM,CAACE,GAAG,CAACC,KAAK,IACrC5C,YAAY,CAAC6C,aAAa,CAACD,KAAK,EAAEnC,WAAW,CAACS,aAAa,CAAC,CAC7D;MAEDjB,WAAW,CAAC6C,kBAAkB,CAAC;QAC7B9B,WAAW,KAAAC,MAAA,CAAKR,WAAW,CAACS,aAAa,OAAAD,MAAA,CAAIV,OAAO,CAAE;QACtDwC,OAAO,EAAE;UAAE1B,QAAQ,EAAEqB;QAAc,CAAE;QACrCM,SAAS,EAAEC,IAAI,CAACC,GAAG;OACpB,CAAC;MAEF,OAAOR,cAAc;IACvB,CAAC,CAAC,OAAOS,KAAK,EAAE;MACd,OAAO,IAAI;IACb;EACF,CAAC;EAED;;;;EAIAxB,sBAAsBA,CAACN,QAAkD;IACvE,OAAOA,QAAQ,CAAC+B,MAAM,CAACL,OAAO,IAAIA,OAAO,CAACM,QAAQ,CAACC,QAAQ,KAAK,GAAG,CAAC;EACtE,CAAC;EACD,MAAMC,iBAAiBA,CAAAC,IAAA,EAAmE;IAAA,IAAlE;MAAExC,WAAW;MAAEyC,YAAY;MAAEhD;IAAW,CAA0B,GAAA+C,IAAA;IACxF,MAAME,YAAY,GAAG,MAAMxD,QAAQ,CAACyD,sBAAsB,CAAClD,WAAW,CAAC;IAEvE,MAAM;MAAEF;IAAO,CAAE,GAAGZ,SAAS,CAACiE,gBAAgB,CAAC5C,WAAW,CAAC;IAE3D,MAAM,CAAC;MAAE6C,MAAM,EAAEC;IAAI,CAAE,EAAE;MAAED,MAAM,EAAEE;IAAM,CAAE,EAAE;MAAEF,MAAM,EAAEd;IAAO,CAAE,EAAE;MAAEc,MAAM,EAAEP;IAAQ,CAAE,CAAC,GACrF,MAAMI,YAAY,CAACM,SAAS,CAAC;MAC3BC,SAAS,EAAE,CACT;QACE1D,OAAO,EAAEkD,YAAuB;QAChCS,YAAY,EAAE,MAAM;QACpBC,IAAI,EAAE,EAAE;QACRC,GAAG,EAAE5E;OACN,EACD;QACEe,OAAO,EAAEkD,YAAuB;QAChCS,YAAY,EAAE,QAAQ;QACtBC,IAAI,EAAE,EAAE;QACRC,GAAG,EAAE5E;OACN,EACD;QACEe,OAAO,EAAEkD,YAAuB;QAChCS,YAAY,EAAE,WAAW;QACzBC,IAAI,EAAE,CAAC5D,OAAkB,CAAC;QAC1B6D,GAAG,EAAE5E;OACN,EACD;QACEe,OAAO,EAAEkD,YAAuB;QAChCS,YAAY,EAAE,UAAU;QACxBC,IAAI,EAAE,EAAE;QACRC,GAAG,EAAE5E;OACN;KAEJ,CAAC;IAEJ,OAAO;MACLsE,IAAI;MACJC,MAAM;MACNT,QAAQ;MACRP,OAAO,EAAEA,OAAO,IAAIO,QAAQ,GAAG7D,WAAW,CAACsD,OAAO,EAAEO,QAAQ,CAAC,GAAG;KACjE;EACH;CACD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}