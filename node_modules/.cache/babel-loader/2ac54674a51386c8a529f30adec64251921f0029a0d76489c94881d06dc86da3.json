{"ast":null,"code":"import { ethers } from 'ethers';\nimport MarketplaceABI from '../contracts/abis/Marketplace.json';\nimport StrDomainsNFTABI from '../contracts/abis/StrDomainsNFT.json';\nimport RoyaltySplitterABI from '../contracts/abis/RoyaltySplitter.json';\nexport class MarketplaceSDK {\n  constructor(signer, marketplaceAddress, nftAddress, develop = false) {\n    this.provider = void 0;\n    this.signer = void 0;\n    this.marketplaceAddress = void 0;\n    this.nftAddress = void 0;\n    this.marketplaceContract = void 0;\n    this.nftContract = void 0;\n    this.develop = void 0;\n    this.collectionCountTokens = void 0;\n    this.develop = develop;\n    this.signer = signer;\n    this.provider = signer.provider;\n    this.marketplaceAddress = marketplaceAddress;\n    this.nftAddress = nftAddress;\n\n    // Create contract instances\n    this.marketplaceContract = new ethers.Contract(marketplaceAddress, MarketplaceABI, signer);\n    this.nftContract = new ethers.Contract(nftAddress, StrDomainsNFTABI, signer);\n  }\n\n  // Update signer when wallet changes\n  updateSigner(signer) {\n    this.signer = signer;\n    this.provider = signer.provider;\n    this.marketplaceContract = new ethers.Contract(this.marketplaceAddress, MarketplaceABI, signer);\n    this.nftContract = new ethers.Contract(this.nftAddress, StrDomainsNFTABI, signer);\n  }\n\n  // Buy a listed token\n  async buyToken(listingId) {\n    try {\n      const listing = await this.marketplaceContract.getListing(listingId);\n      const {\n        price,\n        active\n      } = listing;\n      if (!active) {\n        this.warn('This listing is not active.');\n        return null;\n      }\n      this.warn(`Buying token for ${ethers.formatEther(price)} MATIC...`);\n      const tx = await this.marketplaceContract.buy(listingId, {\n        value: price\n      });\n      const receipt = await tx.wait();\n      this.warn(`Purchase successful!`);\n      return receipt.hash;\n    } catch (error) {\n      this.error('Error purchasing token:', error);\n      return null;\n    }\n  }\n\n  // Update a listed token price\n  async updateListing(listingId, newPrice) {\n    try {\n      const tx = await this.marketplaceContract.updateListing(listingId, ethers.parseEther(newPrice));\n      this.warn(`Listing ${listingId} updated with new price: ${newPrice} MATIC`);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error) {\n      this.error('Error updating listing:', error);\n      return null;\n    }\n  }\n\n  // List a token on the marketplace\n  async listToken(tokenId, price) {\n    try {\n      await this.approveTokenForSale(tokenId);\n      const approved = await this.nftContract.getApproved(tokenId);\n      if (approved !== this.marketplaceAddress) {\n        this.warn(`Please approve tokenId: ${tokenId} for Marketplace address: ${this.marketplaceAddress}, or check the Marketplace listings`);\n        return null;\n      }\n      const tx = await this.marketplaceContract.listToken(this.nftAddress, tokenId, ethers.parseEther(price));\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error) {\n      this.error(`Error listing your tokenId: ${tokenId}, check your ownership`);\n      return null;\n    }\n  }\n\n  // Cancel a listing\n  async cancelListing(listingId) {\n    try {\n      const tx = await this.marketplaceContract.cancelListing(listingId);\n      const receipt = await tx.wait();\n      this.warn(`Listing ${listingId} has been cancelled.`);\n      return receipt.hash;\n    } catch (error) {\n      this.error(`Error cancelling listing, check the listingId: ${listingId} is active, or it exists`);\n      return null;\n    }\n  }\n\n  // Get Marketplace fees\n  async getMarketplaceFees() {\n    try {\n      const fees = await this.marketplaceContract.accruedFees();\n      return fees;\n    } catch (error) {\n      this.error('Error fetching fees details:', error);\n      return null;\n    }\n  }\n\n  // Get listing details\n  async getListing(listingId) {\n    try {\n      const listing = await this.marketplaceContract.getListing(listingId);\n      return listing;\n    } catch (error) {\n      this.error('Error fetching listing details:', error);\n      return null;\n    }\n  }\n\n  // Get tokenData from collection\n  async getTokenData(tokenId) {\n    try {\n      const data = await this.nftContract.getTokenData(tokenId);\n      return data;\n    } catch (error) {\n      this.error('Getting token:', error);\n      return null;\n    }\n  }\n\n  // Get token data from collection\n  async getStrDomainFromCollection(tokenId) {\n    try {\n      const data = await this.nftContract.getTokenData(tokenId);\n      const formattedToken = {\n        tokenId: tokenId,\n        creator: data[0],\n        mintTimestamp: Number(data[1]),\n        uri: data[2],\n        lastPrice: data[3].toString(),\n        lastPriceTimestamp: data[4].toString()\n      };\n      return formattedToken;\n    } catch (e) {\n      // Don't log error, just return null\n      return null;\n    }\n  }\n\n  // Scraping all tokens from the collection\n  async getAllStrDomainsFromCollection() {\n    const tokenList = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 50; // Limit to avoid RPC issues\n\n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n          consecutiveFailures = 0;\n        } else {\n          consecutiveFailures++;\n        }\n        tokenId++;\n      } catch (error) {\n        var _error$reason;\n        consecutiveFailures++;\n        if (error.code === 'CALL_EXCEPTION' && (_error$reason = error.reason) !== null && _error$reason !== void 0 && _error$reason.includes('ERC721NonexistentToken')) {\n          tokenId++;\n          continue;\n        }\n        this.warn(`Error at token ${tokenId}, continuing...`);\n        tokenId++;\n      }\n    }\n    this.collectionCountTokens = tokenList.length;\n    this.warn(`Found ${tokenList.length} tokens in collection`);\n    return tokenList;\n  }\n\n  // Fetch all NFTs from the collection that belong to the connected wallet\n  async getMyDomainsFromCollection() {\n    const myTokenList = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 20; // Reduced to avoid RPC issues\n\n    const myAddress = await this.signer.getAddress();\n\n    // Helper to delay between calls\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const owner = await this.nftContract.ownerOf(tokenId);\n        if (owner.toLowerCase() === myAddress.toLowerCase()) {\n          const tokenData = await this.getStrDomainFromCollection(tokenId);\n          if (tokenData) {\n            myTokenList.push(tokenData);\n            this.log(`Found your domain: Token #${tokenId}`);\n          }\n        }\n        consecutiveFailures = 0;\n        tokenId++;\n\n        // Small delay to avoid RPC rate limiting\n        await delay(100);\n      } catch (error) {\n        var _error$reason2, _error$reason3, _error$message, _error$message2;\n        consecutiveFailures++;\n        if (error.code === 'CALL_EXCEPTION' && ((_error$reason2 = error.reason) !== null && _error$reason2 !== void 0 && _error$reason2.includes('ERC721NonexistentToken') || (_error$reason3 = error.reason) !== null && _error$reason3 !== void 0 && _error$reason3.includes('nonexistent') || (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('could not decode'))) {\n          tokenId++;\n          await delay(100);\n          continue;\n        }\n\n        // RPC error - wait longer before continuing\n        if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('Internal JSON-RPC')) {\n          this.warn(`RPC rate limit hit at token ${tokenId}, slowing down...`);\n          await delay(500);\n        }\n        this.warn(`Error at tokenId ${tokenId}, continuing...`);\n        tokenId++;\n        await delay(200);\n      }\n    }\n    this.warn(`Found ${myTokenList.length} domains owned by you`);\n    return myTokenList;\n  }\n\n  // Count all the tokens from the collection\n  async countCollectionTokens() {\n    const tokenList = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 50; // Limit to avoid RPC issues\n\n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n          consecutiveFailures = 0;\n        } else {\n          consecutiveFailures++;\n        }\n        tokenId++;\n      } catch (error) {\n        var _error$reason4, _error$reason5, _error$message3;\n        consecutiveFailures++;\n        if (error.code === 'CALL_EXCEPTION' && ((_error$reason4 = error.reason) !== null && _error$reason4 !== void 0 && _error$reason4.includes('ERC721NonexistentToken') || (_error$reason5 = error.reason) !== null && _error$reason5 !== void 0 && _error$reason5.includes('nonexistent') || (_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('could not decode'))) {\n          tokenId++;\n          continue;\n        }\n        this.warn(`Error at token ${tokenId}, continuing...`);\n        tokenId++;\n      }\n    }\n    this.collectionCountTokens = tokenList.length;\n    this.warn(`Counted ${tokenList.length} tokens in collection`);\n    return tokenList.length;\n  }\n\n  // Scraping all splitter contracts from the collection\n  async getAllSplitterContractsFromCollection() {\n    this.collectionCountTokens = await this.countCollectionTokens();\n    if (!this.collectionCountTokens) {\n      this.warn('no token counter, please run Marketplace.getStrDomainFromCollection()');\n      return [];\n    }\n    const splitterList = [];\n    let tokenId = 1;\n    for (tokenId = 1; tokenId <= this.collectionCountTokens; tokenId++) {\n      try {\n        const splitterData = await this.nftContract.royaltyInfo(tokenId, 40000000);\n        splitterList.push(splitterData[0]);\n      } catch (error) {\n        this.error('Unexpected error fetching token:', error);\n        break;\n      }\n    }\n    return splitterList;\n  }\n\n  // Get total count of listings\n  async getListingCount() {\n    try {\n      const result = await this.marketplaceContract.lastListingId();\n      return Number(result);\n    } catch (error) {\n      this.error('Error getting listing count:', error);\n      return 0;\n    }\n  }\n\n  // Get paginated listings (smart pagination - only fetch what's needed)\n  async getListingsPaginated(startId, limit, activeOnly = true) {\n    const listedTokens = [];\n    const endId = startId + limit - 1;\n    this.log(`Fetching listings ${startId} to ${endId} (${activeOnly ? 'active only' : 'all'})`);\n\n    // Helper to delay between calls\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n    for (let listingId = startId; listingId <= endId; listingId++) {\n      try {\n        const listing = await this.marketplaceContract.getListing(listingId);\n\n        // Filter by active if needed\n        if (!activeOnly || listing.active) {\n          let tokenData;\n          try {\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (e) {\n            // Token data optional\n          }\n          listedTokens.push({\n            listingId,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined\n          });\n        }\n\n        // Small delay to avoid RPC spam\n        await delay(100);\n      } catch (e) {\n        // Listing doesn't exist or error, continue\n        await delay(50);\n        continue;\n      }\n    }\n    this.log(`Fetched ${listedTokens.length} listings from range ${startId}-${endId}`);\n    return listedTokens;\n  }\n\n  // Get all active listed tokens on marketplace (legacy method - for compatibility)\n  async getAllActiveListedDomainsOnMarketplaceWithTokenData() {\n    const listedTokens = [];\n    try {\n      let lastListingId = 0;\n\n      // Try to get lastListingId\n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n        this.log('lastListingId:', lastListingId);\n      } catch (error) {\n        this.warn('lastListingId() not available, using fallback method');\n        return await this.scanForListings(true);\n      }\n      if (lastListingId === 0) {\n        this.warn('No listings found - lastListingId is 0');\n        return [];\n      }\n\n      // Use pagination to fetch all (with delays)\n      return await this.getListingsPaginated(1, lastListingId, true);\n    } catch (error) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Fallback: Scan for listings without lastListingId\n  async scanForListings(activeOnly = true) {\n    const listedTokens = [];\n    const MAX_SCAN = 20; // Reduced to avoid RPC spam\n    let consecutiveFailures = 0;\n    let rpcErrorCount = 0;\n    this.warn('Scanning for listings (no lastListingId available)...');\n\n    // Helper to delay between calls\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n    for (let listingId = 1; listingId <= MAX_SCAN; listingId++) {\n      try {\n        // Exponential backoff if we've hit RPC errors\n        if (rpcErrorCount > 0) {\n          const backoffDelay = Math.min(1000 * Math.pow(2, rpcErrorCount), 5000);\n          this.log(`Backing off ${backoffDelay}ms before next call...`);\n          await delay(backoffDelay);\n        } else {\n          // Normal delay\n          await delay(300);\n        }\n        const listing = await this.marketplaceContract.getListing(listingId);\n\n        // Reset failure counters on success\n        consecutiveFailures = 0;\n        rpcErrorCount = Math.max(0, rpcErrorCount - 1); // Gradually reduce backoff\n\n        // Filter by active if needed\n        if (!activeOnly || listing.active) {\n          let tokenData;\n          try {\n            await delay(200); // Delay before token data\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (e) {\n            // Token data optional\n          }\n          listedTokens.push({\n            listingId,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined\n          });\n        }\n      } catch (e) {\n        var _e$message;\n        consecutiveFailures++;\n\n        // If RPC error, increase backoff\n        if ((_e$message = e.message) !== null && _e$message !== void 0 && _e$message.includes('Internal JSON-RPC') || e.code === -32603) {\n          rpcErrorCount++;\n          this.warn(`RPC error #${rpcErrorCount} at listing ${listingId}, backing off...`);\n\n          // If too many RPC errors, stop early\n          if (rpcErrorCount >= 3) {\n            this.warn(`Too many RPC errors, stopping scan early`);\n            break;\n          }\n        }\n\n        // Stop after 5 consecutive failures\n        if (consecutiveFailures >= 5) {\n          this.log(`Stopped scanning at listing ${listingId} after ${consecutiveFailures} failures`);\n          break;\n        }\n      }\n    }\n    this.log(`Found ${listedTokens.length} listings via scanning`);\n    return listedTokens;\n  }\n\n  // Get all listed tokens on marketplace (legacy - for compatibility)\n  async getAllListedDomainsOnMarketplaceWithTokenData() {\n    try {\n      let lastListingId = 0;\n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n      } catch (error) {\n        this.warn('lastListingId() not available, using fallback');\n        return await this.scanForListings(false);\n      }\n      if (lastListingId === 0) {\n        this.warn('No listings found');\n        return [];\n      }\n\n      // Use pagination to fetch all\n      return await this.getListingsPaginated(1, lastListingId, false);\n    } catch (error) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Get my all listed tokens on marketplace (legacy - fetches all)\n  async getMyAllListedDomainsOnMarketplaceWithTokenData() {\n    try {\n      const myAddress = (await this.signer.getAddress()).toLowerCase();\n      let lastListingId = 0;\n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n      } catch (error) {\n        this.warn('lastListingId() not available, using fallback');\n        const allListings = await this.scanForListings(false);\n        return allListings.filter(l => l.seller.toLowerCase() === myAddress);\n      }\n      if (lastListingId === 0) {\n        this.warn('No listings found');\n        return [];\n      }\n\n      // Fetch all listings for this user\n      const allListings = await this.getListingsPaginated(1, lastListingId, false);\n      return allListings.filter(l => l.seller.toLowerCase() === myAddress);\n    } catch (error) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Get paginated NFTs from collection\n  async getDomainsPaginated(startTokenId, limit, filterByOwner) {\n    const tokenList = [];\n    const endTokenId = startTokenId + limit - 1;\n    this.log(`Fetching tokens ${startTokenId} to ${endTokenId}`);\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n    const targetOwner = filterByOwner === null || filterByOwner === void 0 ? void 0 : filterByOwner.toLowerCase();\n    for (let tokenId = startTokenId; tokenId <= endTokenId; tokenId++) {\n      try {\n        // If filtering by owner, check ownership first\n        if (targetOwner) {\n          const owner = await this.nftContract.ownerOf(tokenId);\n          if (owner.toLowerCase() !== targetOwner) {\n            await delay(50);\n            continue;\n          }\n        }\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n        }\n        await delay(100);\n      } catch (error) {\n        // Token doesn't exist, continue\n        await delay(50);\n        continue;\n      }\n    }\n    this.log(`Fetched ${tokenList.length} tokens from range ${startTokenId}-${endTokenId}`);\n    return tokenList;\n  }\n\n  // Get available fee balance from a splitter\n  async getSplitterBalance(splitterAddress, walletAddress) {\n    try {\n      const contractInstance = new ethers.Contract(splitterAddress, RoyaltySplitterABI, this.signer);\n      const balance = await contractInstance.ethBalance(walletAddress);\n      return balance;\n    } catch (error) {\n      this.error('Unexpected error fetching balance:', error);\n      return null;\n    }\n  }\n\n  // Get all splitter balances for a given wallet across the collection\n  async getSplitterBalanceOfWallet(walletAddress) {\n    const balances = [];\n    try {\n      const splitterAddresses = await this.getAllSplitterContractsFromCollection();\n      if (!splitterAddresses || splitterAddresses.length === 0) {\n        this.warn('No splitter contracts found in collection.');\n        return balances;\n      }\n      for (const splitterAddress of splitterAddresses) {\n        try {\n          const contract = new ethers.Contract(splitterAddress, RoyaltySplitterABI, this.signer);\n          const rawBalance = await contract.ethBalance(walletAddress);\n          const balance = ethers.formatEther(rawBalance);\n          if (rawBalance > 0n) {\n            balances.push({\n              splitter: splitterAddress,\n              balance\n            });\n          }\n        } catch (innerErr) {\n          this.warn(`Failed to fetch balance from splitter: ${splitterAddress}`, innerErr.message);\n        }\n      }\n    } catch (error) {\n      this.error('Error fetching splitter balances:', error);\n    }\n    return balances;\n  }\n\n  // Owner only - Approve token for sale\n  async approveTokenForSale(tokenId) {\n    try {\n      const tx = await this.nftContract.approve(this.marketplaceAddress, tokenId);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error) {\n      this.error(`Error approve your NFT tokenId: ${tokenId}, check your ownership`);\n      return null;\n    }\n  }\n\n  // Withdraw royalty from a specific splitter\n  async withdrawRoyaltyFromSplitter(splitterAddress) {\n    try {\n      const contract = new ethers.Contract(splitterAddress, RoyaltySplitterABI, this.signer);\n      const walletAddress = await this.signer.getAddress();\n      const rawBalance = await contract.ethBalance(walletAddress);\n      if (rawBalance <= 0n) {\n        this.warn(`â­ Skipping ${splitterAddress}: no funds to withdraw.`);\n        return null;\n      }\n      const balance = ethers.formatEther(rawBalance);\n      const tx = await contract.withdraw();\n      if (!tx || !tx.hash) {\n        this.warn(`No transaction hash returned from withdraw() on ${splitterAddress}`);\n        return null;\n      }\n      const receipt = await tx.wait();\n      this.warn(`Withdrawn from splitter ${splitterAddress} | Tx: ${receipt.hash} | Amount: ${balance}`);\n      return {\n        splitter: splitterAddress,\n        transactionHash: receipt.hash,\n        withdrawn: balance\n      };\n    } catch (err) {\n      this.warn(`Failed to withdraw from splitter: ${splitterAddress} | ${err.message}`);\n      return null;\n    }\n  }\n\n  // Withdraw royalty fees from all existing splitter contracts\n  async withdrawAllRoyaltyFees() {\n    try {\n      const walletAddress = await this.signer.getAddress();\n      const splitterBalances = await this.getSplitterBalanceOfWallet(walletAddress);\n      if (!splitterBalances || splitterBalances.length === 0) {\n        this.warn('No splitter contracts with available balances found.');\n        return null;\n      }\n      const receipts = [];\n      for (const item of splitterBalances) {\n        const result = await this.withdrawRoyaltyFromSplitter(item.splitter);\n        if (result) {\n          receipts.push(result);\n        }\n      }\n      return receipts;\n    } catch (error) {\n      this.error('Error withdrawing all royalty fees:', error);\n      return null;\n    }\n  }\n\n  // Withdraw marketplace fees (only owner of the contract)\n  async withdrawMarketPlaceFees() {\n    const isAdmin = await this.isAdmin();\n    try {\n      if (!isAdmin) {\n        this.warn('You are not an admin of the Marketplace contract. Withdraw not allowed.');\n        return null;\n      }\n      const tx = await this.marketplaceContract.withdrawFees();\n      const receipt = await tx.wait();\n      this.warn(`Marketplace fees withdrawn successfully! Tx hash: ${receipt.hash}`);\n      return receipt.hash;\n    } catch (error) {\n      this.error('Error withdrawing marketplace fees, or check the fees balance');\n      return null;\n    }\n  }\n\n  // Check if connected wallet is admin\n  async isAdmin() {\n    try {\n      const ADMIN_ROLE = '0x0000000000000000000000000000000000000000000000000000000000000000';\n      const isAdmin = await this.nftContract.hasRole(ADMIN_ROLE, await this.signer.getAddress());\n      if (!isAdmin) {\n        this.warn('Please connect with an admin account before running isAdmin method.');\n      }\n      return isAdmin;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Admin only - Mint domain\n  async mintDomain(originalCreator, URI) {\n    if (!(await this.isAdmin())) return null;\n    try {\n      const tx = await this.nftContract.mint(originalCreator, URI);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error) {\n      this.error('Error minting domain NFT, check you are the owner of the contract, or have minter role');\n      return null;\n    }\n  }\n\n  // Logging methods\n  log(...args) {\n    if (this.develop) console.log(...args);\n  }\n  warn(...args) {\n    if (this.develop) console.warn(...args);\n  }\n  error(...args) {\n    if (this.develop) console.error(...args);\n  }\n\n  // Set develop mode on/off\n  setDevelopMode(enabled) {\n    this.develop = !!enabled;\n    this.warn(`Develop mode set to ${this.develop}`);\n  }\n}","map":{"version":3,"names":["ethers","MarketplaceABI","StrDomainsNFTABI","RoyaltySplitterABI","MarketplaceSDK","constructor","signer","marketplaceAddress","nftAddress","develop","provider","marketplaceContract","nftContract","collectionCountTokens","Contract","updateSigner","buyToken","listingId","listing","getListing","price","active","warn","formatEther","tx","buy","value","receipt","wait","hash","error","updateListing","newPrice","parseEther","listToken","tokenId","approveTokenForSale","approved","getApproved","cancelListing","getMarketplaceFees","fees","accruedFees","getTokenData","data","getStrDomainFromCollection","formattedToken","creator","mintTimestamp","Number","uri","lastPrice","toString","lastPriceTimestamp","e","getAllStrDomainsFromCollection","tokenList","consecutiveFailures","MAX_CONSECUTIVE_FAILURES","MAX_TOKENS","tokenData","push","_error$reason","code","reason","includes","length","getMyDomainsFromCollection","myTokenList","myAddress","getAddress","delay","ms","Promise","resolve","setTimeout","owner","ownerOf","toLowerCase","log","_error$reason2","_error$reason3","_error$message","_error$message2","message","countCollectionTokens","_error$reason4","_error$reason5","_error$message3","getAllSplitterContractsFromCollection","splitterList","splitterData","royaltyInfo","getListingCount","result","lastListingId","getListingsPaginated","startId","limit","activeOnly","listedTokens","endId","seller","strCollectionAddress","nft","undefined","getAllActiveListedDomainsOnMarketplaceWithTokenData","scanForListings","MAX_SCAN","rpcErrorCount","backoffDelay","Math","min","pow","max","_e$message","getAllListedDomainsOnMarketplaceWithTokenData","getMyAllListedDomainsOnMarketplaceWithTokenData","allListings","filter","l","getDomainsPaginated","startTokenId","filterByOwner","endTokenId","targetOwner","getSplitterBalance","splitterAddress","walletAddress","contractInstance","balance","ethBalance","getSplitterBalanceOfWallet","balances","splitterAddresses","contract","rawBalance","splitter","innerErr","approve","withdrawRoyaltyFromSplitter","withdraw","transactionHash","withdrawn","err","withdrawAllRoyaltyFees","splitterBalances","receipts","item","withdrawMarketPlaceFees","isAdmin","withdrawFees","ADMIN_ROLE","hasRole","mintDomain","originalCreator","URI","mint","args","console","setDevelopMode","enabled"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/src/sdk/MarketplaceSDK.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport MarketplaceABI from '../contracts/abis/Marketplace.json';\nimport StrDomainsNFTABI from '../contracts/abis/StrDomainsNFT.json';\nimport RoyaltySplitterABI from '../contracts/abis/RoyaltySplitter.json';\n\nexport interface TokenData {\n  creator: string;\n  mintTimestamp: number;\n  uri: string;\n  lastPrice: string;\n  lastPriceTimestamp: string;\n}\n\nexport interface FormattedToken extends TokenData {\n  tokenId: number;\n}\n\nexport interface Listing {\n  seller: string;\n  nft: string;\n  tokenId: bigint;\n  price: bigint;\n  active: boolean;\n}\n\nexport interface ListedToken {\n  listingId: number;\n  active: boolean;\n  seller: string;\n  tokenId: number;\n  price: string;\n  strCollectionAddress: string;\n  tokenData?: FormattedToken;\n}\n\nexport interface SplitterBalance {\n  splitter: string;\n  balance: string;\n}\n\nexport class MarketplaceSDK {\n  private provider: ethers.BrowserProvider;\n  private signer: ethers.JsonRpcSigner;\n  private marketplaceAddress: string;\n  private nftAddress: string;\n  private marketplaceContract: ethers.Contract;\n  private nftContract: ethers.Contract;\n  private develop: boolean;\n  public collectionCountTokens?: number;\n\n  constructor(\n    signer: ethers.JsonRpcSigner,\n    marketplaceAddress: string,\n    nftAddress: string,\n    develop: boolean = false\n  ) {\n    this.develop = develop;\n    this.signer = signer;\n    this.provider = signer.provider as ethers.BrowserProvider;\n    this.marketplaceAddress = marketplaceAddress;\n    this.nftAddress = nftAddress;\n\n    // Create contract instances\n    this.marketplaceContract = new ethers.Contract(\n      marketplaceAddress,\n      MarketplaceABI,\n      signer\n    );\n    this.nftContract = new ethers.Contract(nftAddress, StrDomainsNFTABI, signer);\n  }\n\n  // Update signer when wallet changes\n  updateSigner(signer: ethers.JsonRpcSigner) {\n    this.signer = signer;\n    this.provider = signer.provider as ethers.BrowserProvider;\n    \n    this.marketplaceContract = new ethers.Contract(\n      this.marketplaceAddress,\n      MarketplaceABI,\n      signer\n    );\n    this.nftContract = new ethers.Contract(\n      this.nftAddress,\n      StrDomainsNFTABI,\n      signer\n    );\n  }\n\n  // Buy a listed token\n  async buyToken(listingId: number): Promise<string | null> {\n    try {\n      const listing = await this.marketplaceContract.getListing(listingId);\n      const { price, active } = listing;\n\n      if (!active) {\n        this.warn('This listing is not active.');\n        return null;\n      }\n\n      this.warn(`Buying token for ${ethers.formatEther(price)} MATIC...`);\n      const tx = await this.marketplaceContract.buy(listingId, {\n        value: price,\n      });\n      const receipt = await tx.wait();\n\n      this.warn(`Purchase successful!`);\n      return receipt.hash;\n    } catch (error: any) {\n      this.error('Error purchasing token:', error);\n      return null;\n    }\n  }\n\n  // Update a listed token price\n  async updateListing(listingId: number, newPrice: string): Promise<string | null> {\n    try {\n      const tx = await this.marketplaceContract.updateListing(\n        listingId,\n        ethers.parseEther(newPrice)\n      );\n      this.warn(`Listing ${listingId} updated with new price: ${newPrice} MATIC`);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error('Error updating listing:', error);\n      return null;\n    }\n  }\n\n  // List a token on the marketplace\n  async listToken(tokenId: number, price: string): Promise<string | null> {\n    try {\n      await this.approveTokenForSale(tokenId);\n\n      const approved = await this.nftContract.getApproved(tokenId);\n\n      if (approved !== this.marketplaceAddress) {\n        this.warn(\n          `Please approve tokenId: ${tokenId} for Marketplace address: ${this.marketplaceAddress}, or check the Marketplace listings`\n        );\n        return null;\n      }\n\n      const tx = await this.marketplaceContract.listToken(\n        this.nftAddress,\n        tokenId,\n        ethers.parseEther(price)\n      );\n\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(`Error listing your tokenId: ${tokenId}, check your ownership`);\n      return null;\n    }\n  }\n\n  // Cancel a listing\n  async cancelListing(listingId: number): Promise<string | null> {\n    try {\n      const tx = await this.marketplaceContract.cancelListing(listingId);\n      const receipt = await tx.wait();\n      this.warn(`Listing ${listingId} has been cancelled.`);\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(\n        `Error cancelling listing, check the listingId: ${listingId} is active, or it exists`\n      );\n      return null;\n    }\n  }\n\n  // Get Marketplace fees\n  async getMarketplaceFees(): Promise<bigint | null> {\n    try {\n      const fees = await this.marketplaceContract.accruedFees();\n      return fees;\n    } catch (error: any) {\n      this.error('Error fetching fees details:', error);\n      return null;\n    }\n  }\n\n  // Get listing details\n  async getListing(listingId: number): Promise<Listing | null> {\n    try {\n      const listing = await this.marketplaceContract.getListing(listingId);\n      return listing;\n    } catch (error: any) {\n      this.error('Error fetching listing details:', error);\n      return null;\n    }\n  }\n\n  // Get tokenData from collection\n  async getTokenData(tokenId: number): Promise<any> {\n    try {\n      const data = await this.nftContract.getTokenData(tokenId);\n      return data;\n    } catch (error: any) {\n      this.error('Getting token:', error);\n      return null;\n    }\n  }\n\n  // Get token data from collection\n  async getStrDomainFromCollection(tokenId: number): Promise<FormattedToken | null> {\n    try {\n      const data = await this.nftContract.getTokenData(tokenId);\n      const formattedToken: FormattedToken = {\n        tokenId: tokenId,\n        creator: data[0],\n        mintTimestamp: Number(data[1]),\n        uri: data[2],\n        lastPrice: data[3].toString(),\n        lastPriceTimestamp: data[4].toString(),\n      };\n\n      return formattedToken;\n    } catch (e: any) {\n      // Don't log error, just return null\n      return null;\n    }\n  }\n\n  // Scraping all tokens from the collection\n  async getAllStrDomainsFromCollection(): Promise<FormattedToken[]> {\n    const tokenList: FormattedToken[] = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 50; // Limit to avoid RPC issues\n    \n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n          consecutiveFailures = 0;\n        } else {\n          consecutiveFailures++;\n        }\n        tokenId++;\n      } catch (error: any) {\n        consecutiveFailures++;\n        if (\n          error.code === 'CALL_EXCEPTION' &&\n          error.reason?.includes('ERC721NonexistentToken')\n        ) {\n          tokenId++;\n          continue;\n        }\n        this.warn(`Error at token ${tokenId}, continuing...`);\n        tokenId++;\n      }\n    }\n\n    this.collectionCountTokens = tokenList.length;\n    this.warn(`Found ${tokenList.length} tokens in collection`);\n    return tokenList;\n  }\n\n  // Fetch all NFTs from the collection that belong to the connected wallet\n  async getMyDomainsFromCollection(): Promise<FormattedToken[]> {\n    const myTokenList: FormattedToken[] = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 20; // Reduced to avoid RPC issues\n\n    const myAddress = await this.signer.getAddress();\n    \n    // Helper to delay between calls\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const owner = await this.nftContract.ownerOf(tokenId);\n\n        if (owner.toLowerCase() === myAddress.toLowerCase()) {\n          const tokenData = await this.getStrDomainFromCollection(tokenId);\n          if (tokenData) {\n            myTokenList.push(tokenData);\n            this.log(`Found your domain: Token #${tokenId}`);\n          }\n        }\n\n        consecutiveFailures = 0;\n        tokenId++;\n        \n        // Small delay to avoid RPC rate limiting\n        await delay(100);\n      } catch (error: any) {\n        consecutiveFailures++;\n        \n        if (\n          error.code === 'CALL_EXCEPTION' &&\n          (error.reason?.includes('ERC721NonexistentToken') || \n           error.reason?.includes('nonexistent') ||\n           error.message?.includes('could not decode'))\n        ) {\n          tokenId++;\n          await delay(100);\n          continue;\n        }\n\n        // RPC error - wait longer before continuing\n        if (error.message?.includes('Internal JSON-RPC')) {\n          this.warn(`RPC rate limit hit at token ${tokenId}, slowing down...`);\n          await delay(500);\n        }\n        \n        this.warn(`Error at tokenId ${tokenId}, continuing...`);\n        tokenId++;\n        await delay(200);\n      }\n    }\n\n    this.warn(`Found ${myTokenList.length} domains owned by you`);\n    return myTokenList;\n  }\n\n  // Count all the tokens from the collection\n  async countCollectionTokens(): Promise<number> {\n    const tokenList: FormattedToken[] = [];\n    let tokenId = 1;\n    let consecutiveFailures = 0;\n    const MAX_CONSECUTIVE_FAILURES = 3;\n    const MAX_TOKENS = 50; // Limit to avoid RPC issues\n    \n    while (tokenId <= MAX_TOKENS && consecutiveFailures < MAX_CONSECUTIVE_FAILURES) {\n      try {\n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n          consecutiveFailures = 0;\n        } else {\n          consecutiveFailures++;\n        }\n        tokenId++;\n      } catch (error: any) {\n        consecutiveFailures++;\n        if (\n          error.code === 'CALL_EXCEPTION' &&\n          (error.reason?.includes('ERC721NonexistentToken') ||\n           error.reason?.includes('nonexistent') ||\n           error.message?.includes('could not decode'))\n        ) {\n          tokenId++;\n          continue;\n        }\n        this.warn(`Error at token ${tokenId}, continuing...`);\n        tokenId++;\n      }\n    }\n\n    this.collectionCountTokens = tokenList.length;\n    this.warn(`Counted ${tokenList.length} tokens in collection`);\n    return tokenList.length;\n  }\n\n  // Scraping all splitter contracts from the collection\n  async getAllSplitterContractsFromCollection(): Promise<string[]> {\n    this.collectionCountTokens = await this.countCollectionTokens();\n    if (!this.collectionCountTokens) {\n      this.warn(\n        'no token counter, please run Marketplace.getStrDomainFromCollection()'\n      );\n      return [];\n    }\n    const splitterList: string[] = [];\n    let tokenId = 1;\n    for (tokenId = 1; tokenId <= this.collectionCountTokens; tokenId++) {\n      try {\n        const splitterData = await this.nftContract.royaltyInfo(tokenId, 40000000);\n        splitterList.push(splitterData[0]);\n      } catch (error: any) {\n        this.error('Unexpected error fetching token:', error);\n        break;\n      }\n    }\n\n    return splitterList;\n  }\n\n  // Get total count of listings\n  async getListingCount(): Promise<number> {\n    try {\n      const result = await this.marketplaceContract.lastListingId();\n      return Number(result);\n    } catch (error: any) {\n      this.error('Error getting listing count:', error);\n      return 0;\n    }\n  }\n\n  // Get paginated listings (smart pagination - only fetch what's needed)\n  async getListingsPaginated(\n    startId: number,\n    limit: number,\n    activeOnly: boolean = true\n  ): Promise<ListedToken[]> {\n    const listedTokens: ListedToken[] = [];\n    const endId = startId + limit - 1;\n    \n    this.log(`Fetching listings ${startId} to ${endId} (${activeOnly ? 'active only' : 'all'})`);\n    \n    // Helper to delay between calls\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    \n    for (let listingId = startId; listingId <= endId; listingId++) {\n      try {\n        const listing = await this.marketplaceContract.getListing(listingId);\n\n        // Filter by active if needed\n        if (!activeOnly || listing.active) {\n          let tokenData;\n          try {\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (e) {\n            // Token data optional\n          }\n\n          listedTokens.push({\n            listingId,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined,\n          });\n        }\n        \n        // Small delay to avoid RPC spam\n        await delay(100);\n      } catch (e: any) {\n        // Listing doesn't exist or error, continue\n        await delay(50);\n        continue;\n      }\n    }\n\n    this.log(`Fetched ${listedTokens.length} listings from range ${startId}-${endId}`);\n    return listedTokens;\n  }\n\n  // Get all active listed tokens on marketplace (legacy method - for compatibility)\n  async getAllActiveListedDomainsOnMarketplaceWithTokenData(): Promise<ListedToken[]> {\n    const listedTokens: ListedToken[] = [];\n    \n    try {\n      let lastListingId: number = 0;\n      \n      // Try to get lastListingId\n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n        this.log('lastListingId:', lastListingId);\n      } catch (error: any) {\n        this.warn('lastListingId() not available, using fallback method');\n        return await this.scanForListings(true);\n      }\n\n      if (lastListingId === 0) {\n        this.warn('No listings found - lastListingId is 0');\n        return [];\n      }\n\n      // Use pagination to fetch all (with delays)\n      return await this.getListingsPaginated(1, lastListingId, true);\n    } catch (error: any) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Fallback: Scan for listings without lastListingId\n  private async scanForListings(activeOnly: boolean = true): Promise<ListedToken[]> {\n    const listedTokens: ListedToken[] = [];\n    const MAX_SCAN = 20; // Reduced to avoid RPC spam\n    let consecutiveFailures = 0;\n    let rpcErrorCount = 0;\n    \n    this.warn('Scanning for listings (no lastListingId available)...');\n    \n    // Helper to delay between calls\n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    \n    for (let listingId = 1; listingId <= MAX_SCAN; listingId++) {\n      try {\n        // Exponential backoff if we've hit RPC errors\n        if (rpcErrorCount > 0) {\n          const backoffDelay = Math.min(1000 * Math.pow(2, rpcErrorCount), 5000);\n          this.log(`Backing off ${backoffDelay}ms before next call...`);\n          await delay(backoffDelay);\n        } else {\n          // Normal delay\n          await delay(300);\n        }\n        \n        const listing = await this.marketplaceContract.getListing(listingId);\n        \n        // Reset failure counters on success\n        consecutiveFailures = 0;\n        rpcErrorCount = Math.max(0, rpcErrorCount - 1); // Gradually reduce backoff\n        \n        // Filter by active if needed\n        if (!activeOnly || listing.active) {\n          let tokenData;\n          try {\n            await delay(200); // Delay before token data\n            tokenData = await this.getStrDomainFromCollection(Number(listing.tokenId));\n          } catch (e) {\n            // Token data optional\n          }\n\n          listedTokens.push({\n            listingId,\n            active: listing.active,\n            seller: listing.seller,\n            tokenId: Number(listing.tokenId),\n            price: ethers.formatEther(listing.price),\n            strCollectionAddress: listing.nft,\n            tokenData: tokenData || undefined,\n          });\n        }\n      } catch (e: any) {\n        consecutiveFailures++;\n        \n        // If RPC error, increase backoff\n        if (e.message?.includes('Internal JSON-RPC') || e.code === -32603) {\n          rpcErrorCount++;\n          this.warn(`RPC error #${rpcErrorCount} at listing ${listingId}, backing off...`);\n          \n          // If too many RPC errors, stop early\n          if (rpcErrorCount >= 3) {\n            this.warn(`Too many RPC errors, stopping scan early`);\n            break;\n          }\n        }\n        \n        // Stop after 5 consecutive failures\n        if (consecutiveFailures >= 5) {\n          this.log(`Stopped scanning at listing ${listingId} after ${consecutiveFailures} failures`);\n          break;\n        }\n      }\n    }\n    \n    this.log(`Found ${listedTokens.length} listings via scanning`);\n    return listedTokens;\n  }\n\n  // Get all listed tokens on marketplace (legacy - for compatibility)\n  async getAllListedDomainsOnMarketplaceWithTokenData(): Promise<ListedToken[]> {\n    try {\n      let lastListingId: number = 0;\n      \n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n      } catch (error: any) {\n        this.warn('lastListingId() not available, using fallback');\n        return await this.scanForListings(false);\n      }\n\n      if (lastListingId === 0) {\n        this.warn('No listings found');\n        return [];\n      }\n\n      // Use pagination to fetch all\n      return await this.getListingsPaginated(1, lastListingId, false);\n    } catch (error: any) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Get my all listed tokens on marketplace (legacy - fetches all)\n  async getMyAllListedDomainsOnMarketplaceWithTokenData(): Promise<ListedToken[]> {\n    try {\n      const myAddress = (await this.signer.getAddress()).toLowerCase();\n      let lastListingId: number = 0;\n      \n      try {\n        const result = await this.marketplaceContract.lastListingId();\n        lastListingId = Number(result);\n      } catch (error: any) {\n        this.warn('lastListingId() not available, using fallback');\n        const allListings = await this.scanForListings(false);\n        return allListings.filter(l => l.seller.toLowerCase() === myAddress);\n      }\n\n      if (lastListingId === 0) {\n        this.warn('No listings found');\n        return [];\n      }\n\n      // Fetch all listings for this user\n      const allListings = await this.getListingsPaginated(1, lastListingId, false);\n      return allListings.filter(l => l.seller.toLowerCase() === myAddress);\n    } catch (error: any) {\n      this.error('Error fetching listed tokens:', error);\n      return [];\n    }\n  }\n\n  // Get paginated NFTs from collection\n  async getDomainsPaginated(\n    startTokenId: number,\n    limit: number,\n    filterByOwner?: string\n  ): Promise<FormattedToken[]> {\n    const tokenList: FormattedToken[] = [];\n    const endTokenId = startTokenId + limit - 1;\n    \n    this.log(`Fetching tokens ${startTokenId} to ${endTokenId}`);\n    \n    const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n    const targetOwner = filterByOwner?.toLowerCase();\n    \n    for (let tokenId = startTokenId; tokenId <= endTokenId; tokenId++) {\n      try {\n        // If filtering by owner, check ownership first\n        if (targetOwner) {\n          const owner = await this.nftContract.ownerOf(tokenId);\n          if (owner.toLowerCase() !== targetOwner) {\n            await delay(50);\n            continue;\n          }\n        }\n        \n        const tokenData = await this.getStrDomainFromCollection(tokenId);\n        if (tokenData) {\n          tokenList.push(tokenData);\n        }\n        \n        await delay(100);\n      } catch (error: any) {\n        // Token doesn't exist, continue\n        await delay(50);\n        continue;\n      }\n    }\n\n    this.log(`Fetched ${tokenList.length} tokens from range ${startTokenId}-${endTokenId}`);\n    return tokenList;\n  }\n\n  // Get available fee balance from a splitter\n  async getSplitterBalance(\n    splitterAddress: string,\n    walletAddress: string\n  ): Promise<bigint | null> {\n    try {\n      const contractInstance = new ethers.Contract(\n        splitterAddress,\n        RoyaltySplitterABI,\n        this.signer\n      );\n      const balance = await contractInstance.ethBalance(walletAddress);\n      return balance;\n    } catch (error: any) {\n      this.error('Unexpected error fetching balance:', error);\n      return null;\n    }\n  }\n\n  // Get all splitter balances for a given wallet across the collection\n  async getSplitterBalanceOfWallet(walletAddress: string): Promise<SplitterBalance[]> {\n    const balances: SplitterBalance[] = [];\n\n    try {\n      const splitterAddresses = await this.getAllSplitterContractsFromCollection();\n\n      if (!splitterAddresses || splitterAddresses.length === 0) {\n        this.warn('No splitter contracts found in collection.');\n        return balances;\n      }\n\n      for (const splitterAddress of splitterAddresses) {\n        try {\n          const contract = new ethers.Contract(\n            splitterAddress,\n            RoyaltySplitterABI,\n            this.signer\n          );\n          const rawBalance = await contract.ethBalance(walletAddress);\n          const balance = ethers.formatEther(rawBalance);\n\n          if (rawBalance > 0n) {\n            balances.push({\n              splitter: splitterAddress,\n              balance,\n            });\n          }\n        } catch (innerErr: any) {\n          this.warn(\n            `Failed to fetch balance from splitter: ${splitterAddress}`,\n            innerErr.message\n          );\n        }\n      }\n    } catch (error: any) {\n      this.error('Error fetching splitter balances:', error);\n    }\n\n    return balances;\n  }\n\n  // Owner only - Approve token for sale\n  async approveTokenForSale(tokenId: number): Promise<string | null> {\n    try {\n      const tx = await this.nftContract.approve(this.marketplaceAddress, tokenId);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(\n        `Error approve your NFT tokenId: ${tokenId}, check your ownership`\n      );\n      return null;\n    }\n  }\n\n  // Withdraw royalty from a specific splitter\n  async withdrawRoyaltyFromSplitter(splitterAddress: string): Promise<any> {\n    try {\n      const contract = new ethers.Contract(\n        splitterAddress,\n        RoyaltySplitterABI,\n        this.signer\n      );\n      const walletAddress = await this.signer.getAddress();\n      const rawBalance = await contract.ethBalance(walletAddress);\n\n      if (rawBalance <= 0n) {\n        this.warn(`â­ Skipping ${splitterAddress}: no funds to withdraw.`);\n        return null;\n      }\n\n      const balance = ethers.formatEther(rawBalance);\n\n      const tx = await contract.withdraw();\n      if (!tx || !tx.hash) {\n        this.warn(\n          `No transaction hash returned from withdraw() on ${splitterAddress}`\n        );\n        return null;\n      }\n\n      const receipt = await tx.wait();\n\n      this.warn(\n        `Withdrawn from splitter ${splitterAddress} | Tx: ${receipt.hash} | Amount: ${balance}`\n      );\n\n      return {\n        splitter: splitterAddress,\n        transactionHash: receipt.hash,\n        withdrawn: balance,\n      };\n    } catch (err: any) {\n      this.warn(\n        `Failed to withdraw from splitter: ${splitterAddress} | ${err.message}`\n      );\n      return null;\n    }\n  }\n\n  // Withdraw royalty fees from all existing splitter contracts\n  async withdrawAllRoyaltyFees(): Promise<any[] | null> {\n    try {\n      const walletAddress = await this.signer.getAddress();\n      const splitterBalances = await this.getSplitterBalanceOfWallet(walletAddress);\n\n      if (!splitterBalances || splitterBalances.length === 0) {\n        this.warn('No splitter contracts with available balances found.');\n        return null;\n      }\n\n      const receipts = [];\n\n      for (const item of splitterBalances) {\n        const result = await this.withdrawRoyaltyFromSplitter(item.splitter);\n        if (result) {\n          receipts.push(result);\n        }\n      }\n\n      return receipts;\n    } catch (error: any) {\n      this.error('Error withdrawing all royalty fees:', error);\n      return null;\n    }\n  }\n\n  // Withdraw marketplace fees (only owner of the contract)\n  async withdrawMarketPlaceFees(): Promise<string | null> {\n    const isAdmin = await this.isAdmin();\n\n    try {\n      if (!isAdmin) {\n        this.warn(\n          'You are not an admin of the Marketplace contract. Withdraw not allowed.'\n        );\n        return null;\n      }\n\n      const tx = await this.marketplaceContract.withdrawFees();\n      const receipt = await tx.wait();\n\n      this.warn(`Marketplace fees withdrawn successfully! Tx hash: ${receipt.hash}`);\n\n      return receipt.hash;\n    } catch (error: any) {\n      this.error('Error withdrawing marketplace fees, or check the fees balance');\n      return null;\n    }\n  }\n\n  // Check if connected wallet is admin\n  async isAdmin(): Promise<boolean> {\n    try {\n      const ADMIN_ROLE =\n        '0x0000000000000000000000000000000000000000000000000000000000000000';\n      const isAdmin = await this.nftContract.hasRole(\n        ADMIN_ROLE,\n        await this.signer.getAddress()\n      );\n      if (!isAdmin) {\n        this.warn('Please connect with an admin account before running isAdmin method.');\n      }\n      return isAdmin;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Admin only - Mint domain\n  async mintDomain(originalCreator: string, URI: string): Promise<string | null> {\n    if (!(await this.isAdmin())) return null;\n\n    try {\n      const tx = await this.nftContract.mint(originalCreator, URI);\n      const receipt = await tx.wait();\n      return receipt.hash;\n    } catch (error: any) {\n      this.error(\n        'Error minting domain NFT, check you are the owner of the contract, or have minter role'\n      );\n      return null;\n    }\n  }\n\n  // Logging methods\n  log(...args: any[]) {\n    if (this.develop) console.log(...args);\n  }\n\n  warn(...args: any[]) {\n    if (this.develop) console.warn(...args);\n  }\n\n  error(...args: any[]) {\n    if (this.develop) console.error(...args);\n  }\n\n  // Set develop mode on/off\n  setDevelopMode(enabled: boolean) {\n    this.develop = !!enabled;\n    this.warn(`Develop mode set to ${this.develop}`);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}