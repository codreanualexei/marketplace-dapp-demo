{"ast":null,"code":"import _objectSpread from \"/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as AccessList from './AccessList.js';\nimport * as Blobs from './Blobs.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Kzg from './Kzg.js';\nimport * as Rlp from './Rlp.js';\nimport * as Signature from './Signature.js';\nimport * as TransactionEnvelope from './TransactionEnvelope.js';\nimport * as TransactionEnvelopeEip1559 from './TransactionEnvelopeEip1559.js';\nexport const serializedType = '0x03';\nexport const type = 'eip4844';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844, Value } from 'ox'\n *\n * TransactionEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: EmptyBlobVersionedHashesError: Blob versioned hashes must not be empty.\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(envelope) {\n  const {\n    blobVersionedHashes\n  } = envelope;\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new Blobs.EmptyBlobVersionedHashesError();\n    for (const hash of blobVersionedHashes) {\n      const size = Hex.size(hash);\n      const version = Hex.toNumber(Hex.slice(hash, 0, 1));\n      if (size !== 32) throw new Blobs.InvalidVersionedHashSizeError({\n        hash,\n        size\n      });\n      if (version !== Kzg.versionedHashVersion) throw new Blobs.InvalidVersionedHashVersionError({\n        hash,\n        version\n      });\n    }\n  }\n  TransactionEnvelopeEip1559.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip4844.deserialize('0x03ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   type: 'eip4844',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(serialized) {\n  const transactionOrWrapperArray = Rlp.toHex(Hex.slice(serialized, 1));\n  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;\n  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;\n  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r, s] = transactionArray;\n  const [blobs, commitments, proofs] = wrapperArray;\n  if (!(transactionArray.length === 11 || transactionArray.length === 14)) throw new TransactionEnvelope.InvalidSerializedError({\n    attributes: _objectSpread({\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList\n    }, transactionArray.length > 9 ? {\n      yParity,\n      r,\n      s\n    } : {}),\n    serialized,\n    type\n  });\n  let transaction = {\n    blobVersionedHashes: blobVersionedHashes,\n    chainId: Number(chainId),\n    type\n  };\n  if (Hex.validate(to) && to !== '0x') transaction.to = to;\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas);\n  if (Hex.validate(data) && data !== '0x') transaction.data = data;\n  if (Hex.validate(nonce)) transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce);\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value);\n  if (Hex.validate(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x') transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = BigInt(maxFeePerGas);\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n  if ((accessList === null || accessList === void 0 ? void 0 : accessList.length) !== 0 && accessList !== '0x') transaction.accessList = AccessList.fromTupleList(accessList);\n  if (blobs && commitments && proofs) transaction.sidecars = Blobs.toSidecars(blobs, {\n    commitments: commitments,\n    proofs: proofs\n  });\n  const signature = r && s && yParity ? Signature.fromTuple([yParity, r, s]) : undefined;\n  if (signature) transaction = _objectSpread(_objectSpread({}, transaction), signature);\n  assert(transaction);\n  return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-4844 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(sidecars)\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerBlobGas: 3000000000n,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-4844 Transaction Envelope from a {@link ox#TransactionEnvelopeEip4844.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip4844.from('0x03f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-4844 Transaction Envelope.\n */\nexport function from(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    signature\n  } = options;\n  const envelope_ = typeof envelope === 'string' ? deserialize(envelope) : envelope;\n  assert(envelope_);\n  return _objectSpread(_objectSpread(_objectSpread({}, envelope_), signature ? Signature.from(signature) : {}), {}, {\n    type: 'eip4844'\n  });\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip4844.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(envelope) {\n  return hash(envelope, {\n    presign: true\n  });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const hash = TransactionEnvelopeEip4844.hash(envelope) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-4844 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    presign\n  } = options;\n  return Hash.keccak256(serialize(_objectSpread(_objectSpread({}, envelope), presign ? {\n    sidecars: undefined,\n    r: undefined,\n    s: undefined,\n    yParity: undefined,\n    v: undefined\n  } : {})));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(blobs)\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(envelope) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    blobVersionedHashes,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data\n  } = envelope;\n  assert(envelope);\n  const accessTupleList = AccessList.toTupleList(accessList);\n  const signature = Signature.extract(options.signature || envelope);\n  const serialized = [Hex.fromNumber(chainId), nonce ? Hex.fromNumber(nonce) : '0x', maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x', maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x', gas ? Hex.fromNumber(gas) : '0x', to !== null && to !== void 0 ? to : '0x', value ? Hex.fromNumber(value) : '0x', data !== null && data !== void 0 ? data : '0x', accessTupleList, maxFeePerBlobGas ? Hex.fromNumber(maxFeePerBlobGas) : '0x', blobVersionedHashes !== null && blobVersionedHashes !== void 0 ? blobVersionedHashes : [], ...(signature ? Signature.toTuple(signature) : [])];\n  const sidecars = options.sidecars || envelope.sidecars;\n  const blobs = [];\n  const commitments = [];\n  const proofs = [];\n  if (sidecars) for (let i = 0; i < sidecars.length; i++) {\n    const {\n      blob,\n      commitment,\n      proof\n    } = sidecars[i];\n    blobs.push(blob);\n    commitments.push(commitment);\n    proofs.push(proof);\n  }\n  return Hex.concat('0x03', sidecars ?\n  // If sidecars are provided, envelope turns into a \"network wrapper\":\n  Rlp.fromHex([serialized, blobs, commitments, proofs]) :\n  // Otherwise, standard envelope is used:\n  Rlp.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} to an {@link ox#TransactionEnvelopeEip4844.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcRequest, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerBlobGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip4844.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-4844 transaction envelope to convert.\n * @returns An RPC-formatted EIP-4844 transaction envelope.\n */\nexport function toRpc(envelope) {\n  var _envelope$data;\n  const signature = Signature.extract(envelope);\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, envelope), {}, {\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: (_envelope$data = envelope.data) !== null && _envelope$data !== void 0 ? _envelope$data : envelope.input\n  }, typeof envelope.gas === 'bigint' ? {\n    gas: Hex.fromNumber(envelope.gas)\n  } : {}), typeof envelope.nonce === 'bigint' ? {\n    nonce: Hex.fromNumber(envelope.nonce)\n  } : {}), typeof envelope.value === 'bigint' ? {\n    value: Hex.fromNumber(envelope.value)\n  } : {}), typeof envelope.maxFeePerBlobGas === 'bigint' ? {\n    maxFeePerBlobGas: Hex.fromNumber(envelope.maxFeePerBlobGas)\n  } : {}), typeof envelope.maxFeePerGas === 'bigint' ? {\n    maxFeePerGas: Hex.fromNumber(envelope.maxFeePerGas)\n  } : {}), typeof envelope.maxPriorityFeePerGas === 'bigint' ? {\n    maxPriorityFeePerGas: Hex.fromNumber(envelope.maxPriorityFeePerGas)\n  } : {}), {}, {\n    type: '0x3'\n  }, signature ? Signature.toRpc(signature) : {});\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(envelope) {\n  try {\n    assert(envelope);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}","map":{"version":3,"names":["AccessList","Blobs","Hash","Hex","Kzg","Rlp","Signature","TransactionEnvelope","TransactionEnvelopeEip1559","serializedType","type","assert","envelope","blobVersionedHashes","length","EmptyBlobVersionedHashesError","hash","size","version","toNumber","slice","InvalidVersionedHashSizeError","versionedHashVersion","InvalidVersionedHashVersionError","deserialize","serialized","transactionOrWrapperArray","toHex","hasNetworkWrapper","transactionArray","wrapperArray","chainId","nonce","maxPriorityFeePerGas","maxFeePerGas","gas","to","value","data","accessList","maxFeePerBlobGas","yParity","r","s","blobs","commitments","proofs","InvalidSerializedError","attributes","_objectSpread","transaction","Number","validate","BigInt","fromTupleList","sidecars","toSidecars","signature","fromTuple","undefined","from","options","arguments","envelope_","getSignPayload","presign","keccak256","serialize","v","accessTupleList","toTupleList","extract","fromNumber","toTuple","i","blob","commitment","proof","push","concat","fromHex","toRpc","_envelope$data","input","_unused"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/TransactionEnvelopeEip4844.ts"],"sourcesContent":["import * as AccessList from './AccessList.js'\nimport * as Blobs from './Blobs.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type {\n  Assign,\n  Compute,\n  PartialBy,\n  UnionPartialBy,\n} from './internal/types.js'\nimport * as Kzg from './Kzg.js'\nimport * as Rlp from './Rlp.js'\nimport * as Signature from './Signature.js'\nimport * as TransactionEnvelope from './TransactionEnvelope.js'\nimport * as TransactionEnvelopeEip1559 from './TransactionEnvelopeEip1559.js'\n\nexport type TransactionEnvelopeEip4844<\n  signed extends boolean = boolean,\n  bigintType = bigint,\n  numberType = number,\n  type extends string = Type,\n> = Compute<\n  TransactionEnvelope.Base<type, signed, bigintType, numberType> & {\n    /** EIP-2930 Access List. */\n    accessList?: AccessList.AccessList | undefined\n    /** Versioned hashes of blobs to be included in the transaction. */\n    blobVersionedHashes: readonly Hex.Hex[]\n    /** Maximum total fee per gas sender is willing to pay for blob gas (in wei). */\n    maxFeePerBlobGas?: bigintType | undefined\n    /** Total fee per gas in wei (gasPrice/baseFeePerGas + maxPriorityFeePerGas). */\n    maxFeePerGas?: bigintType | undefined\n    /** Max priority fee per gas (in wei). */\n    maxPriorityFeePerGas?: bigintType | undefined\n    /** The sidecars associated with this transaction. When defined, the envelope is in the \"network wrapper\" format. */\n    sidecars?: readonly Blobs.BlobSidecar<Hex.Hex>[] | undefined\n  }\n>\n\nexport type Rpc<signed extends boolean = boolean> = TransactionEnvelopeEip4844<\n  signed,\n  Hex.Hex,\n  Hex.Hex,\n  '0x3'\n>\n\nexport type Serialized = `${SerializedType}${string}`\n\nexport const serializedType = '0x03' as const\nexport type SerializedType = typeof serializedType\n\nexport type Signed = TransactionEnvelopeEip4844<true>\n\nexport const type = 'eip4844' as const\nexport type Type = 'eip4844'\n\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844, Value } from 'ox'\n *\n * TransactionEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: EmptyBlobVersionedHashesError: Blob versioned hashes must not be empty.\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nexport function assert(\n  envelope: PartialBy<TransactionEnvelopeEip4844, 'type'>,\n) {\n  const { blobVersionedHashes } = envelope\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0)\n      throw new Blobs.EmptyBlobVersionedHashesError()\n    for (const hash of blobVersionedHashes) {\n      const size = Hex.size(hash)\n      const version = Hex.toNumber(Hex.slice(hash, 0, 1))\n      if (size !== 32)\n        throw new Blobs.InvalidVersionedHashSizeError({ hash, size })\n      if (version !== Kzg.versionedHashVersion)\n        throw new Blobs.InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  TransactionEnvelopeEip1559.assert(\n    envelope as {} as TransactionEnvelopeEip1559.TransactionEnvelopeEip1559,\n  )\n}\n\nexport declare namespace assert {\n  type ErrorType =\n    | TransactionEnvelopeEip1559.assert.ErrorType\n    | Hex.size.ErrorType\n    | Hex.toNumber.ErrorType\n    | Hex.slice.ErrorType\n    | Blobs.EmptyBlobVersionedHashesError\n    | Blobs.InvalidVersionedHashSizeError\n    | Blobs.InvalidVersionedHashVersionError\n    | Errors.GlobalErrorType\n}\n\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip4844.deserialize('0x03ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   type: 'eip4844',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nexport function deserialize(\n  serialized: Serialized,\n): Compute<TransactionEnvelopeEip4844> {\n  const transactionOrWrapperArray = Rlp.toHex(Hex.slice(serialized, 1))\n\n  const hasNetworkWrapper = transactionOrWrapperArray.length === 4\n\n  const transactionArray = hasNetworkWrapper\n    ? transactionOrWrapperArray[0]!\n    : transactionOrWrapperArray\n  const wrapperArray = hasNetworkWrapper\n    ? transactionOrWrapperArray.slice(1)\n    : []\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    maxFeePerBlobGas,\n    blobVersionedHashes,\n    yParity,\n    r,\n    s,\n  ] = transactionArray\n  const [blobs, commitments, proofs] = wrapperArray\n\n  if (!(transactionArray.length === 11 || transactionArray.length === 14))\n    throw new TransactionEnvelope.InvalidSerializedError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 9\n          ? {\n              yParity,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serialized,\n      type,\n    })\n\n  let transaction = {\n    blobVersionedHashes: blobVersionedHashes as Hex.Hex[],\n    chainId: Number(chainId),\n    type,\n  } as TransactionEnvelopeEip4844\n  if (Hex.validate(to) && to !== '0x') transaction.to = to\n  if (Hex.validate(gas) && gas !== '0x') transaction.gas = BigInt(gas)\n  if (Hex.validate(data) && data !== '0x') transaction.data = data\n  if (Hex.validate(nonce))\n    transaction.nonce = nonce === '0x' ? 0n : BigInt(nonce)\n  if (Hex.validate(value) && value !== '0x') transaction.value = BigInt(value)\n  if (Hex.validate(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')\n    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas)\n  if (Hex.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = BigInt(maxFeePerGas)\n  if (Hex.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas)\n  if (accessList?.length !== 0 && accessList !== '0x')\n    transaction.accessList = AccessList.fromTupleList(accessList as any)\n  if (blobs && commitments && proofs)\n    transaction.sidecars = Blobs.toSidecars(blobs as Hex.Hex[], {\n      commitments: commitments as Hex.Hex[],\n      proofs: proofs as Hex.Hex[],\n    })\n\n  const signature =\n    r && s && yParity\n      ? Signature.fromTuple([yParity as Hex.Hex, r as Hex.Hex, s as Hex.Hex])\n      : undefined\n  if (signature)\n    transaction = {\n      ...transaction,\n      ...signature,\n    } as TransactionEnvelopeEip4844\n\n  assert(transaction)\n\n  return transaction\n}\n\nexport declare namespace deserialize {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Converts an arbitrary transaction object into an EIP-4844 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   chainId: 1,\n *   blobVersionedHashes,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(sidecars)\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip4844.from(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerBlobGas: 3000000000n,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-4844 Transaction Envelope from a {@link ox#TransactionEnvelopeEip4844.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip4844.from('0x03f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   blobVersionedHashes: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip4844',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-4844 Transaction Envelope.\n */\nexport function from<\n  const envelope extends\n    | UnionPartialBy<TransactionEnvelopeEip4844, 'type'>\n    | Serialized,\n  const signature extends Signature.Signature | undefined = undefined,\n>(\n  envelope:\n    | envelope\n    | UnionPartialBy<TransactionEnvelopeEip4844, 'type'>\n    | Serialized,\n  options: from.Options<signature> = {},\n): from.ReturnType<envelope, signature> {\n  const { signature } = options\n\n  const envelope_ = (\n    typeof envelope === 'string' ? deserialize(envelope) : envelope\n  ) as TransactionEnvelopeEip4844\n\n  assert(envelope_)\n\n  return {\n    ...envelope_,\n    ...(signature ? Signature.from(signature) : {}),\n    type: 'eip4844',\n  } as never\n}\n\nexport declare namespace from {\n  type Options<signature extends Signature.Signature | undefined = undefined> =\n    {\n      signature?: signature | Signature.Signature | undefined\n    }\n\n  type ReturnType<\n    envelope extends\n      | UnionPartialBy<TransactionEnvelopeEip4844, 'type'>\n      | Hex.Hex = TransactionEnvelopeEip4844 | Hex.Hex,\n    signature extends Signature.Signature | undefined = undefined,\n  > = Compute<\n    envelope extends Hex.Hex\n      ? TransactionEnvelopeEip4844\n      : Assign<\n          envelope,\n          (signature extends Signature.Signature ? Readonly<signature> : {}) & {\n            readonly type: 'eip4844'\n          }\n        >\n  >\n\n  type ErrorType =\n    | deserialize.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip4844.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nexport function getSignPayload(\n  envelope: TransactionEnvelopeEip4844,\n): getSignPayload.ReturnType {\n  return hash(envelope, { presign: true })\n}\n\nexport declare namespace getSignPayload {\n  type ReturnType = Hex.Hex\n\n  type ErrorType = hash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const hash = TransactionEnvelopeEip4844.hash(envelope) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-4844 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nexport function hash<presign extends boolean = false>(\n  envelope: TransactionEnvelopeEip4844<presign extends true ? false : true>,\n  options: hash.Options<presign> = {},\n): hash.ReturnType {\n  const { presign } = options\n  return Hash.keccak256(\n    serialize({\n      ...envelope,\n      ...(presign\n        ? {\n            sidecars: undefined,\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined,\n          }\n        : {}),\n    }),\n  )\n}\n\nexport declare namespace hash {\n  type Options<presign extends boolean = false> = {\n    /** Whether to hash this transaction for signing. @default false */\n    presign?: presign | boolean | undefined\n  }\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | serialize.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, TransactionEnvelopeEip4844 } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, Secp256k1, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const blobVersionedHashes = Blobs.sidecarsToVersionedHashes(blobs)\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   maxFeePerBlobGas: Value.fromGwei('3'),\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip4844.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip4844.serialize(envelope, { // [!code focus]\n *   sidecars, // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nexport function serialize(\n  envelope: PartialBy<TransactionEnvelopeEip4844, 'type'>,\n  options: serialize.Options = {},\n): Serialized {\n  const {\n    blobVersionedHashes,\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = envelope\n\n  assert(envelope)\n\n  const accessTupleList = AccessList.toTupleList(accessList)\n\n  const signature = Signature.extract(options.signature || envelope)\n\n  const serialized = [\n    Hex.fromNumber(chainId),\n    nonce ? Hex.fromNumber(nonce) : '0x',\n    maxPriorityFeePerGas ? Hex.fromNumber(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? Hex.fromNumber(maxFeePerGas) : '0x',\n    gas ? Hex.fromNumber(gas) : '0x',\n    to ?? '0x',\n    value ? Hex.fromNumber(value) : '0x',\n    data ?? '0x',\n    accessTupleList,\n    maxFeePerBlobGas ? Hex.fromNumber(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...(signature ? Signature.toTuple(signature) : []),\n  ] as const\n\n  const sidecars = options.sidecars || envelope.sidecars\n  const blobs: Hex.Hex[] = []\n  const commitments: Hex.Hex[] = []\n  const proofs: Hex.Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]!\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return Hex.concat(\n    '0x03',\n    sidecars\n      ? // If sidecars are provided, envelope turns into a \"network wrapper\":\n        Rlp.fromHex([serialized, blobs, commitments, proofs])\n      : // Otherwise, standard envelope is used:\n        Rlp.fromHex(serialized),\n  ) as Serialized\n}\n\nexport declare namespace serialize {\n  type Options = {\n    /** Signature to append to the serialized Transaction Envelope. */\n    signature?: Signature.Signature | undefined\n    /** Sidecars to append to the serialized Transaction Envelope. */\n    sidecars?: Blobs.BlobSidecars<Hex.Hex> | undefined\n  }\n\n  type ErrorType =\n    | assert.ErrorType\n    | Hex.fromNumber.ErrorType\n    | Signature.toTuple.ErrorType\n    | Hex.concat.ErrorType\n    | Rlp.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Converts an {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844} to an {@link ox#TransactionEnvelopeEip4844.Rpc}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs, RpcRequest, TransactionEnvelopeEip4844, Value } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const blobVersionedHashes = Blobs.toVersionedHashes(blobs, { kzg })\n *\n * const envelope = TransactionEnvelopeEip4844.from({\n *   blobVersionedHashes,\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerBlobGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip4844.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-4844 transaction envelope to convert.\n * @returns An RPC-formatted EIP-4844 transaction envelope.\n */\nexport function toRpc(envelope: Omit<TransactionEnvelopeEip4844, 'type'>): Rpc {\n  const signature = Signature.extract(envelope)\n\n  return {\n    ...envelope,\n    chainId: Hex.fromNumber(envelope.chainId),\n    data: envelope.data ?? envelope.input,\n    ...(typeof envelope.gas === 'bigint'\n      ? { gas: Hex.fromNumber(envelope.gas) }\n      : {}),\n    ...(typeof envelope.nonce === 'bigint'\n      ? { nonce: Hex.fromNumber(envelope.nonce) }\n      : {}),\n    ...(typeof envelope.value === 'bigint'\n      ? { value: Hex.fromNumber(envelope.value) }\n      : {}),\n    ...(typeof envelope.maxFeePerBlobGas === 'bigint'\n      ? { maxFeePerBlobGas: Hex.fromNumber(envelope.maxFeePerBlobGas) }\n      : {}),\n    ...(typeof envelope.maxFeePerGas === 'bigint'\n      ? { maxFeePerGas: Hex.fromNumber(envelope.maxFeePerGas) }\n      : {}),\n    ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n      ? { maxPriorityFeePerGas: Hex.fromNumber(envelope.maxPriorityFeePerGas) }\n      : {}),\n    type: '0x3',\n    ...(signature ? Signature.toRpc(signature) : {}),\n  } as never\n}\n\nexport declare namespace toRpc {\n  export type ErrorType = Signature.extract.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Validates a {@link ox#TransactionEnvelopeEip4844.TransactionEnvelopeEip4844}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip4844, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip4844.assert({\n *   blobVersionedHashes: [],\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nexport function validate(\n  envelope: PartialBy<TransactionEnvelopeEip4844, 'type'>,\n) {\n  try {\n    assert(envelope)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = Errors.GlobalErrorType\n}\n"],"mappings":";AAAA,OAAO,KAAKA,UAAU,MAAM,iBAAiB;AAC7C,OAAO,KAAKC,KAAK,MAAM,YAAY;AAEnC,OAAO,KAAKC,IAAI,MAAM,WAAW;AACjC,OAAO,KAAKC,GAAG,MAAM,UAAU;AAO/B,OAAO,KAAKC,GAAG,MAAM,UAAU;AAC/B,OAAO,KAAKC,GAAG,MAAM,UAAU;AAC/B,OAAO,KAAKC,SAAS,MAAM,gBAAgB;AAC3C,OAAO,KAAKC,mBAAmB,MAAM,0BAA0B;AAC/D,OAAO,KAAKC,0BAA0B,MAAM,iCAAiC;AAiC7E,OAAO,MAAMC,cAAc,GAAG,MAAe;AAK7C,OAAO,MAAMC,IAAI,GAAG,SAAkB;AAGtC;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUC,MAAMA,CACpBC,QAAuD;EAEvD,MAAM;IAAEC;EAAmB,CAAE,GAAGD,QAAQ;EACxC,IAAIC,mBAAmB,EAAE;IACvB,IAAIA,mBAAmB,CAACC,MAAM,KAAK,CAAC,EAClC,MAAM,IAAIb,KAAK,CAACc,6BAA6B,EAAE;IACjD,KAAK,MAAMC,IAAI,IAAIH,mBAAmB,EAAE;MACtC,MAAMI,IAAI,GAAGd,GAAG,CAACc,IAAI,CAACD,IAAI,CAAC;MAC3B,MAAME,OAAO,GAAGf,GAAG,CAACgB,QAAQ,CAAChB,GAAG,CAACiB,KAAK,CAACJ,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACnD,IAAIC,IAAI,KAAK,EAAE,EACb,MAAM,IAAIhB,KAAK,CAACoB,6BAA6B,CAAC;QAAEL,IAAI;QAAEC;MAAI,CAAE,CAAC;MAC/D,IAAIC,OAAO,KAAKd,GAAG,CAACkB,oBAAoB,EACtC,MAAM,IAAIrB,KAAK,CAACsB,gCAAgC,CAAC;QAC/CP,IAAI;QACJE;OACD,CAAC;IACN;EACF;EACAV,0BAA0B,CAACG,MAAM,CAC/BC,QAAuE,CACxE;AACH;AAcA;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUY,WAAWA,CACzBC,UAAsB;EAEtB,MAAMC,yBAAyB,GAAGrB,GAAG,CAACsB,KAAK,CAACxB,GAAG,CAACiB,KAAK,CAACK,UAAU,EAAE,CAAC,CAAC,CAAC;EAErE,MAAMG,iBAAiB,GAAGF,yBAAyB,CAACZ,MAAM,KAAK,CAAC;EAEhE,MAAMe,gBAAgB,GAAGD,iBAAiB,GACtCF,yBAAyB,CAAC,CAAC,CAAE,GAC7BA,yBAAyB;EAC7B,MAAMI,YAAY,GAAGF,iBAAiB,GAClCF,yBAAyB,CAACN,KAAK,CAAC,CAAC,CAAC,GAClC,EAAE;EAEN,MAAM,CACJW,OAAO,EACPC,KAAK,EACLC,oBAAoB,EACpBC,YAAY,EACZC,GAAG,EACHC,EAAE,EACFC,KAAK,EACLC,IAAI,EACJC,UAAU,EACVC,gBAAgB,EAChB3B,mBAAmB,EACnB4B,OAAO,EACPC,CAAC,EACDC,CAAC,CACF,GAAGd,gBAAgB;EACpB,MAAM,CAACe,KAAK,EAAEC,WAAW,EAAEC,MAAM,CAAC,GAAGhB,YAAY;EAEjD,IAAI,EAAED,gBAAgB,CAACf,MAAM,KAAK,EAAE,IAAIe,gBAAgB,CAACf,MAAM,KAAK,EAAE,CAAC,EACrE,MAAM,IAAIP,mBAAmB,CAACwC,sBAAsB,CAAC;IACnDC,UAAU,EAAAC,aAAA;MACRlB,OAAO;MACPC,KAAK;MACLC,oBAAoB;MACpBC,YAAY;MACZC,GAAG;MACHC,EAAE;MACFC,KAAK;MACLC,IAAI;MACJC;IAAU,GACNV,gBAAgB,CAACf,MAAM,GAAG,CAAC,GAC3B;MACE2B,OAAO;MACPC,CAAC;MACDC;KACD,GACD,EAAE,CACP;IACDlB,UAAU;IACVf;GACD,CAAC;EAEJ,IAAIwC,WAAW,GAAG;IAChBrC,mBAAmB,EAAEA,mBAAgC;IACrDkB,OAAO,EAAEoB,MAAM,CAACpB,OAAO,CAAC;IACxBrB;GAC6B;EAC/B,IAAIP,GAAG,CAACiD,QAAQ,CAAChB,EAAE,CAAC,IAAIA,EAAE,KAAK,IAAI,EAAEc,WAAW,CAACd,EAAE,GAAGA,EAAE;EACxD,IAAIjC,GAAG,CAACiD,QAAQ,CAACjB,GAAG,CAAC,IAAIA,GAAG,KAAK,IAAI,EAAEe,WAAW,CAACf,GAAG,GAAGkB,MAAM,CAAClB,GAAG,CAAC;EACpE,IAAIhC,GAAG,CAACiD,QAAQ,CAACd,IAAI,CAAC,IAAIA,IAAI,KAAK,IAAI,EAAEY,WAAW,CAACZ,IAAI,GAAGA,IAAI;EAChE,IAAInC,GAAG,CAACiD,QAAQ,CAACpB,KAAK,CAAC,EACrBkB,WAAW,CAAClB,KAAK,GAAGA,KAAK,KAAK,IAAI,GAAG,EAAE,GAAGqB,MAAM,CAACrB,KAAK,CAAC;EACzD,IAAI7B,GAAG,CAACiD,QAAQ,CAACf,KAAK,CAAC,IAAIA,KAAK,KAAK,IAAI,EAAEa,WAAW,CAACb,KAAK,GAAGgB,MAAM,CAAChB,KAAK,CAAC;EAC5E,IAAIlC,GAAG,CAACiD,QAAQ,CAACZ,gBAAgB,CAAC,IAAIA,gBAAgB,KAAK,IAAI,EAC7DU,WAAW,CAACV,gBAAgB,GAAGa,MAAM,CAACb,gBAAgB,CAAC;EACzD,IAAIrC,GAAG,CAACiD,QAAQ,CAAClB,YAAY,CAAC,IAAIA,YAAY,KAAK,IAAI,EACrDgB,WAAW,CAAChB,YAAY,GAAGmB,MAAM,CAACnB,YAAY,CAAC;EACjD,IAAI/B,GAAG,CAACiD,QAAQ,CAACnB,oBAAoB,CAAC,IAAIA,oBAAoB,KAAK,IAAI,EACrEiB,WAAW,CAACjB,oBAAoB,GAAGoB,MAAM,CAACpB,oBAAoB,CAAC;EACjE,IAAI,CAAAM,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEzB,MAAM,MAAK,CAAC,IAAIyB,UAAU,KAAK,IAAI,EACjDW,WAAW,CAACX,UAAU,GAAGvC,UAAU,CAACsD,aAAa,CAACf,UAAiB,CAAC;EACtE,IAAIK,KAAK,IAAIC,WAAW,IAAIC,MAAM,EAChCI,WAAW,CAACK,QAAQ,GAAGtD,KAAK,CAACuD,UAAU,CAACZ,KAAkB,EAAE;IAC1DC,WAAW,EAAEA,WAAwB;IACrCC,MAAM,EAAEA;GACT,CAAC;EAEJ,MAAMW,SAAS,GACbf,CAAC,IAAIC,CAAC,IAAIF,OAAO,GACbnC,SAAS,CAACoD,SAAS,CAAC,CAACjB,OAAkB,EAAEC,CAAY,EAAEC,CAAY,CAAC,CAAC,GACrEgB,SAAS;EACf,IAAIF,SAAS,EACXP,WAAW,GAAAD,aAAA,CAAAA,aAAA,KACNC,WAAW,GACXO,SAAS,CACiB;EAEjC9C,MAAM,CAACuC,WAAW,CAAC;EAEnB,OAAOA,WAAW;AACpB;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8FA,OAAM,SAAUU,IAAIA,CAMlBhD,QAGc,EACuB;EAAA,IAArCiD,OAAA,GAAAC,SAAA,CAAAhD,MAAA,QAAAgD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAmC,EAAE;EAErC,MAAM;IAAEL;EAAS,CAAE,GAAGI,OAAO;EAE7B,MAAME,SAAS,GACb,OAAOnD,QAAQ,KAAK,QAAQ,GAAGY,WAAW,CAACZ,QAAQ,CAAC,GAAGA,QAC1B;EAE/BD,MAAM,CAACoD,SAAS,CAAC;EAEjB,OAAAd,aAAA,CAAAA,aAAA,CAAAA,aAAA,KACKc,SAAS,GACRN,SAAS,GAAGnD,SAAS,CAACsD,IAAI,CAACH,SAAS,CAAC,GAAG,EAAE;IAC9C/C,IAAI,EAAE;EAAS;AAEnB;AA8BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,OAAM,SAAUsD,cAAcA,CAC5BpD,QAAoC;EAEpC,OAAOI,IAAI,CAACJ,QAAQ,EAAE;IAAEqD,OAAO,EAAE;EAAI,CAAE,CAAC;AAC1C;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA,OAAM,SAAUjD,IAAIA,CAClBJ,QAAyE,EACtC;EAAA,IAAnCiD,OAAA,GAAAC,SAAA,CAAAhD,MAAA,QAAAgD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAAiC,EAAE;EAEnC,MAAM;IAAEG;EAAO,CAAE,GAAGJ,OAAO;EAC3B,OAAO3D,IAAI,CAACgE,SAAS,CACnBC,SAAS,CAAAlB,aAAA,CAAAA,aAAA,KACJrC,QAAQ,GACPqD,OAAO,GACP;IACEV,QAAQ,EAAEI,SAAS;IACnBjB,CAAC,EAAEiB,SAAS;IACZhB,CAAC,EAAEgB,SAAS;IACZlB,OAAO,EAAEkB,SAAS;IAClBS,CAAC,EAAET;GACJ,GACD,EAAE,CACP,CAAC,CACH;AACH;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgEA,OAAM,SAAUQ,SAASA,CACvBvD,QAAuD,EACxB;EAAA,IAA/BiD,OAAA,GAAAC,SAAA,CAAAhD,MAAA,QAAAgD,SAAA,QAAAH,SAAA,GAAAG,SAAA,MAA6B,EAAE;EAE/B,MAAM;IACJjD,mBAAmB;IACnBkB,OAAO;IACPI,GAAG;IACHH,KAAK;IACLI,EAAE;IACFC,KAAK;IACLG,gBAAgB;IAChBN,YAAY;IACZD,oBAAoB;IACpBM,UAAU;IACVD;EAAI,CACL,GAAG1B,QAAQ;EAEZD,MAAM,CAACC,QAAQ,CAAC;EAEhB,MAAMyD,eAAe,GAAGrE,UAAU,CAACsE,WAAW,CAAC/B,UAAU,CAAC;EAE1D,MAAMkB,SAAS,GAAGnD,SAAS,CAACiE,OAAO,CAACV,OAAO,CAACJ,SAAS,IAAI7C,QAAQ,CAAC;EAElE,MAAMa,UAAU,GAAG,CACjBtB,GAAG,CAACqE,UAAU,CAACzC,OAAO,CAAC,EACvBC,KAAK,GAAG7B,GAAG,CAACqE,UAAU,CAACxC,KAAK,CAAC,GAAG,IAAI,EACpCC,oBAAoB,GAAG9B,GAAG,CAACqE,UAAU,CAACvC,oBAAoB,CAAC,GAAG,IAAI,EAClEC,YAAY,GAAG/B,GAAG,CAACqE,UAAU,CAACtC,YAAY,CAAC,GAAG,IAAI,EAClDC,GAAG,GAAGhC,GAAG,CAACqE,UAAU,CAACrC,GAAG,CAAC,GAAG,IAAI,EAChCC,EAAE,aAAFA,EAAE,cAAFA,EAAE,GAAI,IAAI,EACVC,KAAK,GAAGlC,GAAG,CAACqE,UAAU,CAACnC,KAAK,CAAC,GAAG,IAAI,EACpCC,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAI,IAAI,EACZ+B,eAAe,EACf7B,gBAAgB,GAAGrC,GAAG,CAACqE,UAAU,CAAChC,gBAAgB,CAAC,GAAG,IAAI,EAC1D3B,mBAAmB,aAAnBA,mBAAmB,cAAnBA,mBAAmB,GAAI,EAAE,EACzB,IAAI4C,SAAS,GAAGnD,SAAS,CAACmE,OAAO,CAAChB,SAAS,CAAC,GAAG,EAAE,CAAC,CAC1C;EAEV,MAAMF,QAAQ,GAAGM,OAAO,CAACN,QAAQ,IAAI3C,QAAQ,CAAC2C,QAAQ;EACtD,MAAMX,KAAK,GAAc,EAAE;EAC3B,MAAMC,WAAW,GAAc,EAAE;EACjC,MAAMC,MAAM,GAAc,EAAE;EAC5B,IAAIS,QAAQ,EACV,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,QAAQ,CAACzC,MAAM,EAAE4D,CAAC,EAAE,EAAE;IACxC,MAAM;MAAEC,IAAI;MAAEC,UAAU;MAAEC;IAAK,CAAE,GAAGtB,QAAQ,CAACmB,CAAC,CAAE;IAChD9B,KAAK,CAACkC,IAAI,CAACH,IAAI,CAAC;IAChB9B,WAAW,CAACiC,IAAI,CAACF,UAAU,CAAC;IAC5B9B,MAAM,CAACgC,IAAI,CAACD,KAAK,CAAC;EACpB;EAEF,OAAO1E,GAAG,CAAC4E,MAAM,CACf,MAAM,EACNxB,QAAQ;EACJ;EACAlD,GAAG,CAAC2E,OAAO,CAAC,CAACvD,UAAU,EAAEmB,KAAK,EAAEC,WAAW,EAAEC,MAAM,CAAC,CAAC;EACrD;EACAzC,GAAG,CAAC2E,OAAO,CAACvD,UAAU,CAAC,CACd;AACjB;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,OAAM,SAAUwD,KAAKA,CAACrE,QAAkD;EAAA,IAAAsE,cAAA;EACtE,MAAMzB,SAAS,GAAGnD,SAAS,CAACiE,OAAO,CAAC3D,QAAQ,CAAC;EAE7C,OAAAqC,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,CAAAA,aAAA,KACKrC,QAAQ;IACXmB,OAAO,EAAE5B,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAACmB,OAAO,CAAC;IACzCO,IAAI,GAAA4C,cAAA,GAAEtE,QAAQ,CAAC0B,IAAI,cAAA4C,cAAA,cAAAA,cAAA,GAAItE,QAAQ,CAACuE;EAAK,GACjC,OAAOvE,QAAQ,CAACuB,GAAG,KAAK,QAAQ,GAChC;IAAEA,GAAG,EAAEhC,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAACuB,GAAG;EAAC,CAAE,GACrC,EAAE,GACF,OAAOvB,QAAQ,CAACoB,KAAK,KAAK,QAAQ,GAClC;IAAEA,KAAK,EAAE7B,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAACoB,KAAK;EAAC,CAAE,GACzC,EAAE,GACF,OAAOpB,QAAQ,CAACyB,KAAK,KAAK,QAAQ,GAClC;IAAEA,KAAK,EAAElC,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAACyB,KAAK;EAAC,CAAE,GACzC,EAAE,GACF,OAAOzB,QAAQ,CAAC4B,gBAAgB,KAAK,QAAQ,GAC7C;IAAEA,gBAAgB,EAAErC,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAAC4B,gBAAgB;EAAC,CAAE,GAC/D,EAAE,GACF,OAAO5B,QAAQ,CAACsB,YAAY,KAAK,QAAQ,GACzC;IAAEA,YAAY,EAAE/B,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAACsB,YAAY;EAAC,CAAE,GACvD,EAAE,GACF,OAAOtB,QAAQ,CAACqB,oBAAoB,KAAK,QAAQ,GACjD;IAAEA,oBAAoB,EAAE9B,GAAG,CAACqE,UAAU,CAAC5D,QAAQ,CAACqB,oBAAoB;EAAC,CAAE,GACvE,EAAE;IACNvB,IAAI,EAAE;EAAK,GACP+C,SAAS,GAAGnD,SAAS,CAAC2E,KAAK,CAACxB,SAAS,CAAC,GAAG,EAAE;AAEnD;AAMA;;;;;;;;;;;;;;;;;;AAkBA,OAAM,SAAUL,QAAQA,CACtBxC,QAAuD;EAEvD,IAAI;IACFD,MAAM,CAACC,QAAQ,CAAC;IAChB,OAAO,IAAI;EACb,CAAC,CAAC,OAAAwE,OAAA,EAAM;IACN,OAAO,KAAK;EACd;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}