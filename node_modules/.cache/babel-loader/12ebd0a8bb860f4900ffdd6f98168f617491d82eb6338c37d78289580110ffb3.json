{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo } from 'react';\nimport { ethers } from 'ethers';\nimport { useWallet } from '../contexts/WalletContext';\nimport { MarketplaceSDK } from '../sdk/MarketplaceSDK';\nconst MARKETPLACE_ADDRESS = process.env.REACT_APP_MARKETPLACE_ADDRESS || '';\n// Support both naming variants found in env/example\nconst NFT_ADDRESS = process.env.REACT_APP_STR_DOMAIN_NFT_COLLECTION || process.env.REACT_APP_NFT_COLLECTION_ADDRESS || '';\nconst IS_DEV = process.env.NODE_ENV === 'development';\n\n/**\n * Custom hook to access the Marketplace SDK\n * Returns null if wallet is not connected\n */\nexport const useMarketplaceSDK = () => {\n  _s();\n  const {\n    signer\n  } = useWallet();\n  const sdk = useMemo(() => {\n    if (!MARKETPLACE_ADDRESS || !NFT_ADDRESS) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('Missing marketplace/NFT env addresses');\n      }\n      return null;\n    }\n    try {\n      if (signer) {\n        return new MarketplaceSDK(signer, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n      }\n\n      // Read-only fallback using RPC URL if available\n      const rpcUrl = process.env.REACT_APP_RPC_URL;\n      if (rpcUrl) {\n        var _getSigner, _ref;\n        const provider = new ethers.JsonRpcProvider(rpcUrl);\n        // Create a dummy signer bound to provider (read-only methods will still work using provider via signer.provider)\n        const dummySigner = ((_getSigner = (_ref = provider).getSigner) === null || _getSigner === void 0 ? void 0 : _getSigner.call(_ref)) || new ethers.Wallet.createRandom().connect(provider);\n        return new MarketplaceSDK(dummySigner, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n      }\n      return null;\n    } catch (error) {\n      console.error('Error creating Marketplace SDK:', error);\n      return null;\n    }\n  }, [signer]);\n  return sdk;\n};\n_s(useMarketplaceSDK, \"QyUWqqqdjz9otHWbpzA0nn8m4qY=\", false, function () {\n  return [useWallet];\n});\nexport default useMarketplaceSDK;","map":{"version":3,"names":["useMemo","ethers","useWallet","MarketplaceSDK","MARKETPLACE_ADDRESS","process","env","REACT_APP_MARKETPLACE_ADDRESS","NFT_ADDRESS","REACT_APP_STR_DOMAIN_NFT_COLLECTION","REACT_APP_NFT_COLLECTION_ADDRESS","IS_DEV","NODE_ENV","useMarketplaceSDK","_s","signer","sdk","console","warn","rpcUrl","REACT_APP_RPC_URL","_getSigner","_ref","provider","JsonRpcProvider","dummySigner","getSigner","call","Wallet","createRandom","connect","error"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/src/hooks/useMarketplaceSDK.ts"],"sourcesContent":["import { useMemo } from 'react';\nimport { ethers } from 'ethers';\nimport { useWallet } from '../contexts/WalletContext';\nimport { MarketplaceSDK } from '../sdk/MarketplaceSDK';\n\nconst MARKETPLACE_ADDRESS = process.env.REACT_APP_MARKETPLACE_ADDRESS || '';\n// Support both naming variants found in env/example\nconst NFT_ADDRESS =\n  process.env.REACT_APP_STR_DOMAIN_NFT_COLLECTION ||\n  process.env.REACT_APP_NFT_COLLECTION_ADDRESS ||\n  '';\nconst IS_DEV = process.env.NODE_ENV === 'development';\n\n/**\n * Custom hook to access the Marketplace SDK\n * Returns null if wallet is not connected\n */\nexport const useMarketplaceSDK = (): MarketplaceSDK | null => {\n  const { signer } = useWallet();\n\n  const sdk = useMemo(() => {\n    if (!MARKETPLACE_ADDRESS || !NFT_ADDRESS) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('Missing marketplace/NFT env addresses');\n      }\n      return null;\n    }\n\n    try {\n      if (signer) {\n        return new MarketplaceSDK(signer, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n      }\n\n      // Read-only fallback using RPC URL if available\n      const rpcUrl = process.env.REACT_APP_RPC_URL;\n      if (rpcUrl) {\n        const provider = new ethers.JsonRpcProvider(rpcUrl);\n        // Create a dummy signer bound to provider (read-only methods will still work using provider via signer.provider)\n        const dummySigner = (provider as any).getSigner?.() || (new ethers.Wallet.createRandom()).connect(provider);\n        return new MarketplaceSDK(dummySigner, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Error creating Marketplace SDK:', error);\n      return null;\n    }\n  }, [signer]);\n\n  return sdk;\n};\n\nexport default useMarketplaceSDK;\n\n"],"mappings":";AAAA,SAASA,OAAO,QAAQ,OAAO;AAC/B,SAASC,MAAM,QAAQ,QAAQ;AAC/B,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,cAAc,QAAQ,uBAAuB;AAEtD,MAAMC,mBAAmB,GAAGC,OAAO,CAACC,GAAG,CAACC,6BAA6B,IAAI,EAAE;AAC3E;AACA,MAAMC,WAAW,GACfH,OAAO,CAACC,GAAG,CAACG,mCAAmC,IAC/CJ,OAAO,CAACC,GAAG,CAACI,gCAAgC,IAC5C,EAAE;AACJ,MAAMC,MAAM,GAAGN,OAAO,CAACC,GAAG,CAACM,QAAQ,KAAK,aAAa;;AAErD;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAGA,CAAA,KAA6B;EAAAC,EAAA;EAC5D,MAAM;IAAEC;EAAO,CAAC,GAAGb,SAAS,CAAC,CAAC;EAE9B,MAAMc,GAAG,GAAGhB,OAAO,CAAC,MAAM;IACxB,IAAI,CAACI,mBAAmB,IAAI,CAACI,WAAW,EAAE;MACxC,IAAIH,OAAO,CAACC,GAAG,CAACM,QAAQ,KAAK,aAAa,EAAE;QAC1CK,OAAO,CAACC,IAAI,CAAC,uCAAuC,CAAC;MACvD;MACA,OAAO,IAAI;IACb;IAEA,IAAI;MACF,IAAIH,MAAM,EAAE;QACV,OAAO,IAAIZ,cAAc,CAACY,MAAM,EAAEX,mBAAmB,EAAEI,WAAW,EAAEG,MAAM,CAAC;MAC7E;;MAEA;MACA,MAAMQ,MAAM,GAAGd,OAAO,CAACC,GAAG,CAACc,iBAAiB;MAC5C,IAAID,MAAM,EAAE;QAAA,IAAAE,UAAA,EAAAC,IAAA;QACV,MAAMC,QAAQ,GAAG,IAAItB,MAAM,CAACuB,eAAe,CAACL,MAAM,CAAC;QACnD;QACA,MAAMM,WAAW,GAAG,EAAAJ,UAAA,IAAAC,IAAA,GAACC,QAAQ,EAASG,SAAS,cAAAL,UAAA,uBAA3BA,UAAA,CAAAM,IAAA,CAAAL,IAA8B,CAAC,KAAK,IAAIrB,MAAM,CAAC2B,MAAM,CAACC,YAAY,CAAC,CAAC,CAAEC,OAAO,CAACP,QAAQ,CAAC;QAC3G,OAAO,IAAIpB,cAAc,CAACsB,WAAW,EAAErB,mBAAmB,EAAEI,WAAW,EAAEG,MAAM,CAAC;MAClF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAOoB,KAAK,EAAE;MACdd,OAAO,CAACc,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvD,OAAO,IAAI;IACb;EACF,CAAC,EAAE,CAAChB,MAAM,CAAC,CAAC;EAEZ,OAAOC,GAAG;AACZ,CAAC;AAACF,EAAA,CAjCWD,iBAAiB;EAAA,QACTX,SAAS;AAAA;AAkC9B,eAAeW,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}