{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useMemo, useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport { useWallet } from '../contexts/WalletContext';\nimport { MarketplaceSDK } from '../sdk/MarketplaceSDK';\n\n// CRA exposes only env vars prefixed with REACT_APP_\nconst MARKETPLACE_ADDRESS = process.env.REACT_APP_MARKETPLACE_ADDRESS || '';\n// Support both naming variants found in env/example\nconst NFT_ADDRESS = process.env.REACT_APP_STR_DOMAIN_NFT_COLLECTION || process.env.REACT_APP_NFT_COLLECTION_ADDRESS || '';\nconst IS_DEV = process.env.NODE_ENV === 'development';\n\n/**\n * Custom hook to access the Marketplace SDK\n * Returns null if wallet is not connected\n */\nexport const useMarketplaceSDK = () => {\n  _s();\n  const {\n    signer,\n    provider,\n    account,\n    walletType,\n    isNetworkSwitching\n  } = useWallet();\n  const [sdkReady, setSdkReady] = useState(false);\n\n  // Delay SDK creation after network switches to allow provider to stabilize\n  useEffect(() => {\n    if (isNetworkSwitching) {\n      setSdkReady(false);\n    } else {\n      // Add a small delay after network switching completes\n      const timer = setTimeout(() => {\n        setSdkReady(true);\n      }, 1000);\n      return () => clearTimeout(timer);\n    }\n  }, [isNetworkSwitching]);\n  const sdk = useMemo(() => {\n    // Don't create SDK if network is switching or not ready\n    if (isNetworkSwitching || !sdkReady) {\n      return null;\n    }\n    if (!MARKETPLACE_ADDRESS || !NFT_ADDRESS) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('Missing marketplace/NFT env addresses', {\n          REACT_APP_MARKETPLACE_ADDRESS: process.env.REACT_APP_MARKETPLACE_ADDRESS,\n          REACT_APP_STR_DOMAIN_NFT_COLLECTION: process.env.REACT_APP_STR_DOMAIN_NFT_COLLECTION,\n          REACT_APP_NFT_COLLECTION_ADDRESS: process.env.REACT_APP_NFT_COLLECTION_ADDRESS\n        });\n      }\n      return null;\n    }\n    try {\n      // Only create SDK if we have a valid signer and account\n      if (signer && account && provider) {\n        console.log('Creating Marketplace SDK with:', {\n          walletType,\n          account,\n          hasSigner: !!signer,\n          hasProvider: !!provider\n        });\n        return new MarketplaceSDK(signer, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n      }\n\n      // Read-only fallback using RPC URL if available (for when wallet is not connected)\n      const rpcUrl = process.env.REACT_APP_RPC_URL;\n      if (rpcUrl) {\n        console.log('Creating read-only Marketplace SDK with RPC provider');\n        const provider = new ethers.JsonRpcProvider(rpcUrl);\n        // Create a dummy wallet connected to provider; avoids provider.getSigner() which throws on public RPC\n        const readOnlySigner = ethers.Wallet.createRandom().connect(provider);\n        const sdk = new MarketplaceSDK(readOnlySigner, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n        // Disable develop mode for read-only SDK to reduce console spam\n        sdk.setDevelopMode(false);\n        return sdk;\n      }\n      console.log('No valid signer or RPC URL available for Marketplace SDK');\n      return null;\n    } catch (error) {\n      console.error('Error creating Marketplace SDK:', error);\n      return null;\n    }\n  }, [signer, provider, account, walletType]);\n  return sdk;\n};\n_s(useMarketplaceSDK, \"dZyK2faw5qX3/WVTsS8LdD00YOw=\", false, function () {\n  return [useWallet];\n});\nexport default useMarketplaceSDK;","map":{"version":3,"names":["useMemo","useState","useEffect","ethers","useWallet","MarketplaceSDK","MARKETPLACE_ADDRESS","process","env","REACT_APP_MARKETPLACE_ADDRESS","NFT_ADDRESS","REACT_APP_STR_DOMAIN_NFT_COLLECTION","REACT_APP_NFT_COLLECTION_ADDRESS","IS_DEV","NODE_ENV","useMarketplaceSDK","_s","signer","provider","account","walletType","isNetworkSwitching","sdkReady","setSdkReady","timer","setTimeout","clearTimeout","sdk","console","warn","log","hasSigner","hasProvider","rpcUrl","REACT_APP_RPC_URL","JsonRpcProvider","readOnlySigner","Wallet","createRandom","connect","setDevelopMode","error"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/src/hooks/useMarketplaceSDK.ts"],"sourcesContent":["import { useMemo, useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport { useWallet } from '../contexts/WalletContext';\nimport { MarketplaceSDK } from '../sdk/MarketplaceSDK';\n\n// CRA exposes only env vars prefixed with REACT_APP_\nconst MARKETPLACE_ADDRESS = process.env.REACT_APP_MARKETPLACE_ADDRESS || '';\n// Support both naming variants found in env/example\nconst NFT_ADDRESS =\n  process.env.REACT_APP_STR_DOMAIN_NFT_COLLECTION ||\n  process.env.REACT_APP_NFT_COLLECTION_ADDRESS ||\n  '';\nconst IS_DEV = process.env.NODE_ENV === 'development';\n\n\n\n/**\n * Custom hook to access the Marketplace SDK\n * Returns null if wallet is not connected\n */\nexport const useMarketplaceSDK = (): MarketplaceSDK | null => {\n  const { signer, provider, account, walletType, isNetworkSwitching } = useWallet();\n  const [sdkReady, setSdkReady] = useState(false);\n\n  // Delay SDK creation after network switches to allow provider to stabilize\n  useEffect(() => {\n    if (isNetworkSwitching) {\n      setSdkReady(false);\n    } else {\n      // Add a small delay after network switching completes\n      const timer = setTimeout(() => {\n        setSdkReady(true);\n      }, 1000);\n      return () => clearTimeout(timer);\n    }\n  }, [isNetworkSwitching]);\n\n  const sdk = useMemo(() => {\n    // Don't create SDK if network is switching or not ready\n    if (isNetworkSwitching || !sdkReady) {\n      return null;\n    }\n    if (!MARKETPLACE_ADDRESS || !NFT_ADDRESS) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          'Missing marketplace/NFT env addresses',\n          {\n            REACT_APP_MARKETPLACE_ADDRESS: process.env.REACT_APP_MARKETPLACE_ADDRESS,\n            REACT_APP_STR_DOMAIN_NFT_COLLECTION: process.env.REACT_APP_STR_DOMAIN_NFT_COLLECTION,\n            REACT_APP_NFT_COLLECTION_ADDRESS: process.env.REACT_APP_NFT_COLLECTION_ADDRESS,\n          }\n        );\n      }\n      return null;\n    }\n\n    try {\n      // Only create SDK if we have a valid signer and account\n      if (signer && account && provider) {\n        console.log('Creating Marketplace SDK with:', {\n          walletType,\n          account,\n          hasSigner: !!signer,\n          hasProvider: !!provider\n        });\n        return new MarketplaceSDK(signer, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n      }\n\n      // Read-only fallback using RPC URL if available (for when wallet is not connected)\n      const rpcUrl = process.env.REACT_APP_RPC_URL;\n      if (rpcUrl) {\n        console.log('Creating read-only Marketplace SDK with RPC provider');\n        const provider = new ethers.JsonRpcProvider(rpcUrl);\n        // Create a dummy wallet connected to provider; avoids provider.getSigner() which throws on public RPC\n        const readOnlySigner = ethers.Wallet.createRandom().connect(provider);\n        const sdk = new MarketplaceSDK(readOnlySigner, MARKETPLACE_ADDRESS, NFT_ADDRESS, IS_DEV);\n        // Disable develop mode for read-only SDK to reduce console spam\n        sdk.setDevelopMode(false);\n        return sdk;\n      }\n\n      console.log('No valid signer or RPC URL available for Marketplace SDK');\n      return null;\n    } catch (error) {\n      console.error('Error creating Marketplace SDK:', error);\n      return null;\n    }\n  }, [signer, provider, account, walletType]);\n\n  return sdk;\n};\n\nexport default useMarketplaceSDK;\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}