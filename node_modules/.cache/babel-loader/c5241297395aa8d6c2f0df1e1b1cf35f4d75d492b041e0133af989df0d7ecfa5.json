{"ast":null,"code":"/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a) {\n  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';\n}\n/** Asserts something is boolean. */\nexport function abool(b) {\n  if (typeof b !== 'boolean') throw new Error(\"boolean expected, not \".concat(b));\n}\n/** Asserts something is positive integer. */\nexport function anumber(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nexport function abytes(b) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    lengths[_key - 1] = arguments[_key];\n  }\n  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h) {\n  if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance) {\n  let checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out, instance) {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr) {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr) {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean() {\n  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arrays[_key2] = arguments[_key2];\n  }\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE = /* @__PURE__ */(() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */(() =>\n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n  _0: 48,\n  _9: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction asciiToBase16(ch) {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n// Used in micro\nexport function hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n// Used in micro, ff1\nexport function numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes) {\n  return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);else if (isBytes(data)) data = copyBytes(data);else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a, b) {\n  return a.buffer === b.buffer &&\n  // best we can do, may fail with an obscure Proxy\n  a.byteOffset < b.byteOffset + b.byteLength &&\n  // a starts before b end\n  b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  ;\n}\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input, output) {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset) throw new Error('complex overlap of input and output is not supported');\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes() {\n  let sum = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    const a = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arguments.length; i++) {\n    const a = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\nexport function checkOpts(defaults, opts) {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport class Hash {}\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = (params, constructor) => {\n  function wrappedCipher(key) {\n    // Validate key\n    abytes(key);\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n    // Validate nonce if nonceLength is present\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);else abytes(nonce, params.nonceLength);\n    }\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength, output) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data, output) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return cipher.encrypt(data, output);\n      },\n      decrypt(data, output) {\n        abytes(data);\n        if (tagl && data.length < tagl) throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return cipher.decrypt(data, output);\n      }\n    };\n    return wrCipher;\n  }\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher;\n};\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(expectedLength, out) {\n  let onlyAligned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength) throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n/** Polyfill for Safari 14. */\nexport function setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\nexport function u64Lengths(dataLength, aadLength, isLE) {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(aadLength), isLE);\n  setBigUint64(view, 8, BigInt(dataLength), isLE);\n  return num;\n}\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes) {\n  return bytes.byteOffset % 4 === 0;\n}\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes) {\n  return Uint8Array.from(bytes);\n}","map":{"version":3,"names":["isBytes","a","Uint8Array","ArrayBuffer","isView","constructor","name","abool","b","Error","concat","anumber","n","Number","isSafeInteger","abytes","_len","arguments","length","lengths","Array","_key","includes","ahash","h","create","outputLen","blockLen","aexists","instance","checkFinished","undefined","destroyed","finished","aoutput","out","min","u8","arr","buffer","byteOffset","byteLength","u32","Uint32Array","Math","floor","clean","_len2","arrays","_key2","i","fill","createView","DataView","isLE","hasHexBuiltin","from","toHex","fromHex","hexes","_","toString","padStart","bytesToHex","bytes","hex","asciis","_0","_9","A","F","f","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","charCodeAt","n2","char","hexToNumber","BigInt","bytesToNumberBE","numberToBytesBE","len","nextTick","utf8ToBytes","str","TextEncoder","encode","bytesToUtf8","TextDecoder","decode","toBytes","data","copyBytes","overlapBytes","complexOverlapBytes","input","output","concatBytes","sum","res","pad","set","checkOpts","defaults","opts","merged","Object","assign","equalBytes","diff","Hash","wrapCipher","params","wrappedCipher","key","_len3","args","_key3","nonceLength","nonce","varSizeNonce","tagl","tagLength","cipher","checkOutput","fnLength","called","wrCipher","encrypt","decrypt","getOutput","expectedLength","onlyAligned","isAligned32","setBigUint64","view","value","_32n","_u32_max","wh","wl","l","setUint32","u64Lengths","dataLength","aadLength","num"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/@noble/ciphers/src/utils.ts"],"sourcesContent":["/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n// TODO: remove\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: string | Uint8Array): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = copyBytes(data);\n  else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key);\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);\n      else abytes(nonce, params.nonceLength);\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\n/** Polyfill for Safari 14. */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(aadLength), isLE);\n  setBigUint64(view, 8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}