{"ast":null,"code":"import * as Bytes from './Bytes.js';\nimport * as Errors from './Errors.js';\nimport * as Hash from './Hash.js';\nimport * as Hex from './Hex.js';\nimport * as Cursor from './internal/cursor.js';\nimport * as Kzg from './Kzg.js';\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6;\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32;\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096;\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction -\n// terminator byte (0x80).\n1 -\n// zero byte (0x00) appended to each field element.\n1 * fieldElementsPerBlob * blobsPerTransaction;\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes(commitments) {\n  var _options$as;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    version\n  } = options;\n  const as = (_options$as = options.as) !== null && _options$as !== void 0 ? _options$as : typeof commitments[0] === 'string' ? 'Hex' : 'Bytes';\n  const hashes = [];\n  for (const commitment of commitments) {\n    hashes.push(commitmentToVersionedHash(commitment, {\n      as,\n      version\n    }));\n  }\n  return hashes;\n}\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash(commitment) {\n  var _options$as2;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    version = 1\n  } = options;\n  const as = (_options$as2 = options.as) !== null && _options$as2 !== void 0 ? _options$as2 : typeof commitment === 'string' ? 'Hex' : 'Bytes';\n  const versionedHash = Hash.sha256(commitment, {\n    as: 'Bytes'\n  });\n  versionedHash.set([version], 0);\n  return as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash);\n}\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from(data) {\n  var _options$as3;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const as = (_options$as3 = options.as) !== null && _options$as3 !== void 0 ? _options$as3 : typeof data === 'string' ? 'Hex' : 'Bytes';\n  const data_ = typeof data === 'string' ? Bytes.fromHex(data) : data;\n  const size_ = Bytes.size(data_);\n  if (!size_) throw new EmptyBlobError();\n  if (size_ > maxBytesPerTransaction) throw new BlobSizeTooLargeError({\n    maxSize: maxBytesPerTransaction,\n    size: size_\n  });\n  const blobs = [];\n  let active = true;\n  let position = 0;\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob));\n    let size = 0;\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00);\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes);\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80);\n        active = false;\n        break;\n      }\n      size++;\n      position += 31;\n    }\n    blobs.push(blob);\n  }\n  return as === 'Bytes' ? blobs.map(x => x.bytes) : blobs.map(x => Hex.fromBytes(x.bytes));\n}\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes(sidecars) {\n  var _options$as4;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    version\n  } = options;\n  const as = (_options$as4 = options.as) !== null && _options$as4 !== void 0 ? _options$as4 : typeof sidecars[0].blob === 'string' ? 'Hex' : 'Bytes';\n  const hashes = [];\n  for (const {\n    commitment\n  } of sidecars) {\n    hashes.push(commitmentToVersionedHash(commitment, {\n      as,\n      version\n    }));\n  }\n  return hashes;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to(blobs, to) {\n  const to_ = to !== null && to !== void 0 ? to : typeof blobs[0] === 'string' ? 'Hex' : 'Bytes';\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0);\n  const data = Cursor.create(new Uint8Array(length));\n  let active = true;\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob);\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1);\n      let consume = 31;\n      if (blob.length - cursor.position < 31) consume = blob.length - cursor.position;\n      for (const _ in Array.from({\n        length: consume\n      })) {\n        const byte = cursor.readByte();\n        const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);\n        if (isTerminator) {\n          active = false;\n          break;\n        }\n        data.pushByte(byte);\n      }\n    }\n  }\n  const trimmedData = data.bytes.slice(0, data.position);\n  return to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData;\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(blobs) {\n  return to(blobs, 'Hex');\n}\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(blobs) {\n  return to(blobs, 'Bytes');\n}\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments(blobs, options) {\n  var _options$as5;\n  const {\n    kzg\n  } = options;\n  const as = (_options$as5 = options.as) !== null && _options$as5 !== void 0 ? _options$as5 : typeof blobs[0] === 'string' ? 'Hex' : 'Bytes';\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const commitments = [];\n  for (const blob of blobs_) commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\n  return as === 'Bytes' ? commitments : commitments.map(x => Hex.fromBytes(x));\n}\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs(blobs, options) {\n  var _options$as6;\n  const {\n    kzg\n  } = options;\n  const as = (_options$as6 = options.as) !== null && _options$as6 !== void 0 ? _options$as6 : typeof blobs[0] === 'string' ? 'Hex' : 'Bytes';\n  const blobs_ = typeof blobs[0] === 'string' ? blobs.map(x => Bytes.fromHex(x)) : blobs;\n  const commitments = typeof options.commitments[0] === 'string' ? options.commitments.map(x => Bytes.fromHex(x)) : options.commitments;\n  const proofs = [];\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i];\n    const commitment = commitments[i];\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\n  }\n  return as === 'Bytes' ? proofs : proofs.map(x => Hex.fromBytes(x));\n}\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars(blobs, options) {\n  var _options$commitments, _options$proofs;\n  const {\n    kzg\n  } = options;\n  const commitments = (_options$commitments = options.commitments) !== null && _options$commitments !== void 0 ? _options$commitments : toCommitments(blobs, {\n    kzg: kzg\n  });\n  const proofs = (_options$proofs = options.proofs) !== null && _options$proofs !== void 0 ? _options$proofs : toProofs(blobs, {\n    commitments: commitments,\n    kzg: kzg\n  });\n  const sidecars = [];\n  for (let i = 0; i < blobs.length; i++) sidecars.push({\n    blob: blobs[i],\n    commitment: commitments[i],\n    proof: proofs[i]\n  });\n  return sidecars;\n}\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes(blobs, options) {\n  const commitments = toCommitments(blobs, options);\n  return commitmentsToVersionedHashes(commitments, options);\n}\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  constructor(_ref) {\n    let {\n      maxSize,\n      size\n    } = _ref;\n    super('Blob size is too large.', {\n      metaMessages: [\"Max: \".concat(maxSize, \" bytes\"), \"Given: \".concat(size, \" bytes\")]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.BlobSizeTooLargeError'\n    });\n  }\n}\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  constructor() {\n    super('Blob data must not be empty.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.EmptyBlobError'\n    });\n  }\n}\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  constructor() {\n    super('Blob versioned hashes must not be empty.');\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.EmptyBlobVersionedHashesError'\n    });\n  }\n}\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  constructor(_ref2) {\n    let {\n      hash,\n      size\n    } = _ref2;\n    super(\"Versioned hash \\\"\".concat(hash, \"\\\" size is invalid.\"), {\n      metaMessages: ['Expected: 32', \"Received: \".concat(size)]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.InvalidVersionedHashSizeError'\n    });\n  }\n}\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  constructor(_ref3) {\n    let {\n      hash,\n      version\n    } = _ref3;\n    super(\"Versioned hash \\\"\".concat(hash, \"\\\" version is invalid.\"), {\n      metaMessages: [\"Expected: \".concat(Kzg.versionedHashVersion), \"Received: \".concat(version)]\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 'Blobs.InvalidVersionedHashVersionError'\n    });\n  }\n}","map":{"version":3,"names":["Bytes","Errors","Hash","Hex","Cursor","Kzg","blobsPerTransaction","bytesPerFieldElement","fieldElementsPerBlob","bytesPerBlob","maxBytesPerTransaction","commitmentsToVersionedHashes","commitments","_options$as","options","arguments","length","undefined","version","as","hashes","commitment","push","commitmentToVersionedHash","_options$as2","versionedHash","sha256","set","fromBytes","from","data","_options$as3","data_","fromHex","size_","size","EmptyBlobError","BlobSizeTooLargeError","maxSize","blobs","active","position","blob","create","Uint8Array","bytes","slice","pushByte","pushBytes","map","x","sidecarsToVersionedHashes","sidecars","_options$as4","to","to_","blobs_","reduce","cursor","incrementPosition","consume","_","Array","byte","readByte","isTerminator","inspectBytes","remaining","includes","trimmedData","toHex","toBytes","toCommitments","_options$as5","kzg","blobToKzgCommitment","toProofs","_options$as6","proofs","i","computeBlobKzgProof","toSidecars","_options$commitments","_options$proofs","proof","toVersionedHashes","BaseError","constructor","_ref","metaMessages","concat","Object","defineProperty","EmptyBlobVersionedHashesError","InvalidVersionedHashSizeError","_ref2","hash","InvalidVersionedHashVersionError","_ref3","versionedHashVersion"],"sources":["/Users/alex.codreanu/Desktop/marketplace-dapp/node_modules/ox/core/Blobs.ts"],"sourcesContent":["import * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Cursor from './internal/cursor.js'\nimport type { Compute, Mutable, OneOf, UnionCompute } from './internal/types.js'\nimport * as Kzg from './Kzg.js'\n\n/** Blob limit per transaction. */\nconst blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n\n/** Root type for a Blob. */\nexport type Blob<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  type\n\n/** A list of {@link ox#Blobs.Blob}. */\nexport type Blobs<type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes> =\n  readonly Blob<type>[]\n\n/** Type for a Blob Sidecar that contains a blob, as well as its KZG commitment and proof. */\nexport type BlobSidecar<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = Compute<{\n  /** The blob associated with the transaction. */\n  blob: type\n  /** The KZG commitment corresponding to this blob. */\n  commitment: type\n  /** The KZG proof corresponding to this blob and commitment. */\n  proof: type\n}>\n\n/**\n * Transform a list of Commitments to Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments) // [!code focus]\n * // @log: ['0x...', '0x...']\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentsToVersionedHashes(commitments, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitments - A list of commitments.\n * @param options - Options.\n * @returns A list of Blob Versioned Hashes.\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (commitments extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (commitments extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  commitments: commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  options: commitmentsToVersionedHashes.Options<as> = {},\n): commitmentsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof commitments[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as never,\n    )\n  }\n  return hashes as never\n}\n\nexport declare namespace commitmentsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transform a Commitment to its Blob Versioned Hash.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHash = Blobs.commitmentToVersionedHash(commitment) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hash with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hash with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const [commitment] = Blobs.toCommitments(blobs, { kzg })\n * const versionedHashes = Blobs.commitmentToVersionedHash(commitment, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param commitment - The commitment.\n * @param options - Options.\n * @returns The Blob Versioned Hash.\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (commitment extends Hex.Hex ? 'Hex' : never)\n    | (commitment extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  commitment: commitment | Hex.Hex | Bytes.Bytes,\n  options: commitmentToVersionedHash.Options<as> = {},\n): commitmentToVersionedHash.ReturnType<as> {\n  const { version = 1 } = options\n  const as = options.as ?? (typeof commitment === 'string' ? 'Hex' : 'Bytes')\n\n  const versionedHash = Hash.sha256(commitment, { as: 'Bytes' })\n  versionedHash.set([version], 0)\n  return (\n    as === 'Bytes' ? versionedHash : Hex.fromBytes(versionedHash)\n  ) as commitmentToVersionedHash.ReturnType<as>\n}\n\nexport declare namespace commitmentToVersionedHash {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hash. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? Bytes.Bytes : never)\n    | (as extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Transforms arbitrary data to {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * ```\n *\n * @example\n * ### Creating Blobs from a String\n *\n * An example of creating Blobs from a string using  {@link ox#Hex.(from:function)}:\n *\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from(Hex.fromString('Hello world!'))\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Blobs with the `as` option.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef', { as: 'Bytes' })\n * //    ^?\n *\n *\n * ```\n *\n * @param data - The data to convert to {@link ox#Blobs.Blobs}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.Blobs}.\n */\nexport function from<\n  const data extends Hex.Hex | Bytes.Bytes,\n  as extends 'Hex' | 'Bytes' =\n    | (data extends Hex.Hex ? 'Hex' : never)\n    | (data extends Bytes.Bytes ? 'Bytes' : never),\n>(\n  data: data | Hex.Hex | Bytes.Bytes,\n  options: from.Options<as> = {},\n): from.ReturnType<as> {\n  const as = options.as ?? (typeof data === 'string' ? 'Hex' : 'Bytes')\n  const data_ = (\n    typeof data === 'string' ? Bytes.fromHex(data) : data\n  ) as Bytes.Bytes\n\n  const size_ = Bytes.size(data_)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = Cursor.create(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    as === 'Bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => Hex.fromBytes(x.bytes))\n  ) as never\n}\n\nexport declare namespace from {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | BlobSizeTooLargeError\n    | EmptyBlobError\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Cursor.create.ErrorType\n    | Bytes.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms a list of {@link ox#Blobs.BlobSidecars} to their Blob Versioned Hashes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type for the Versioned Hashes with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   as: 'Bytes', // [!code focus]\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @example\n * ### Versioning Hashes\n *\n * It is possible to configure the version for the Versioned Hashes with the `version` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg })\n * const versionedHashes = Blobs.sidecarsToVersionedHashes(sidecars, {\n *   version: 2, // [!code focus]\n * })\n * ```\n *\n * @param sidecars - The {@link ox#Blobs.BlobSidecars} to transform to Blob Versioned Hashes.\n * @param options - Options.\n * @returns The versioned hashes.\n */\nexport function sidecarsToVersionedHashes<\n  const sidecars extends BlobSidecars,\n  as extends 'Hex' | 'Bytes' =\n    | (sidecars extends BlobSidecars<Hex.Hex> ? 'Hex' : never)\n    | (sidecars extends BlobSidecars<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  sidecars: sidecars | BlobSidecars,\n  options: sidecarsToVersionedHashes.Options<as> = {},\n): sidecarsToVersionedHashes.ReturnType<as> {\n  const { version } = options\n\n  const as =\n    options.as ?? (typeof sidecars[0]!.blob === 'string' ? 'Hex' : 'Bytes')\n\n  const hashes: Uint8Array[] | Hex.Hex[] = []\n  for (const { commitment } of sidecars) {\n    hashes.push(\n      commitmentToVersionedHash(commitment, {\n        as,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n\nexport declare namespace sidecarsToVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' | undefined = undefined> = {\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n    /** Version to tag onto the hashes. */\n    version?: number | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType = commitmentToVersionedHash.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with second argument.\n *\n * ```ts twoslash\n * import { Blobs } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.to(blobs, 'Bytes')\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform.\n * @param to - The type to transform to.\n * @returns The originating data.\n */\nexport function to<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n  to?: to | 'Hex' | 'Bytes' | undefined,\n): to.ReturnType<to> {\n  const to_ = to ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as Hex.Hex))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const length = blobs_.reduce((length, blob) => length + blob.length, 0)\n  const data = Cursor.create(new Uint8Array(length))\n  let active = true\n\n  for (const blob of blobs_) {\n    const cursor = Cursor.create(blob)\n    while (active && cursor.position < blob.length) {\n      // First byte will be a zero 0x00 byte – we can skip.\n      cursor.incrementPosition(1)\n\n      let consume = 31\n      if (blob.length - cursor.position < 31)\n        consume = blob.length - cursor.position\n\n      for (const _ in Array.from({ length: consume })) {\n        const byte = cursor.readByte()\n        const isTerminator =\n          byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80)\n        if (isTerminator) {\n          active = false\n          break\n        }\n        data.pushByte(byte)\n      }\n    }\n  }\n\n  const trimmedData = data.bytes.slice(0, data.position)\n  return (to_ === 'Hex' ? Hex.fromBytes(trimmedData) : trimmedData) as never\n}\n\nexport declare namespace to {\n  type ReturnType<to extends 'Hex' | 'Bytes' = 'Hex'> =\n    | (to extends 'Bytes' ? Bytes.Bytes : never)\n    | (to extends 'Hex' ? Hex.Hex : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Cursor.create.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts twoslash\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toHex(blobs) // [!code focus]\n * // @log: '0xdeadbeef'\n * ```\n */\nexport function toHex(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toHex.ReturnType {\n  return to(blobs, 'Hex')\n}\n\nexport declare namespace toHex {\n  type ReturnType = to.ReturnType<'Hex'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Transforms Ox-shaped {@link ox#Blobs.Blobs} into the originating data.\n *\n * @example\n * ```ts\n * import { Blobs, Hex } from 'ox'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const data = Blobs.toBytes(blobs) // [!code focus]\n * // @log: Uint8Array [ 13, 174, 190, 239 ]\n * ```\n */\nexport function toBytes(\n  blobs: Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n): toBytes.ReturnType {\n  return to(blobs, 'Bytes')\n}\n\n/**\n * Compute commitments from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * ### Configuring Return Type\n *\n * It is possible to configure the return type with the `as` option.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, {\n *   as: 'Bytes', // [!code focus]\n *   kzg,\n * })\n * // @log: [Uint8Array [ ... ], Uint8Array [ ... ]]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform to commitments.\n * @param options - Options.\n * @returns The commitments.\n */\nexport function toCommitments<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toCommitments.Options<as>,\n): toCommitments.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n\n  const commitments: Bytes.Bytes[] = []\n  for (const blob of blobs_)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (\n    as === 'Bytes' ? commitments : commitments.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toCommitments {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | Bytes.fromHex.ErrorType\n    | Hex.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\nexport declare namespace toBytes {\n  type ReturnType = to.ReturnType<'Bytes'>\n  type ErrorType = to.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Compute the proofs for a list of {@link ox#Blobs.Blobs} and their commitments.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to compute proofs for.\n * @param options - Options.\n * @returns The Blob proofs.\n */\nexport function toProofs<\n  const blobs extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  const commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[],\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends readonly Hex.Hex[] ? 'Hex' : never)\n    | (blobs extends readonly Bytes.Bytes[] ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toProofs.Options<blobs, commitments, as>,\n): toProofs.ReturnType<as> {\n  const { kzg } = options\n\n  const as = options.as ?? (typeof blobs[0] === 'string' ? 'Hex' : 'Bytes')\n\n  const blobs_ = (\n    typeof blobs[0] === 'string'\n      ? blobs.map((x) => Bytes.fromHex(x as any))\n      : blobs\n  ) as Bytes.Bytes[]\n  const commitments = (\n    typeof options.commitments[0] === 'string'\n      ? options.commitments.map((x) => Bytes.fromHex(x as any))\n      : options.commitments\n  ) as Bytes.Bytes[]\n\n  const proofs: Bytes.Bytes[] = []\n  for (let i = 0; i < blobs_.length; i++) {\n    const blob = blobs_[i]!\n    const commitment = commitments[i]!\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (\n    as === 'Bytes' ? proofs : proofs.map((x) => Hex.fromBytes(x))\n  ) as never\n}\n\nexport declare namespace toProofs {\n  type Options<\n    blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex> =\n      | Blobs<Bytes.Bytes>\n      | Blobs<Hex.Hex>,\n    commitments extends readonly Bytes.Bytes[] | readonly Hex.Hex[] =\n      | readonly Bytes.Bytes[]\n      | readonly Hex.Hex[],\n    as extends 'Hex' | 'Bytes' =\n      | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n  > = {\n    /** Commitments for the blobs. */\n    commitments: (commitments | readonly Bytes.Bytes[] | readonly Hex.Hex[]) &\n      (commitments extends blobs\n        ? {}\n        : `commitments must be the same type as blobs`)\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'computeBlobKzgProof'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex' | 'Bytes'> =\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n\n  type ErrorType =\n    | Hex.fromBytes.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Transforms {@link ox#Blobs.Blobs} into a {@link ox#Blobs.BlobSidecars} array.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const sidecars = Blobs.toSidecars(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @example\n * You can also provide your own commitments and proofs if you do not want `toSidecars`\n * to compute them.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const commitments = Blobs.toCommitments(blobs, { kzg })\n * const proofs = Blobs.toProofs(blobs, { commitments, kzg })\n *\n * const sidecars = Blobs.toSidecars(blobs, { commitments, kzg, proofs }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into {@link ox#Blobs.BlobSidecars}.\n * @param options - Options.\n * @returns The {@link ox#Blobs.BlobSidecars}.\n */\nexport function toSidecars<\n  const blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>,\n>(\n  blobs: blobs,\n  options: toSidecars.Options<blobs>,\n): toSidecars.ReturnType<blobs> {\n  const { kzg } = options\n\n  const commitments = options.commitments ?? toCommitments(blobs, { kzg: kzg! })\n  const proofs =\n    options.proofs ??\n    toProofs(blobs, { commitments: commitments as any, kzg: kzg! })\n\n  const sidecars: Mutable<BlobSidecars> = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i]!,\n      commitment: commitments[i]!,\n      proof: proofs[i]!,\n    })\n\n  return sidecars as never\n}\n\nexport declare namespace toSidecars {\n  type Options<\n    blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes> =\n      | Blobs<Hex.Hex>\n      | Blobs<Bytes.Bytes>,\n  > = {\n    kzg?: Kzg.Kzg | undefined\n  } & OneOf<\n    | {}\n    | {\n        /** Commitment for each blob. */\n        commitments: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n        /** Proof for each blob. */\n        proofs: blobs | readonly Hex.Hex[] | readonly Bytes.Bytes[]\n      }\n  >\n\n  type ReturnType<blobs extends Blobs<Hex.Hex> | Blobs<Bytes.Bytes>> =\n    UnionCompute<\n      | (blobs extends Blobs<Hex.Hex> ? BlobSidecars<Hex.Hex> : never)\n      | (blobs extends Blobs<Bytes.Bytes> ? BlobSidecars<Bytes.Bytes> : never)\n    >\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Compute Blob Versioned Hashes from a list of {@link ox#Blobs.Blobs}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Blobs } from 'ox'\n * import { kzg } from './kzg'\n *\n * const blobs = Blobs.from('0xdeadbeef')\n * const versionedHashes = Blobs.toVersionedHashes(blobs, { kzg }) // [!code focus]\n * ```\n *\n * @param blobs - The {@link ox#Blobs.Blobs} to transform into Blob Versioned Hashes.\n * @param options - Options.\n * @returns The Blob Versioned Hashes.\n */\nexport function toVersionedHashes<\n  const blobs extends Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  as extends 'Hex' | 'Bytes' =\n    | (blobs extends Blobs<Hex.Hex> ? 'Hex' : never)\n    | (blobs extends Blobs<Bytes.Bytes> ? 'Bytes' : never),\n>(\n  blobs: blobs | Blobs<Bytes.Bytes> | Blobs<Hex.Hex>,\n  options: toVersionedHashes.Options<as>,\n): toVersionedHashes.ReturnType<as> {\n  const commitments = toCommitments(blobs, options)\n  return commitmentsToVersionedHashes(commitments, options)\n}\n\nexport declare namespace toVersionedHashes {\n  type Options<as extends 'Hex' | 'Bytes' = 'Hex'> = {\n    /** KZG implementation. */\n    kzg: Pick<Kzg.Kzg, 'blobToKzgCommitment'>\n    /** Return type. */\n    as?: as | 'Hex' | 'Bytes' | undefined\n  }\n\n  type ReturnType<as extends 'Hex' | 'Bytes' = 'Hex'> = Compute<\n    | (as extends 'Bytes' ? readonly Bytes.Bytes[] : never)\n    | (as extends 'Hex' ? readonly Hex.Hex[] : never)\n  >\n\n  type ErrorType =\n    | toCommitments.ErrorType\n    | commitmentsToVersionedHashes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** A list of {@link ox#Blobs.BlobSidecar}. */\nexport type BlobSidecars<\n  type extends Hex.Hex | Bytes.Bytes = Hex.Hex | Bytes.Bytes,\n> = readonly Compute<BlobSidecar<type>>[]\n\n/** Thrown when the blob size is too large. */\nexport class BlobSizeTooLargeError extends Errors.BaseError {\n  override readonly name = 'Blobs.BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\n/** Thrown when the blob is empty. */\nexport class EmptyBlobError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hashes are empty. */\nexport class EmptyBlobVersionedHashesError extends Errors.BaseError {\n  override readonly name = 'Blobs.EmptyBlobVersionedHashesError'\n  constructor() {\n    super('Blob versioned hashes must not be empty.')\n  }\n}\n\n/** Thrown when the blob versioned hash size is invalid. */\nexport class InvalidVersionedHashSizeError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hex.Hex\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\n/** Thrown when the blob versioned hash version is invalid. */\nexport class InvalidVersionedHashVersionError extends Errors.BaseError {\n  override readonly name = 'Blobs.InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hex.Hex\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${Kzg.versionedHashVersion}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}